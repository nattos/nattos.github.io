{"version":3,"file":"magneto-editor-67PDQltL.js","sources":["../../src/customnodes/nicepattern/magneto-editor.ts"],"sourcesContent":["import { LitElement, html, css, PropertyValueMap } from 'lit';\nimport { customElement, property, state, query } from 'lit/decorators.js';\nimport { GridNode } from '../../builder/state';\nimport { runtimeManager } from '../../builder/controllers';\nimport { appController } from '../../builder/controllers';\n\n@customElement('nicepattern-magneto-editor')\nexport class MagnetoEditor extends LitElement {\n    @property({ type: Object }) node!: GridNode;\n    @query('#sim-canvas') simCanvas!: HTMLCanvasElement;\n    @query('#adsr-canvas') adsrCanvas!: HTMLCanvasElement;\n    @query('#history-canvas') historyCanvas!: HTMLCanvasElement;\n\n    private cleanup: (() => void) | null = null;\n    private animationFrame: number | null = null;\n\n    // Simulation State\n    // History for Graph\n    private history: {t: number, e: number, fs: number, fm: number}[] = new Array(200).fill({t:0, e:0, fs:0, fm:0});\n\n    // Interaction State\n    private dragging: 'attack' | 'decay' | 'sustain' | 'release' | null = null;\n    private dragOrigin: { peak: number, sustain: number } | null = null;\n    private longEdit: any = null;\n\n    private spheres: any[] = [];\n    private plateY: number = 0;\n    private phase: string = 'IDLE';\n    private sustainProgress: number = 0;\n\n    // ADSR State (Visualization only for now, sourced from worker feedback or config)\n    private adsr: any = { attack: 0.2, decay: 0.25, sustain: 0.6, release: 0.3, peak: 0.9 };\n\n    static styles = css`\n        :host {\n            display: flex;\n            flex-direction: column;\n            height: 100%;\n            background: #050505;\n            color: #888;\n            font-family: \"Space Mono\", \"JetBrains Mono\", monospace;\n            font-size: 10px;\n            user-select: none;\n            position: relative;\n            pointer-events: auto;\n            touch-action: none; /* Prevent scrolling during interaction */\n        }\n\n        canvas {\n            display: block;\n            width: 100%;\n            height: 100%;\n            touch-action: none;\n        }\n\n        .panel {\n            background: #0a0a0a;\n            border-bottom: 1px solid #333;\n            position: relative;\n            width: 100%;\n            overflow: hidden;\n            touch-action: none;\n        }\n\n        .header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding: 4px 6px;\n            background: #000;\n            border-bottom: 1px solid #222;\n            flex-shrink: 0;\n            height: 20px;\n            box-sizing: border-box;\n        }\n\n        .status {\n            font-size: 9px;\n            font-weight: bold;\n            color: #444;\n        }\n        .status.active { color: #00ff00; }\n\n        .param-label {\n            position: absolute;\n            top: 2px; right: 4px;\n            font-size: 8px;\n            color: #555;\n            pointer-events: none;\n        }\n\n        .legend {\n            position: absolute;\n            top: 2px;\n            left: 2px;\n            display: flex;\n            gap: 4px;\n            pointer-events: none;\n        }\n        .dot { width: 4px; height: 4px; margin-top: 3px; }\n    `;\n\n    connectedCallback() {\n        super.connectedCallback();\n        this.startLoop();\n        this.addEventListener('dblclick', this.handleDblClick);\n    }\n\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        if (this.animationFrame) cancelAnimationFrame(this.animationFrame);\n        this.removeEventListener('dblclick', this.handleDblClick);\n    }\n\n    private handleDblClick = (e: Event) => {\n        e.stopPropagation();\n    }\n\n    private startLoop() {\n        const loop = () => {\n            if (!this.isConnected) return;\n            this.animationFrame = requestAnimationFrame(loop);\n\n            const uiState = runtimeManager.uiStates.get(this.node.id);\n            if (uiState) {\n                if (uiState.spheres) this.spheres = uiState.spheres;\n                if (typeof uiState.plateY === 'number') this.plateY = uiState.plateY;\n                if (uiState.phase) this.phase = uiState.phase;\n                if (typeof uiState.sustainProgress === 'number') this.sustainProgress = uiState.sustainProgress;\n\n                // Only update ADSR if we are NOT dragging (prevent fighting)\n                if (!this.dragging && uiState.adsr) this.adsr = uiState.adsr;\n\n                this.updateHistory(); // Pull latest output from RuntimeManager for graph\n                this.drawSim();\n                this.drawHistory();\n                this.drawADSR();\n                this.requestUpdate();\n            }\n        };\n        loop();\n    }\n\n    private updateHistory() {\n        // We need the output values. UI state sends them? No, UI state sends spheres/plate.\n        // We can get outputs from runtimeManager.outputs.get(id)\n        const outputs = runtimeManager.outputs.get(this.node.id);\n        if (outputs && outputs.fields) {\n            this.history.push({\n                t: outputs.fields.env ?? 0,\n                e: outputs.fields.ch2 ?? 0,\n                fs: outputs.fields.ch3 ?? 0,\n                fm: outputs.fields.ch4 ?? 0\n            });\n            if(this.history.length > 200) this.history.shift();\n        }\n    }\n\n    // Explicitly handle resize if needed, though grid handles it via size changes\n    firstUpdated() {\n        this.resizeCanvases();\n        // Bind events if not using @ syntax\n        if (this.adsrCanvas) {\n            // Note: We use arrow functions or bind in render usually, but manual add works too.\n            // Using @pointerdown in render is cleaner for Lit.\n        }\n    }\n\n    private resizeCanvases() {\n        const resize = (c: HTMLCanvasElement) => {\n            if(!c) return;\n            // Force read from offsetWidth/Height to ensure we get pixel size\n            const w = c.offsetWidth;\n            const h = c.offsetHeight;\n            // Only update if changed and non-zero (to avoid flicker or gone)\n            if (w > 0 && h > 0 && (c.width !== w || c.height !== h)) {\n                c.width = w;\n                c.height = h;\n            }\n        };\n        resize(this.simCanvas);\n        resize(this.adsrCanvas);\n        resize(this.historyCanvas);\n    }\n\n    // --- INTERACTION ---\n\n    private handleADSRDown(e: PointerEvent) {\n        // Stop propagation to prevent node drag\n        e.preventDefault();\n        e.stopPropagation();\n        (e.target as Element).setPointerCapture(e.pointerId);\n        this.handleADSRInput(e, true);\n    }\n\n    private handleADSRMove(e: PointerEvent) {\n        e.preventDefault();\n        e.stopPropagation();\n        if(this.dragging) this.handleADSRInput(e, false);\n    }\n\n    private handleADSRUp(e: PointerEvent) {\n        e.stopPropagation(); // Prevent partial drags affecting node\n        this.dragging = null;\n        this.dragOrigin = null;\n        if (this.longEdit) {\n            this.longEdit.accept();\n            this.longEdit = null;\n        }\n        (e.target as Element).releasePointerCapture(e.pointerId);\n    }\n\n    private handleADSRInput(e: PointerEvent, isDown: boolean) {\n        const rect = this.adsrCanvas.getBoundingClientRect();\n        const w = rect.width;\n        const h = rect.height;\n        if(w === 0 || h === 0) return;\n\n        // Normalized Inputs\n        const xNorm = (e.clientX - rect.left) / w;\n        const yNorm = (e.clientY - rect.top) / h;\n\n        const { attack, decay, sustain, release, peak } = this.adsr;\n\n        // FIXED TIME WINDOW (1.5s) - Decouples layout from values\n        const VIEW_DURATION = 1.5;\n        const timeAtCursor = xNorm * VIEW_DURATION;\n\n        // Visual Layout with Minimum Widths\n        const MIN_VIS_W = 0.05; // 50ms min visual width\n        const visA = Math.max(attack, MIN_VIS_W);\n        const visD = Math.max(decay, MIN_VIS_W);\n        const visS = 0.5; // Fixed sustain visual width\n\n        // Handle Positions (in Time domain)\n        const tA = visA;\n        const tD = visA + visD;\n        const tS = tD + visS;\n        // const tR = tS + release; // End of graph\n\n        if (isDown) {\n            this.dragOrigin = { peak, sustain };\n\n            // Hit Testing (Distance in Time Domain)\n            // 0.2s threshold for easier grabbing\n            const HIT_THRESH = 0.2;\n            let closestDist = HIT_THRESH;\n            let target = null;\n\n            // Attack Handle (at tA)\n            const distA = Math.abs(timeAtCursor - tA);\n            if(distA < closestDist) { closestDist = distA; target = 'attack'; }\n\n            // Decay Handle (at tD)\n            const distD = Math.abs(timeAtCursor - tD);\n            if(distD < closestDist) { closestDist = distD; target = 'decay'; }\n\n            // Release Drag (Sustain/Release Junction at tS)\n            // We drag the \"start of release\" to set release time?\n            // Actually, usually we drag the TAIL of release to set release time.\n            // Or drag the start of release to... change sustain width? No, S is fixed.\n            // In prev logic: 'release' target set `release`.\n            // Previous code: `const dRelease = Math.abs(x - xS);` -> xS is start of release.\n            // So we click the \"Corner\" between Sustain and Release.\n            // And then drag to set Release duration?\n            // \"if dragging release... newRelease = timeAtCursor - tStartRelease\"\n            // So if I click start, length is 0?\n            // Maybe we should allow clicking ANYWHERE in the release tail?\n            // Let's stick to handle first. \"Sustain End / Release Start\" handle.\n            const distS = Math.abs(timeAtCursor - tS);\n            if(distS < closestDist) { closestDist = distS; target = 'release'; }\n\n            // Sustain Y-axis (Priority if X matches Sustain zone)\n            if (!target && timeAtCursor > tD && timeAtCursor < tS) {\n                target = 'sustain';\n            }\n\n            // Fallback: If clicking loosely near segments\n            if(!target) {\n                if (timeAtCursor < tA) target = 'attack';\n                else if (timeAtCursor < tD) target = 'decay';\n                else if (timeAtCursor > tS) target = 'release';\n            }\n\n            this.dragging = target as any;\n        }\n\n        if (!this.dragging) return;\n\n        // Apply Logic using LINEAR MAPPING\n        const updates: any = {};\n        const config = this.node.config.values || {};\n\n        if (this.dragging === 'attack') {\n            // Dragging A handle sets Attack Time\n            const newAttack = Math.max(0.01, timeAtCursor);\n            updates.attack = newAttack;\n\n            const newPeak = Math.max(0.1, Math.min(1.0, yNorm));\n            updates.peak = newPeak;\n\n            // Rubber band\n            if (sustain > newPeak) updates.sustain = newPeak;\n            else if (this.dragOrigin) updates.sustain = Math.min(newPeak, this.dragOrigin.sustain);\n\n        } else if (this.dragging === 'decay') {\n             // Dragging D handle sets Attack + Decay point\n             // Decay = Cursor - Attack\n             // But Attack is fixed during this drag? Yes.\n             const newDecay = Math.max(0.01, timeAtCursor - attack);\n             updates.decay = newDecay;\n\n        } else if (this.dragging === 'sustain') {\n             const newSus = Math.max(0.0, Math.min(1.0, yNorm));\n             updates.sustain = newSus;\n\n             if (newSus > peak) updates.peak = newSus;\n             else if (this.dragOrigin) updates.peak = Math.max(newSus, this.dragOrigin.peak);\n\n        } else if (this.dragging === 'release') {\n             // Dragging S/R junction?\n             // If we treat this handle as \"Release Length controller\",\n             // We want it to behave like dragging the END of release?\n             // BUT we clicked the START (tS).\n             // If I click tS and drag right, I expect release to grow?\n             // Logic: newRelease = timeAtCursor - tS?\n             // Since tS is fixed (A+D+S_viz), dragging right from there increases R.\n             // This works.\n             const tStartRelease = attack + decay + 0.5;\n             const newRelease = Math.max(0.01, timeAtCursor - tStartRelease);\n             updates.release = newRelease;\n        }\n        // Commit Update (Long Edit)\n        const action = (c: any) => {\n             c.setNodeConfig(this.node.id, { values: { ...config, ...updates } });\n        };\n\n        if (isDown) { // Start of Drag\n             if (this.longEdit) { console.warn('Existing long edit found, accepting'); this.longEdit.accept(); }\n             this.longEdit = appController.beginLongEdit({ apply: action });\n        } else { // Continuation\n             if (this.longEdit) {\n                 this.longEdit.applyAgain(action);\n             } else {\n                 // Fallback\n                 appController.setNodeConfig(this.node.id, { values: { ...config, ...updates } });\n             }\n        }\n\n        // Optimistic update for UI smoothness\n        Object.assign(this.adsr, updates);\n    }\n\n    // --- SIM INTERACTION ---\n    private isSimDragging = false;\n\n    private handleSimDown(e: PointerEvent) {\n        e.preventDefault();\n        e.stopPropagation();\n        (e.target as Element).setPointerCapture(e.pointerId);\n        this.isSimDragging = true;\n        this.sendSimMessage(e);\n    }\n\n    private handleSimMove(e: PointerEvent) {\n        e.preventDefault();\n        e.stopPropagation();\n        if (this.isSimDragging) {\n            this.sendSimMessage(e);\n        }\n    }\n\n    private handleSimUp(e: PointerEvent) {\n        e.stopPropagation();\n        this.isSimDragging = false;\n\n        // Finish ADSR Drag if active\n        if (this.longEdit) {\n             this.longEdit.accept();\n             this.longEdit = null;\n        }\n\n        (e.target as Element).releasePointerCapture(e.pointerId);\n        runtimeManager.sendNodeMessage(this.node.id, {\n            type: 'manual_interaction',\n            active: false\n        });\n    }\n\n    private sendSimMessage(e: PointerEvent) {\n        const rect = this.simCanvas.getBoundingClientRect();\n        // Calculate Y in simulation space (0-600)\n        // Canvas height scales to simulation height.\n        // Screen Y -> Canvas Y -> Sim Y\n        // Canvas Height = rect.height\n        // Sim Height = 600\n        const scale = 600 / rect.height;\n        const y = (e.clientY - rect.top) * scale;\n\n        runtimeManager.sendNodeMessage(this.node.id, {\n            type: 'manual_interaction',\n            active: true,\n            y: y\n        });\n    }\n\n    // --- DRAWING ---\n\n    private drawHistory() {\n        if(!this.historyCanvas) return;\n        const ctx = this.historyCanvas.getContext('2d');\n        if(!ctx) return;\n\n        // Ensure size\n        if(this.historyCanvas.width !== this.historyCanvas.offsetWidth) {\n            this.historyCanvas.width = this.historyCanvas.offsetWidth;\n            this.historyCanvas.height = this.historyCanvas.offsetHeight;\n        }\n\n        const w = this.historyCanvas.width;\n        const h = this.historyCanvas.height;\n        ctx.clearRect(0,0,w,h);\n\n        // Grid\n        ctx.fillStyle = '#111';\n        ctx.fillRect(0,0,w,h);\n\n        const drawLine = (key: 't'|'e'|'fs'|'fm', color: string) => {\n            ctx.strokeStyle = color;\n            ctx.lineWidth = 1;\n            ctx.beginPath();\n            const step = w / this.history.length;\n            this.history.forEach((val, i) => {\n                const y = h - (val[key] * h); // 0..1 to h..0\n                if(i===0) ctx.moveTo(0, y);\n                else ctx.lineTo(i * step, y);\n            });\n            ctx.stroke();\n        };\n\n        drawLine('fm', '#0088ff');\n        drawLine('fs', '#ff0000');\n        drawLine('e', '#ffff00');\n        drawLine('t', '#00ffff');\n    }\n\n    private drawSim() {\n        const ctx = this.simCanvas?.getContext('2d');\n        if (!ctx) return;\n\n        if(this.simCanvas.width !== this.simCanvas.offsetWidth) {\n            this.simCanvas.width = this.simCanvas.offsetWidth;\n            this.simCanvas.height = this.simCanvas.offsetHeight;\n        }\n\n        const w = this.simCanvas.width;\n        const h = this.simCanvas.height;\n        // Map simulation height (600) to canvas height\n        const scaleY = h / 600;\n\n        ctx.clearRect(0, 0, w, h);\n\n        // Draw Plate (PlateY is 0..600? PlateOpenY=40. Deep=570.)\n        const py = this.plateY * scaleY;\n\n        // Magnet Field\n        if (this.phase !== 'IDLE' && this.phase !== 'RELEASE') {\n            const grad = ctx.createLinearGradient(0, py, 0, py + (100 * scaleY));\n            grad.addColorStop(0, 'rgba(0, 255, 0, 0.2)');\n            grad.addColorStop(1, 'rgba(0, 255, 0, 0)');\n            ctx.fillStyle = grad;\n            ctx.fillRect(0, py, w, h - py);\n        }\n\n        ctx.fillStyle = (this.phase !== 'IDLE' && this.phase !== 'RELEASE') ? '#00ff00' : '#444';\n        ctx.fillRect(0, py - 2, w, 4);\n\n        // Draw Spheres\n        this.spheres.forEach(s => {\n            const sx = (s.x / 600) * w;\n            const sy = s.y * scaleY;\n            const sr = s.r * scaleY;\n            const t = s.t || 0;\n\n            let r = 255, g = 255, b = 0;\n            if (t < 0.5) { r = Math.floor((t * 2) * 255); g = 255; }\n            else { r = 255; g = Math.floor((1.0 - (t - 0.5) * 2) * 255); }\n\n            ctx.fillStyle = s.l ? `rgb(${r},${g},0)` : '#ccc';\n\n            // Draw String (from Top=Base to Sphere)\n            ctx.strokeStyle = '#333';\n            ctx.lineWidth = 1;\n            ctx.beginPath();\n            ctx.moveTo(sx, h); // Base is at bottom visually in sim?\n            // Logic check: \"targetY = h - restLength\". So h is base.\n            // Wait, MagnetoEnv.html says: `this.y = h - this.restLength;` (target).\n            // `moveTo(s.x, ch)`. ch is Height. So strings hang from Bottom?\n            // \"Gravity = 800\". Positive. So they fall \"down\" (increasing Y).\n            // So H is \"floor\". 0 is \"ceiling\".\n            // If Plate is at 40, it's at ceiling.\n            // Spheres fall heavily towards floor (h).\n            // Plate pulls them UP (to 0).\n            // Strings anchor at FLOOR (h).\n            // Correct.\n\n            ctx.moveTo(sx, h);\n            ctx.lineTo(sx, sy);\n            ctx.stroke();\n\n            // Draw Sphere\n            ctx.beginPath();\n            ctx.arc(sx, sy, Math.max(2, sr), 0, Math.PI * 2);\n            ctx.fill();\n\n            if (s.l) {\n                ctx.shadowBlur = 10;\n                ctx.shadowColor = `rgb(${r},${g},0)`;\n                ctx.fill();\n                ctx.shadowBlur = 0;\n            }\n        });\n    }\n\n    private drawADSR() {\n        const ctx = this.adsrCanvas?.getContext('2d');\n        if (!ctx) return;\n\n        if(this.adsrCanvas.width !== this.adsrCanvas.offsetWidth) {\n            this.adsrCanvas.width = this.adsrCanvas.offsetWidth;\n            this.adsrCanvas.height = this.adsrCanvas.offsetHeight;\n        }\n\n        const w = this.adsrCanvas.width;\n        const h = this.adsrCanvas.height;\n\n        ctx.clearRect(0, 0, w, h);\n\n        const { attack, decay, sustain, release, peak } = this.adsr;\n\n        // Iceberg Visualization (Inverted)\n\n        // FIXED TIME WINDOW (1.5s)\n        const VIEW_DURATION = 1.5;\n        const scaleX = w / VIEW_DURATION; // pixels per second\n\n        // Visual Layout with Minimum Widths\n        const MIN_VIS_W = 0.05; // 50ms min visual width\n        const visA = Math.max(attack, MIN_VIS_W);\n        const visD = Math.max(decay, MIN_VIS_W);\n        const visS = 0.5; // Fixed sustain visual width\n        // Release is just \"rest of graph\" in concept, but we draw the Release Curve.\n        // We draw R based on ACTUAL release value, but clipped to view if needed.\n        const visR = release;\n\n        const xA = visA * scaleX;\n        const xD = (visA + visD) * scaleX;\n        const xS = xD + (visS * scaleX);\n        const xR = xS + (visR * scaleX);\n\n        // Y coords (Iceberg: 0=Top=Base, 1=Bottom=Max)\n        const y0 = 0;\n        const yP = peak * h;\n        const yS = sustain * h;\n\n        // Active Zone Highlights (Draw first to be background)\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';\n        if (this.dragging === 'attack' || this.phase === 'ATTACK') ctx.fillRect(0, 0, xA, h);\n        if (this.dragging === 'decay' || this.phase === 'DECAY') ctx.fillRect(xA, 0, xD - xA, h);\n        if (this.dragging === 'sustain' || this.phase === 'SUSTAIN') ctx.fillRect(xD, 0, xS - xD, h);\n        if (this.dragging === 'release' || this.phase === 'RELEASE') ctx.fillRect(xS, 0, w - xS, h);\n\n\n        // Draw Shape\n        ctx.strokeStyle = '#00ffff';\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(0, y0);\n        ctx.lineTo(xA, yP);\n        ctx.lineTo(xD, yS);\n        ctx.lineTo(xS, yS);\n        ctx.lineTo(xR, y0);\n        ctx.stroke();\n\n        // Fill\n        const grad = ctx.createLinearGradient(0, 0, 0, h);\n        grad.addColorStop(0, 'rgba(0, 255, 255, 0)');\n        grad.addColorStop(1, 'rgba(0, 255, 255, 0.2)');\n        ctx.fillStyle = grad;\n        ctx.lineTo(0, y0);\n        ctx.fill();\n\n        // Handles (if dragging or hovering?)\n        // Draw dots at key points\n        ctx.fillStyle = '#fff';\n        const drawDot = (x: number, y: number) => {\n            ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();\n        };\n        drawDot(xA, yP);\n        drawDot(xD, yS);\n        drawDot(xS, yS);\n        drawDot(xR, y0);\n    }\n\n    render() {\n        return html`\n            <div class=\"header\" @pointerdown=\"${(e: Event) => e.stopPropagation()}\">\n                <div class=\"status ${this.phase !== 'IDLE' ? 'active' : ''}\">${this.phase}</div>\n                <div style=\"font-size: 8px;\">MAGNETO</div>\n            </div>\n\n            <div class=\"panel\" style=\"height: 40px; flex-shrink: 0;\" @pointerdown=\"${(e: Event) => e.stopPropagation()}\">\n                <canvas id=\"history-canvas\"></canvas>\n                <div class=\"legend\">\n                    <div style=\"color:#00ffff\">TEN<div class=\"dot\" style=\"background:#00ffff; display:inline-block\"></div></div>\n                    <div style=\"color:#ffff00\">EXT<div class=\"dot\" style=\"background:#ffff00; display:inline-block\"></div></div>\n                    <div style=\"color:#ff0000\">SPR<div class=\"dot\" style=\"background:#ff0000; display:inline-block\"></div></div>\n                    <div style=\"color:#0088ff\">MAG<div class=\"dot\" style=\"background:#0088ff; display:inline-block\"></div></div>\n                </div>\n            </div>\n\n            <div class=\"panel\" style=\"height: 140px; flex-shrink: 0; pointer-events: auto;\"\n                 @pointerdown=\"${this.handleSimDown}\"\n                 @pointermove=\"${this.handleSimMove}\"\n                 @pointerup=\"${this.handleSimUp}\"\n                 @pointercancel=\"${this.handleSimUp}\">\n                <canvas id=\"sim-canvas\"></canvas>\n                <div class=\"param-label\">SIMULATION</div>\n            </div>\n\n            <div class=\"panel\" style=\"height: 80px; flex: 1; border-bottom: none;\"\n                 @pointerdown=\"${this.handleADSRDown}\"\n                 @pointermove=\"${this.handleADSRMove}\"\n                 @pointerup=\"${this.handleADSRUp}\"\n                 @pointercancel=\"${this.handleADSRUp}\">\n                <canvas id=\"adsr-canvas\"></canvas>\n                <div class=\"param-label\">ELASTIC EDITOR</div>\n            </div>\n        `;\n    }\n}\n\nexport const MagnetoEditorRenderer = (node: GridNode) => {\n    return html`<nicepattern-magneto-editor .node=${node}></nicepattern-magneto-editor>`;\n}\n"],"names":["MagnetoEditor","LitElement","e","loop","uiState","runtimeManager","outputs","resize","c","w","h","isDown","rect","xNorm","yNorm","attack","decay","sustain","release","peak","timeAtCursor","MIN_VIS_W","visA","visD","visS","tA","tD","tS","closestDist","target","distA","distD","distS","updates","config","newAttack","newPeak","newDecay","newSus","tStartRelease","newRelease","action","appController","scale","y","ctx","drawLine","key","color","step","val","i","scaleY","py","grad","s","sx","sy","sr","t","r","g","scaleX","visR","xA","xD","xS","xR","y0","yP","yS","drawDot","x","html","css","__decorateClass","property","query","customElement","MagnetoEditorRenderer","node"],"mappings":"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"}