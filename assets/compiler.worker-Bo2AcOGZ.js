const G={kind:"atomic",type:"number",defaultValue:0},$t={kind:"atomic",type:"string",defaultValue:""},Z={kind:"atomic",type:"any"};function oe(e,i){if(e==null)return e;if(i.kind==="atomic")return e&&typeof e=="object"&&"kind"in e&&e.kind==="atomic"?e.value:e;if(i.kind==="array")return Array.isArray(e)?e.map(o=>oe(o,i.element)):[];if(i.kind==="record"){if(typeof e=="object"){if("fields"in e){const t=e,n={};for(const[r,s]of Object.entries(i.fields))r in t.fields&&(n[r]=oe(t.fields[r],s));return n}const o={};for(const[t,n]of Object.entries(i.fields))t in e&&(o[t]=oe(e[t],n));return o}return e}return e}function me(e,i){if(e==null||i.kind==="atomic")return e;if(i.kind==="array")return Array.isArray(e)?e.map(t=>me(t,i.element)):(console.error("toStructor array fail: not array",e),[]);if(i.kind==="record"){const o={};for(const[t,n]of Object.entries(i.fields))e[t]!==void 0&&(o[t]=me(e[t],n));return{fields:o}}return e}function ee(e){const i={kind:"record",fields:e.config||{}},o={kind:"record",fields:e.outputs};return{id:e.id,kind:"primitive",metadata:e.metadata,inputs:e.inputs,outputs:e.outputs,configType:i,isRealtime:e.isRealtime,onMessage:e.onMessage,getDisplayLabel:e.getDisplayLabel,subgraphExpansionTag:e.subgraphExpansionTag,getChildren:e.getChildren,getRegion:e.getRegion,cycleBreakingPorts:e.cycleBreakingPorts,consolidate:e.consolidate?(t,n,r,s)=>{const a=oe(n,i),c={},u=t.fields||{};for(const[d,b]of Object.entries(e.inputs||{}))u[d]!==void 0&&(c[d]=oe(u[d],b));e.consolidate(c,a,r,s)}:void 0,computeBackwardPorts:e.computeBackwardPorts,computeForwardPorts:(t,n,r,s)=>e.computeForwardPorts?e.computeForwardPorts(t,n,r,s):{inputs:{kind:"record",fields:e.inputs||{}},outputs:o},shouldRecompileOnConfigChange:(t,n)=>e.shouldRecompileOnConfigChange?e.shouldRecompileOnConfigChange(t,n):!1,compileConfig:e.compileConfig,ui:e.ui,createState:e.createState,execute:(t,n,r)=>{const s=oe(n,i);let a;if(e.createState){const g=r.nodeId||`${e.id}-${JSON.stringify(n)}`;r.nodeState.has(g)||r.nodeState.set(g,e.createState(s,r)),a=r.nodeState.get(g)}let c=t;if(e.autoBroadcast&&e.inputs){const g={outputs:{},reshape:e.reshape??"none"},I=typeof e.autoBroadcast=="object"?e.autoBroadcast:{};if(s&&typeof s=="object"&&"autoBroadcast"in s){const _=s.autoBroadcast;_&&typeof _=="object"&&Object.assign(I,_)}for(const[_,q]of Object.entries(e.inputs)){const J=q.kind==="array",E=I[_],S=J?"collect":{reduce:"first"},X=E&&"combine"in E?E.combine:S;g.outputs[_]={fromFields:[_],combine:X??void 0}}const k=r.broadcast(g,t).apply(_=>{const q={};for(const[E,S]of Object.entries(e.inputs))if(g.outputs[E]?.combine==="collect"&&Array.isArray(_[E])){const h=_[E].map(M=>{if(Array.isArray(M)&&M.length>0&&Array.isArray(M[0])&&S.kind==="array"&&S.element.kind==="record")return M.map(F=>oe(F,S.element));const C=S.element?.kind==="array",H=Array.isArray(M)&&M.length>0&&Array.isArray(M[0]);return C&&!H?oe(M,S.element):oe(M,S)}),w=S.element?.kind==="array";h.length===1&&Array.isArray(h[0])&&!w?q[E]=h[0]:q[E]=h}else{const h=_[E],w=S.element?.kind==="array",M=Array.isArray(h)&&h.length>0&&Array.isArray(h[0]);let C;S.kind==="array"&&w&&!M?C=oe(h,S.element):C=oe(h,S),q[E]=C!==void 0?C:S.defaultValue}return e.execute(q,s,r,a)});if(Array.isArray(k))if(k.length>0){const _={},q=k[0];for(const E of Object.keys(q))_[E]=[];for(const E of k)for(const[S,X]of Object.entries(E))_[S]&&_[S].push(X);const J={};for(const[E,S]of Object.entries(_)){const X=e.outputs[E]||e.dynamicOutputType;X&&(J[E]=me(S,{kind:"array",element:X,size:k.length}))}return{fields:J}}else return{fields:{}};else{let _=k,q;_&&typeof _=="object"&&"outputs"in _&&("ui"in _||Object.keys(_).length===2)&&("outputs"in e.outputs||(q=_.ui,_=_.outputs));const J=new Set([...Object.keys(e.outputs),...Object.keys(_)]),E={};for(const X of J){const h=e.outputs[X]||e.dynamicOutputType;h&&_[X]!==void 0&&(E[X]=me(_[X],h))}const S={fields:E};return q!==void 0?{outputs:S,ui:q}:S}}else if(e.inputs&&Object.keys(e.inputs).length>0){const g={};for(const[I,N]of Object.entries(e.inputs))t.fields&&t.fields[I]!==void 0?g[I]=oe(t.fields[I],N):N.defaultValue!==void 0&&(g[I]=N.defaultValue);c=g}let d=e.execute(c,s,r,a),b;d&&typeof d=="object"&&"outputs"in d&&("ui"in d||Object.keys(d).length===2)&&("outputs"in e.outputs||(b=d.ui,d=d.outputs));const p={},f=d;if(f){const g=new Set([...Object.keys(e.outputs),...Object.keys(f)]);for(const I of g){const N=e.outputs[I]||e.dynamicOutputType;N&&f[I]!==void 0&&(p[I]=me(f[I],N))}}const m={fields:p};return b!==void 0?{outputs:m,ui:b}:m}}}function Gt(e,i,o){const t={outputs:{},reshape:"none"};for(const[a,c]of Object.entries(i))t.outputs[a]={fromFields:c.source?Array.isArray(c.source)?c.source:[c.source]:[a],combine:c.combine??{reduce:"first"}};const r=e.broadcast(t,o).apply(a=>a),s={};if(Array.isArray(r)){for(const a of Object.keys(i))s[a]=[];for(const a of r)for(const c of Object.keys(i))s[c].push(a[c])}else for(const a of Object.keys(i))s[a]=r[a];for(const[a,c]of Object.entries(i))if(c.type)if(c.combine==="collect"){const u=s[a];Array.isArray(u)?s[a]=u.map(d=>oe(d,c.type)):s[a]=oe(u,c.type)}else{const u=s[a];Array.isArray(u)?s[a]=u.map(d=>oe(d,c.type)):s[a]=oe(u,c.type)}return s}function Q(e,i,o,t="binary"){return ee({id:e,metadata:i,inputs:t==="binary"?{a:G,b:G}:{a:G},outputs:{result:G},autoBroadcast:!0,reshape:"vector",execute:(r,s,a)=>{if(t==="binary"){const{a:c,b:u}=r;return{result:o(c,u)}}else{const{a:c}=r;return{result:o(c,0)}}}})}function Ae(e){if(e.length===0)return Z;const i=e[0];if(e.every(r=>r.kind===i.kind&&(r.kind==="atomic"?r.type===i.type:!0)))return i;if(e.some(r=>r.kind==="atomic"&&r.type==="string"))return Z;const t=e.some(r=>r.kind==="atomic"&&r.type==="number"),n=e.some(r=>r.kind==="atomic"&&r.type==="boolean");return t||n?G:Z}var ze=(e=>(e.Auto="auto",e.Show="show",e.Hide="hide",e))(ze||{});class Ht{constructor(){this.nodes=new Map}register(i){this.nodes.set(i.id,i)}get(i){return this.nodes.get(i)?.definition}getNodeType(i){return this.nodes.get(i)}getAllNodeTypes(){return this.nodes.values()}}const xe=new Ht;function R(e){const i={};for(const[n,r]of Object.entries(e.inputs||{}))if("kind"in r)i[n]=r;else if("type"in r){const s=r,a=s.type,c=s.allowMultiConnection?{kind:"array",size:"dynamic",element:a}:a;i[n]={...c,redirect:s.redirect,defaultValue:"defaultValue"in s?s.defaultValue:a.defaultValue}}const o={};for(const[n,r]of Object.entries(e.outputs||{}))"kind"in r?o[n]=r:"type"in r&&(o[n]=r.type);return{...ee({...e,autoBroadcast:e.autoBroadcast,inputs:i,outputs:o,compileConfig:(n,r)=>e.compileConfig?e.compileConfig(n):n,computeForwardPorts:(n,r,s,a)=>e.computeForwardPorts?e.computeForwardPorts(n,r,s,a):{inputs:{kind:"record",fields:i},outputs:{kind:"record",fields:o}},computeBackwardPorts:(n,r,s)=>e.computeBackwardPorts?e.computeBackwardPorts(n,r,s):{inputRequirements:{kind:"record",fields:{}}},onMessage:e.onMessage,config:e.config}),ui:e.ui,version:e.version||"1.0.0",displayName:e.displayName||e.id,aliases:e.aliases,compileConfig:e.compileConfig,loadCompileDeps:e.loadCompileDeps,getDisplayLabel:e.getDisplayLabel,subgraphExpansionTag:e.subgraphExpansionTag,extendedInputs:e.inputs,extendedOutputs:e.outputs,inspectInputs:e.inspectInputs,shouldRecompileOnConfigChange:e.shouldRecompileOnConfigChange,getChildren:e.getChildren,getRegion:e.getRegion}}function y(e){const i=e.extendedInputs||e.inputs||{},o=Object.entries(i).map(([s,a])=>{const c="type"in a&&typeof a.type=="object"&&"kind"in a.type,u=c?a.type:a;return{name:s,type:u,description:c?a.description:void 0,defaultValue:c?a.defaultValue:void 0,range:c?a.range:void 0,step:c?a.step:void 0,suppressInputEditor:c?a.suppressInputEditor:u.kind==="atomic"&&u.type==="any"?!0:void 0,alwaysShowInputEditor:c?a.alwaysShowInputEditor:void 0,suppressLabel:c?a.suppressLabel:void 0,redirect:c?a.redirect:void 0,allowMultiConnection:c?a.allowMultiConnection:void 0}}),t=e.extendedOutputs||e.outputs||{},n=Object.entries(t).map(([s,a])=>{const c="type"in a&&typeof a.type=="object"&&"kind"in a.type,u=c?a.type:a;return{name:s,type:u,description:c?a.description:void 0,suppressLabel:c?a.suppressLabel:void 0}}),r={id:e.id,version:e.version||"1.0.0",displayName:e.displayName||e.id,aliases:e.aliases,definition:e,inputs:o,outputs:n,compileConfig:e.compileConfig,getDisplayLabel:e.getDisplayLabel,inspectInputs:e.inspectInputs,shouldRecompileOnConfigChange:e.shouldRecompileOnConfigChange,getChildren:e.getChildren,getRegion:e.getRegion};r.ui=e.ui,xe.register(r)}var x=(e=>(e.IO="IO",e.Math="Math",e.Logic="Logic",e.Data="Data",e.Functional="Functional",e.Core="Core",e.Custom="Custom",e.Utility="Utility",e.Debug="Debug",e))(x||{});const je={kind:"record",fields:{domain:{kind:"array",element:G,size:2},range:{kind:"array",element:G,size:2},segments:{kind:"array",element:{kind:"record",fields:{id:{kind:"atomic",type:"string"},weight:G,curve:{kind:"record",fields:{type:{kind:"atomic",type:"string"},value:{...G,optional:!0},points:{kind:"array",element:{kind:"record",fields:{x:G,y:G}},optional:!0,size:"dynamic"}}}}},size:"dynamic"},envelopeNodes:{kind:"array",element:{kind:"record",fields:{id:{kind:"atomic",type:"string"},x:G,y:G}},optional:!0,size:"dynamic"}},hint:"curve"},Be=(e,i)=>{const o=e.value,t=e.easing;if(!t||!t.segments||t.segments.length===0)return{result:o};const{domain:n,range:r,segments:s}=t,[a,c]=n,[u,d]=r;let b=(o-a)/(c-a);b=Math.max(0,Math.min(1,b));const p=s.reduce((E,S)=>E+S.weight,0)||1;let f=0,m=s[s.length-1],g=0,I=0;for(const E of s){const S=E.weight/p;if(b>=f&&b<=f+S){m=E,g=f,I=S;break}f+=S}const N=(b-g)/I;let k=0;const _=m.curve,q=_.type==="step"?_.value??2:1;switch(_.type){case"exponential":const E=Math.pow(10,-(_.value??0));k=Math.pow(N,E);break;case"linear":k=N;break;case"step":q<=1?k=0:k=Math.floor(N*q)/(q-1),N>=.999&&(k=1);break;case"sin":k=-(Math.cos(Math.PI*N)-1)/2;break;case"quad":k=N*N;break;case"points":if(_.points&&_.points.length>0){const S=_.points;if(N<=S[0].x)k=S[0].y;else if(N>=S[S.length-1].x)k=S[S.length-1].y;else for(let X=0;X<S.length-1;X++){const h=S[X],w=S[X+1];if(N>=h.x&&N<=w.x){const M=(N-h.x)/(w.x-h.x);k=h.y+M*(w.y-h.y);break}}}else k=N;break;default:k=N}return{result:u+k*(d-u)}},Ut=R({id:"curve.ease",version:"1.0.0",displayName:"Curve Ease",metadata:{category:x.Math,keywords:["curve","ease","envelope","shape"],description:"Applies a custom curve easing to the input value."},inputs:{value:{type:G,description:"Input value (0-1)",defaultValue:0},easing:{type:{...je,optional:!0},description:"Easing Curve Configuration",suppressInputEditor:!0}},outputs:{result:G},autoBroadcast:!0,inspectInputs:!0,compileConfig:e=>({fields:{easing:e?.easing??{domain:[0,1],range:[0,1],segments:[{id:"s1",weight:1,curve:{type:"exponential",value:0}}]}},untagged:[]}),execute:Be}),Yt=R({id:"curve.ease4",version:"1.0.0",displayName:"Curve Ease 4",metadata:{category:x.Math,keywords:["curve","ease","envelope","shape","multi"],description:"Applies a custom 4-segment curve easing to the input value."},inputs:{value:{type:G,description:"Input value (0-1)",defaultValue:0},easing:{type:{...je,optional:!0},description:"Easing Curve Configuration",suppressInputEditor:!0,defaultValue:{domain:[0,1],range:[0,1],segments:[{id:"s1",weight:1,curve:{type:"exponential",value:.5}},{id:"s2",weight:1,curve:{type:"exponential",value:0}},{id:"s3",weight:1,curve:{type:"exponential",value:-.5}},{id:"s4",weight:1,curve:{type:"exponential",value:-1}}]}}},outputs:{result:G},autoBroadcast:!0,inspectInputs:!0,compileConfig:e=>({fields:{easing:e?.easing??{domain:[0,1],range:[0,1],segments:[{id:"s1",weight:1,curve:{type:"exponential",value:.5}},{id:"s2",weight:1,curve:{type:"exponential",value:0}},{id:"s3",weight:1,curve:{type:"exponential",value:-.5}},{id:"s4",weight:1,curve:{type:"exponential",value:-1}}]}},untagged:[]}),execute:Be});y(Ut);y(Yt);const Wt=(e,i,o,t)=>{const n=e.value??0,r=i?.config;if(!r||!r.envelopeNodes||r.envelopeNodes.length<2||!r.segments)return{result:n};const s=r.envelopeNodes,a=r.segments||[],c=s[0],u=s[s.length-1];if(n<=c.x)return{result:c.y};if(n>=u.x)return{result:u.y};let d=t.lastSegmentIndex||0;if(d>=s.length-1||n<s[d].x||n>=s[d+1].x){for(let N=0;N<s.length-1;N++)if(n>=s[N].x&&n<s[N+1].x){d=N;break}}t.lastSegmentIndex=d;const b=s[d],p=s[d+1],f=a[d],m=(n-b.x)/(p.x-b.x);let g=m;if(f&&f.curve){const N=f.curve.type||"linear",k=f.curve.value||0;if(N==="linear")g=m;else if(N==="exponential"){const _=Math.pow(10,-(k??0)),q=Math.max(0,m);g=Math.pow(q,_)}}return{result:b.y+(p.y-b.y)*g}},Zt=R({id:"curve.env",version:"1.0.0",displayName:"Curve Envelope",metadata:{category:"Curve",keywords:["envelope","automation","ramp"],description:"User-editable curve envelope"},inputs:{value:{type:G,description:"Input value (0-1)",defaultValue:0}},outputs:{result:{type:G,description:"Output value"}},config:{config:{kind:"atomic",type:"any",defaultValue:{}}},inspectInputs:!0,createState:()=>({lastSegmentIndex:0}),autoBroadcast:!0,compileConfig:e=>({config:e.config??e.curveData??e.values?.config??{domain:[0,1],range:[0,1],envelopeNodes:[{id:"n1",x:0,y:0},{id:"n2",x:1,y:1}],segments:[{id:"s1",weight:1,curve:{type:"linear"}}]}}),execute:Wt});y(Zt);const Kt={value:{type:G,defaultValue:0},start:{type:G,defaultValue:0},end:{type:G,defaultValue:1,optional:!0},length:{type:G,defaultValue:1,optional:!0}},Xt=R({id:"curve.crop",version:"1.0.0",displayName:"Curve Crop",metadata:{category:"Curve",keywords:["crop","slice","remap","linear"],description:"Linear mapping from 0-1 to start-end range."},config:{mode:{kind:"atomic",type:"string",defaultValue:"start-end"}},computeForwardPorts:(e,i,o)=>{const t=i.mode||"start-end",n={value:{...G,description:"Input value (0-1)",defaultValue:0},start:{...G,description:"Output at 0",defaultValue:0}};return t==="start-length"?n.length={...G,description:"Length of crop",defaultValue:1}:n.end={...G,description:"Output at 1",defaultValue:1},{inputs:{kind:"record",fields:n},outputs:{kind:"record",fields:{result:G}}}},inputs:Kt,outputs:{result:{type:G}},ui:{inspector:{fields:[{type:"tab-bar",label:"Mode",path:"mode",options:[{label:"Start / End",value:"start-end"},{label:"Start / Length",value:"start-length"}]}]}},compileConfig:e=>({mode:e.mode||"start-end"}),autoBroadcast:!0,inspectInputs:!0,execute:(e,i,o)=>{const t=i.mode||"start-end",n=e.start??0,r=e.value??0;let s;if(t==="start-length"){const u=e.length??1;s=n+u}else s=e.end??1;s<n&&(s=n);let a=0;const c=s-n;if(c<1e-6)a=r>=n?1:0;else{const u=(r-n)/c;a=Math.max(0,Math.min(1,u))}return{outputs:{result:a},ui:{start:n,end:s}}},shouldRecompileOnConfigChange:e=>!0});y(Xt);const l={kind:"atomic",type:"number",defaultValue:0},Ee={kind:"atomic",type:"string"},$e={kind:"atomic",type:"boolean"},K={kind:"atomic",type:"any"},Ge={kind:"atomic",type:"string",options:["time","beats"],defaultValue:"time"},Qt={kind:"record",fields:{type:Ee,channel:l,deviceId:{...Ee,optional:!0},time:{...l,optional:!0},note:{...l,optional:!0},velocity:{...l,optional:!0},cc:{...l,optional:!0},value:{...l,optional:!0}},hint:"midi"},V={kind:"array",size:"dynamic",element:Qt,hint:"midi-stream"},Re={kind:"array",element:l,size:4,hint:"float4"},De={kind:"record",fields:{note:l,velocity:l},untagged:[]};({...De},{...De});const Jt={kind:"record",fields:{noteIndex:K,velocity:l,hold:$e},untagged:[]},se={kind:"array",size:"dynamic",element:Jt,hint:"step-sequence"},He=R({id:"debug.scope",version:"1.0.0",displayName:"Scope",metadata:{category:x.Debug,keywords:["debug","scope","chart","visualize"],description:"Visualizes input values over time."},inputs:{value:{type:l,suppressLabel:!0,alwaysShowInputEditor:!0}},outputs:{value:l},config:{},inspectInputs:!0,execute:e=>({value:e.value}),compileConfig:e=>({})});y(He);y(He);class ei{execute(i,o){if(!i.rootId)return null;const t=new Map,n=r=>{if(t.has(r))return t.get(r);const s=i.nodes[r];if(!s)throw new Error(`Missing node ${r}`);const a=s.inputs.map(u=>n(u));let c;switch(s.op){case"const":c=s.params.value;break;case"input":c=o[s.params.key]!==void 0?o[s.params.key]:globalThis[s.params.key];break;case"add":c=a[0]+a[1];break;case"sub":c=a[0]-a[1];break;case"mul":c=a[0]*a[1];break;case"div":c=a[0]/a[1];break;case"prop":if(a[0]===void 0||a[0]===null)throw new Error(`Cannot access property '${s.params.key}' of undefined`);c=a[0][s.params.key];break;case"struct":c={},s.params.keys.forEach((u,d)=>{c[u]=a[d]});break;default:throw new Error(`Unknown op: ${s.op}`)}return t.set(r,c),c};return n(i.rootId)}}let ke=null;const ti=new ei,Se=new Map;function Pe(e){if(Se.has(e))return Se.get(e);if(!ke)return console.warn("Expression Compiler not loaded yet. Returning empty graph."),{nodes:{},rootId:null};try{const i=ke.compiler.compile(e);return Se.set(e,i),i}catch(i){return console.error("Compilation failed:",i),{nodes:{},rootId:null}}}const ii=[{type:"string",label:"Expression",path:"code",placeholder:"e.g. sin(time) * 0.5"}],ni=R({id:"logic.expression",version:"1.0.0",displayName:"Expression",metadata:{category:x.Logic,keywords:["expression","math","script","code"],description:"Evaluates a mathematical expression."},inputs:{},config:{code:$t,graph:Z},outputs:{result:Z},autoBroadcast:!1,ui:{inspector:{fields:ii}},loadCompileDeps:async()=>{if(!ke){const e=await import("./expr-compiler-CbE6jRbp.js");ke={compiler:new e.GraphCompiler}}},compileConfig:e=>{const i=e.code||"",o=Pe(i);return{code:i,graph:o}},computeForwardPorts:(e,i)=>{const o=i.code||"",t=Pe(o),n=new Set;for(const s of Object.values(t.nodes))s.op==="input"&&n.add(s.params.key);const r=Array.from(n).map(s=>[s,{...l,description:`Variable ${s}`}]);return{inputs:{kind:"record",fields:Object.fromEntries(r)},outputs:{kind:"record",fields:{result:{...K,description:"Result"}}}}},execute:(e,i,o)=>{const t=i.graph;if(!t||!t.rootId)return{result:0};const n={...e};try{return{result:ti.execute(t,n.fields||n)}}catch(r){return console.error("Execution failed:",r),{result:null}}}});y(ni);const oi=R({id:"gen.sawtooth",version:"1.0.0",displayName:"Sawtooth",metadata:{category:"Oscillator",keywords:["oscillator","sawtooth","ramp","lfo","generator"],description:"Generates a linear sawtooth wave (0.0 to 1.0) at the given frequency."},inputs:{freq:{type:l,defaultValue:1,range:[0,60],description:"Frequency in Hz"}},outputs:{out:l},autoBroadcast:!0,isRealtime:()=>!0,createState:()=>({phase:0}),execute:(e,i,o,t)=>{const n=e.freq,r=o.clock.dt;return n>=60-1e-6?{out:Math.random()}:(t.phase+=r*n,t.phase-=Math.floor(t.phase),{out:t.phase})}});y(oi);const te={IDLE:0,ATTACK:1,DECAY:2,SUSTAIN:3,RELEASE:4},si=R({id:"gen.adsr",version:"1.0.0",displayName:"ADSR",metadata:{category:"Envelope",keywords:["envelope","adsr","modulation"],description:"Attack-Decay-Sustain-Release envelope generator triggered by MIDI."},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},inputs:{stream:{type:V,description:"MIDI Stream",allowMultiConnection:!0},attack:{type:l,defaultValue:.1,range:[0,5],description:"Attack Time (s)"},decay:{type:l,defaultValue:1,range:[0,5],description:"Decay Time (s)"},sustain:{type:l,defaultValue:.7,range:[0,1],description:"Sustain Level (0-1)"},release:{type:l,defaultValue:1,range:[0,5],description:"Release Time (s)"}},config:{mode:{kind:"atomic",type:"string",defaultValue:"D"}},ui:{inspector:{fields:[{label:"Mode",path:"mode",type:"tab-bar",options:[{label:"ADSR",value:"ADSR"},{label:"ADS",value:"ADS"},{label:"D",value:"D"}]}]}},compileConfig:e=>({mode:e.mode||e.values?.mode||"D"}),computeForwardPorts:(e,i)=>{const o=i.mode||"D",t={stream:V};return o==="ADSR"?(t.attack=l,t.decay=l,t.sustain=l,t.release=l):o==="ADS"?(t.attack=l,t.decay=l,t.sustain=l):o==="D"&&(t.decay=l),{inputs:{kind:"record",fields:t},outputs:{kind:"record",fields:{value:l}}}},outputs:{value:{type:l,description:"Envelope Value (0-1)"}},isRealtime:()=>!0,shouldRecompileOnConfigChange:e=>!0,createState:()=>({phase:te.IDLE,value:0,time:0,activeNotes:0}),execute:(e,i,o,t)=>{const n=o.clock.dt,r=i.mode||"D",s=e.stream;let a=0,c=0,u=0,d=0;if(r==="D"?(a=0,c=Math.max(0,e.decay??.1),u=0,d=c):r==="ADS"?(a=Math.max(0,e.attack??.1),c=Math.max(0,e.decay??.1),u=Math.max(0,Math.min(1,e.sustain??.7)),d=c):(a=Math.max(0,e.attack??.1),c=Math.max(0,e.decay??.1),u=Math.max(0,Math.min(1,e.sustain??.7)),d=Math.max(0,e.release??.5)),Array.isArray(s))for(const b of s)b.type==="note_on"&&(b.velocity??0)>0?(t.activeNotes++,t.activeNotes===1&&(t.phase=te.ATTACK,t.value=0,t.time=0,a<=0&&(t.value=1,t.phase=te.DECAY,t.time=0,c<=0&&(t.value=u,t.phase=te.SUSTAIN)))):(b.type==="note_off"||b.type==="note_on"&&(b.velocity??0)===0)&&(t.activeNotes=Math.max(0,t.activeNotes-1));switch(t.activeNotes===0&&t.phase!==te.IDLE&&t.phase!==te.RELEASE&&(t.phase=te.RELEASE,t.time=0),t.phase){case te.IDLE:t.value=0,t.time=0;break;case te.ATTACK:t.time+=n,t.value+=1/Math.max(.001,a)*n,t.value>=1&&(t.value=1,t.phase=te.DECAY,t.time=0,c<=0&&(t.value=u,t.phase=te.SUSTAIN));break;case te.DECAY:t.time+=n,t.value-=(1-u)/Math.max(.001,c)*n,t.value<=u&&(t.value=u,t.phase=te.SUSTAIN,t.time=0);break;case te.SUSTAIN:t.time+=n,t.value=u;break;case te.RELEASE:t.time+=n,d<=0?(t.value=0,t.phase=te.IDLE,t.time=0):(t.value-=1/d*n,t.value<=0&&(t.value=0,t.phase=te.IDLE,t.time=0));break}return{outputs:{value:Math.max(0,Math.min(1,t.value))},ui:{value:t.value,phase:t.phase,time:t.time}}},inspectInputs:!0});y(si);function ri(e){let n=e;return{next:()=>(n=(1103515245*n+12345)%2147483648,n/2147483647)}}const ai=R({id:"math.random",version:"1.1.0",displayName:"Random",metadata:{category:"Math",keywords:["random","stochastic","noise","seed","white"],description:"Generates a random number (0-1). Supports on-trigger or free-run modes."},inputs:{trigger:{type:V,description:"Trigger Signal",allowMultiConnection:!0}},config:{seed:{kind:"atomic",type:"number",defaultValue:12345},mode:{kind:"atomic",type:"string",defaultValue:"on-trigger"}},outputs:{value:{type:l,description:"Random Value"}},autoBroadcast:{trigger:{combine:{reduce:"flatten"}}},ui:{inspector:{fields:[{type:"tab-bar",label:"Mode",path:"mode",options:[{label:"On Trigger",value:"on-trigger"},{label:"Free Run",value:"free-run"}],default:"on-trigger"},{type:"number",label:"Seed",path:"seed",default:12345}]}},compileConfig:e=>({mode:e.mode||e.values?.mode||"on-trigger",seed:e.seed||e.values?.seed||12345}),computeForwardPorts:(e,i)=>{const o=i.mode||"on-trigger",t={};return o==="on-trigger"&&(t.trigger={type:V,description:"Trigger Signal",allowMultiConnection:!0}),{inputs:{kind:"record",fields:t},outputs:{kind:"record",fields:{value:l}}}},isRealtime:e=>e.mode==="free-run",shouldRecompileOnConfigChange:e=>!0,createState:e=>{const o=e?.seed||12345,t=ri(o);return{generator:t,currentValue:t.next()}},execute:(e,i,o,t)=>{const n=i.mode||"on-trigger",r=e.trigger;if(n==="free-run")t.currentValue=t.generator.next();else if(Array.isArray(r))for(const s of r)s.type==="note_on"&&(s.velocity??0)>0&&(t.currentValue=t.generator.next());return{value:t.currentValue}}});y(ai);const li=[{type:"string",label:"Device ID",path:"deviceId",placeholder:"Optional Device ID"}],ci=[{type:"number",label:"Channel",path:"channel",min:1,max:16,step:1},{type:"number",label:"CC",path:"cc",min:0,max:127,step:1},{type:"string",label:"Device ID",path:"deviceId",placeholder:"Optional Device ID"}],ui=R({id:"midi.input",version:"1.0.0",displayName:"MIDI Input",metadata:{category:x.IO,keywords:["midi","input","source"],description:"Reads raw MIDI messages from a specific device."},inputs:{},config:{deviceId:{kind:"atomic",type:"string",optional:!0}},outputs:{stream:V},ui:{inspector:{fields:li}},isRealtime:()=>!0,execute:(e,i,o)=>{const t=o.midi?.events,n=i.deviceId;return t&&n?{stream:t.filter(s=>s.deviceId===n)}:{stream:t||[]}},compileConfig:e=>({deviceId:e.deviceId})}),di=R({id:"midi.cc.input",version:"1.0.0",displayName:"MIDI CC Input",metadata:{category:x.IO,keywords:["midi","cc","input"],description:"Reads a MIDI CC value directly from the environment."},inputs:{},config:{channel:l,cc:l,deviceId:{kind:"atomic",type:"string",optional:!0}},outputs:{value:l},ui:{inspector:{fields:ci}},isRealtime:()=>!0,execute:(e,i,o)=>{const t=i.channel||1,n=i.cc||0;i.deviceId;const r=`${t}:${n}`;return{value:o.midi?.values.get(r)??0}},compileConfig:e=>({channel:e.channel??1,cc:e.cc??0,deviceId:e.deviceId})});y(ui);y(di);const pi=[{type:"number",label:"Channel",path:"channel",min:1,max:16,step:1},{type:"number",label:"CC",path:"cc",min:0,max:127,step:1}],fi=R({id:"midi.cc",version:"1.0.0",displayName:"MIDI CC",metadata:{category:x.IO,keywords:["midi","cc","control change"],description:"Reads MIDI Control Change messages from a stream."},inputs:{stream:{type:V,allowMultiConnection:!0}},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},config:{channel:l,cc:l},outputs:{value:l},ui:{inspector:{fields:pi}},createState:()=>({value:0}),execute:(e,i,o,t)=>{const n=i.channel||1,r=i.cc||0,s=e.stream||[];if(s&&Array.isArray(s))for(const a of s)a.type==="cc"&&a.channel===n&&a.cc===r&&(t.value=a.value??0);return{value:t.value}},compileConfig:e=>({channel:e.channel??1,cc:e.cc??0})});y(fi);const mi=[{type:"number",label:"Channel",path:"channel",min:1,max:16,step:1},{type:"number",label:"Note",path:"note",min:0,max:127,step:1}],yi=R({id:"midi.note",version:"1.0.0",displayName:"MIDI Note",metadata:{category:x.IO,keywords:["midi","note","keyboard"],description:"Reads MIDI Note messages from a stream."},inputs:{stream:{type:V,allowMultiConnection:!0}},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},config:{channel:l,note:l},outputs:{note:{kind:"atomic",type:"number",optional:!0},velocity:l,gate:l},ui:{inspector:{fields:mi}},createState:()=>({velocity:0,gate:0}),execute:(e,i,o,t)=>{const n=i.channel||1,r=i.note||60,s=e.stream||[];if(s&&Array.isArray(s))for(const a of s)a.channel===n&&(a.type==="note_on"&&a.note===r?(t.velocity=a.velocity??0,t.gate=1):a.type==="note_off"&&a.note===r&&(t.gate=0));return{note:t.gate?r:null,velocity:t.velocity,gate:t.gate}},compileConfig:e=>({channel:e.channel??1,note:e.note??60})});y(yi);const hi=[{type:"number",label:"Channel",path:"channel",min:1,max:16,step:1},{type:"number",label:"Root Note",path:"rootNote",min:0,max:127,step:1},{type:"select",label:"Priority",path:"priority",options:[{label:"Last Note",value:"last"},{label:"Low Note",value:"low"},{label:"High Note",value:"high"}]}],gi=R({id:"midi.to_mono",version:"1.0.0",displayName:"MIDI to Mono",metadata:{category:x.IO,keywords:["midi","mono","converter"],description:"Converts a polyphonic MIDI stream to a monophonic note signal."},inputs:{stream:{type:V,allowMultiConnection:!0}},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},config:{channel:l,rootNote:l,priority:{kind:"atomic",type:"string",optional:!0}},outputs:{note:{kind:"atomic",type:"number",optional:!0},velocity:l,gate:l,frequency:l},ui:{inspector:{fields:hi}},createState:()=>({activeNotes:[],gate:0}),execute:(e,i,o,t)=>{const n=i.channel||1,r=i.rootNote??60,s=e.stream||[];if(t.activeNotes||(t.activeNotes=[]),s&&Array.isArray(s))for(const c of s)c.channel===n&&(c.type==="note_on"?(t.activeNotes=t.activeNotes.filter(u=>u.note!==c.note),t.activeNotes.push({note:c.note,velocity:c.velocity??0})):c.type==="note_off"&&(t.activeNotes=t.activeNotes.filter(u=>u.note!==c.note)));const a=t.activeNotes.length>0?t.activeNotes[t.activeNotes.length-1]:null;if(a){t.gate=1;const c=a.note-r,u=440*Math.pow(2,(a.note-69)/12);return{note:c,velocity:a.velocity,gate:1,frequency:u}}else return t.gate=0,{note:null,velocity:0,gate:0,frequency:0}},compileConfig:e=>({channel:e.channel??1,rootNote:e.rootNote??60,priority:e.priority??"last"})});y(gi);const vi=[{type:"number",label:"Channel",path:"channel",min:1,max:16,step:1},{type:"number",label:"Note",path:"note",min:0,max:127,step:1}],bi=R({id:"midi.filter",version:"1.0.0",displayName:"MIDI Filter",metadata:{category:x.IO,keywords:["midi","filter","note"],description:"Filters MIDI events, allowing only specific Note On/Off messages through."},inputs:{stream:{type:V,allowMultiConnection:!0},channel:{type:l,description:"MIDI Channel (1-16)",defaultValue:1},note:{type:l,description:"Note Number (0-127)",defaultValue:60}},config:{},outputs:{stream:V},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},ui:{inspector:{fields:vi}},execute:(e,i)=>{const o=e.channel??1,t=e.note??60,n=e.stream||[],r=[];if(n&&Array.isArray(n))for(const s of n)s.channel===o&&(s.type==="note_on"||s.type==="note_off")&&s.note===t&&r.push(s);return{stream:r}},compileConfig:e=>({channel:e.channel??1,note:e.note??60})});y(bi);const xi=R({id:"midi.pitch",version:"1.0.0",displayName:"MIDI Pitch",metadata:{category:x.IO,keywords:["midi","pitch","transpose","shift"],description:"Transposes MIDI Note events by a specified amount."},inputs:{stream:{type:V,allowMultiConnection:!0},pitch:{type:l,description:"Pitch shift amount (semitones)",defaultValue:0,range:[-24,24]}},config:{},outputs:{stream:V},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},execute:(e,i)=>{const o=e.pitch??0,t=e.stream||[];return!t||!Array.isArray(t)?{stream:[]}:{stream:t.map(r=>{if(r.type==="note_on"||r.type==="note_off"){const s=Math.max(0,Math.min(127,Math.floor(r.note+o)));return{...r,note:s}}return r})}},compileConfig:e=>({pitch:e.pitch??0})});y(xi);const Ii=R({id:"midi.trigger",version:"1.0.0",displayName:"MIDI Trigger",metadata:{category:x.IO,keywords:["midi","trigger","bang","button"],description:"Manually sends a Middle C Note On/Off pair when triggered."},inputs:{trigger:{type:l,description:"Trigger Signal",suppressInputEditor:!0}},config:{pitch:{...l,defaultValue:60},velocity:{...l,defaultValue:1,range:[0,1]},trigger:l},outputs:{stream:V},createState:()=>({lastTrigger:0,initialized:!1}),execute:(e,i,o,t)=>{const n=i.pitch||60,r=i.velocity||1,s=e.trigger||0;o.clock.dt;const a=[];return t.initialized?(s>t.lastTrigger&&(a.push({type:"note_on",channel:1,note:n,velocity:r,deviceId:"virtual",time:0}),a.push({type:"note_off",channel:1,note:n,velocity:0,deviceId:"virtual",time:0}),o.markSelfDirty&&o.markSelfDirty()),t.lastTrigger=s,{stream:a}):(t.lastTrigger=s,t.initialized=!0,{stream:a})},compileConfig:e=>({pitch:e.pitch??60,velocity:e.velocity??1,trigger:e.trigger}),ui:{inspector:{fields:[{type:"button",label:"Trigger",path:"trigger",text:"Bang"},{type:"number",label:"Pitch",path:"pitch",min:0,max:127,step:1,default:60},{type:"number",label:"Velocity",path:"velocity",min:0,max:1,step:.01,default:1}]}}});y(Ii);const ki=R({id:"midi.merge",version:"1.0.0",displayName:"MIDI Merge",metadata:{category:x.IO,keywords:["midi","merge","combine","mix"],description:"Merges multiple MIDI streams into one using auto-broadcast."},inputs:{stream:{type:V,description:"Input Streams",allowMultiConnection:!0}},outputs:{stream:V},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},config:{},execute:(e,i,o)=>({stream:e.stream||[]}),compileConfig:()=>({})});y(ki);const Ni=R({id:"midi.select",version:"1.0.0",displayName:"MIDI Select",metadata:{category:x.IO,keywords:["midi","select","router","switch","demux"],description:"Routes MIDI events to different ports based on note pitch."},inputs:{stream:{type:V,allowMultiConnection:!0}},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},config:{count:{...l,defaultValue:4},root:{...l,defaultValue:60},skip:{...l,defaultValue:1}},outputs:{},dynamicOutputType:V,isRealtime:()=>!0,computeForwardPorts:(e,i,o)=>{const t=i.count||4,n={};for(let r=0;r<t;r++)n[r.toString()]={...V,hint:"midi-stream",description:`Offset ${r}`};return n.rem={...V,hint:"midi-stream",description:"Remainder"},{inputs:{kind:"record",fields:{stream:V}},outputs:{kind:"record",fields:n}}},shouldRecompileOnConfigChange:e=>!0,execute:(e,i,o)=>{const t=e.stream||[],n=i.count||4,r=i.root||60,s=i.skip||1,a={};for(let c=0;c<n;c++)a[c.toString()]=[];if(a.rem=[],t&&Array.isArray(t)){for(const c of t)if(c.type==="note_on"||c.type==="note_off"){const u=c.note-r;if(u>=0&&u%s===0){const d=u/s;if(d>=0&&d<n){a[d.toString()].push(c);continue}}a.rem.push(c)}}return{...a}},compileConfig:e=>({count:e.count??4,root:e.root??60,skip:e.skip??1}),ui:{inspector:{fields:[{type:"number",label:"Output Count",path:"count",min:1,max:128,step:1,default:4},{type:"number",label:"Root Note",path:"root",min:0,max:127,step:1,default:60},{type:"number",label:"Skip (Semitones)",path:"skip",min:1,max:24,step:1,default:1}]}}});y(Ni);const _i=R({id:"midi.onchange",version:"1.0.0",displayName:"MIDI On Change",metadata:{category:x.IO,keywords:["midi","trigger","change","delta"],description:"Triggers a note when input value changes."},inputs:{value:{type:Z,description:"Input Value"}},config:{rootNote:{...l,defaultValue:60}},outputs:{stream:V},ui:{inspector:{fields:[{type:"number",label:"Root Note",path:"rootNote",min:0,max:127,step:1,default:60}]}},isRealtime:()=>!0,createState:()=>({lastValue:void 0}),execute:(e,i,o,t)=>{const n=e.value,r=i.rootNote??60,s=[];let a=!1;return typeof n=="number"&&typeof t.lastValue=="number"?Math.abs(n-t.lastValue)>1e-5&&(a=!0):n!==t.lastValue&&(a=!0),a?(s.push({type:"note_on",note:r,velocity:1,channel:1,time:0,deviceId:"onchange"}),s.push({type:"note_off",note:r,velocity:0,channel:1,time:0,deviceId:"onchange"}),t.lastValue=n):t.lastValue===void 0&&n!==void 0&&(t.lastValue=n),{stream:s}},compileConfig:e=>({rootNote:e.rootNote??60})});y(_i);const Ue={};for(let e=1;e<=16;e++)Ue[`w${e}`]={type:l,defaultValue:1,optional:!0,description:`Weight ${e}`};const wi=R({id:"midi.onrange",version:"1.0.0",displayName:"MIDI On Range",metadata:{category:x.IO,keywords:["midi","trigger","range","zone"],description:"Triggers notes based on value position in weighted zones."},inputs:{value:{type:l,description:"Input Value"},start:{type:l,defaultValue:0},end:{type:l,defaultValue:1},...Ue},config:{rootNote:{...l,defaultValue:60,description:"Root Note"},zoneCount:{...l,defaultValue:1,description:"Number of Zones"},noteSkip:{...l,defaultValue:1}},outputs:{stream:V},ui:{inspector:{fields:[{type:"number",label:"Root Note",path:"rootNote",min:0,max:127,step:1,default:60},{type:"number",label:"Zone Count",path:"zoneCount",min:1,max:16,step:1,default:1},{type:"number",label:"Note Skip",path:"noteSkip",min:1,max:12,step:1,default:1}]}},isRealtime:()=>!0,createState:()=>({activeZoneIndex:null}),computeForwardPorts:(e,i)=>{const o=i.zoneCount??1,t={value:{...l},start:{...l,defaultValue:0},end:{...l,defaultValue:1}};if(o>1)for(let n=1;n<=o;n++)t[`w${n}`]={...l,defaultValue:1,description:`Weight ${n}`};return{inputs:{kind:"record",fields:t},outputs:{kind:"record",fields:{stream:V}}}},shouldRecompileOnConfigChange:()=>!0,execute:(e,i,o,t)=>{const n=e.value??0,r=e.start??0,s=e.end??1,a=i.rootNote??60,c=i.zoneCount??1,u=i.noteSkip??1;let d=r,b=s;b<d&&(b=r,d=s);const p=[];if(n>=d&&n<=b){let f=0;if(c>1){const m=[];let g=0;for(let I=1;I<=c;I++){let k=e[`w${I}`];k&&typeof k=="object"&&"value"in k&&(k=k.value),k=k??1,typeof k!="number"&&(k=1),m.push(k),g+=k}if(g<=0)f=0;else{const I=b-d,k=(I===0?0:(n-d)/I)*g;let _=0;for(let q=0;q<c;q++)if(_+=m[q],k<=_){f=q;break}f>=c&&(f=c-1)}}else f=0;if(t.activeZoneIndex===null){const m=a+f*u;p.push({type:"note_on",note:m,velocity:1,channel:1,time:0,deviceId:"onrange"}),t.activeZoneIndex=f}else if(t.activeZoneIndex!==f){const m=a+t.activeZoneIndex*u;p.push({type:"note_off",note:m,velocity:0,channel:1,time:0,deviceId:"onrange"});const g=a+f*u;p.push({type:"note_on",note:g,velocity:1,channel:1,time:0,deviceId:"onrange"}),t.activeZoneIndex=f}}else if(t.activeZoneIndex!==null){const f=a+t.activeZoneIndex*u;p.push({type:"note_off",note:f,velocity:0,channel:1,time:0,deviceId:"onrange"}),t.activeZoneIndex=null}return{stream:p}},compileConfig:e=>({rootNote:e.rootNote??60,zoneCount:e.zoneCount??1,noteSkip:e.noteSkip??1})});y(wi);const Ye={type:"tab-bar",label:"Mode",path:"mode",options:[{label:"Time",value:"time"},{label:"Beats",value:"beats"}],default:"time"},Mi={type:"tab-bar",label:"Beat Denom",path:"beatDenom",options:[{label:"1/64",value:.015625},{label:"1/32",value:.03125},{label:"1/16",value:.0625},{label:"1/8",value:.125},{label:"1/4",value:.25},{label:"1/2",value:.5},{label:"1/1",value:1}],default:.25},Ci=[Ye],Si=R({id:"midi.delay",version:"1.0.0",displayName:"MIDI Delay",metadata:{category:x.Utility,keywords:["midi","delay","time","beats"],description:"Delays MIDI events by a specified duration."},inputs:{stream:{type:V,allowMultiConnection:!0},duration:{...l,defaultValue:.25}},config:{mode:{...Ge,defaultValue:"time"}},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},outputs:{stream:V},ui:{inspector:{fields:Ci}},isRealtime:()=>!0,createState:()=>({queue:[]}),execute:(e,i,o,t)=>{const n=e.stream||[],r=e.duration||0,s=i.mode||"time";let a=0;if(s==="beats"?a=o.clock.beat:a=o.time||0,t.queue||(t.queue=[]),n&&Array.isArray(n))for(const d of n)t.queue.push({event:d,releaseTime:a+r});const c=[],u=[];for(const d of t.queue)d.releaseTime<=a?c.push(d.event):u.push(d);return t.queue=u,{stream:c}},compileConfig:e=>({mode:e.mode??"time"})});y(Si);const Ti=R({id:"midi.istrigger",version:"1.0.0",displayName:"MIDI Is Trigger",metadata:{category:x.Logic,keywords:["midi","check","trigger","gate"],description:"Outputs 1 if the stream contains any Note On event, 0 otherwise."},inputs:{stream:{type:V,allowMultiConnection:!0}},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},outputs:{result:l},createState:()=>({}),execute:(e,i,o,t)=>{const n=e.stream||[];let r=0;if(n&&Array.isArray(n)){for(const s of n)if(s.type==="note_on"){r=1;break}}return{result:r}}});y(Ti);const Oi=[Ye,Mi,{type:"number",label:"Note",path:"note",min:0,max:127,default:60}],Vi=R({id:"midi.metronome",version:"1.0.0",displayName:"Metronome",metadata:{category:x.Utility,keywords:["midi","metronome","clock","beat","trigger"],description:"Generates MIDI note events at regular intervals."},inputs:{duration:{...l,defaultValue:1,description:"Interval duration (seconds or beats)",min:0,max:4}},config:{mode:{...Ge,defaultValue:"time"},beatDenom:{...l,defaultValue:.25},note:{...l,defaultValue:60}},outputs:{stream:V},ui:{inspector:{fields:Oi}},isRealtime:()=>!0,createState:()=>({lastTriggerTime:-99999,noteActive:!1}),execute:(e,i,o,t)=>{const n=e.duration||1,r=i.mode||"time",s=i.beatDenom||.25,a=i.note||60;let c=0,u=n;r==="beats"?(c=o.clock.beat,u=Math.round(n)*s*4,u<=0&&(u=s)):c=o.time||0;const d=[];if(t.lastTriggerTime===-99999)return t.lastTriggerTime=c,{stream:[]};const b=t.lastTriggerTime,p=Math.floor(b/u),m=Math.floor(c/u)-p;for(let g=1;g<=m;g++)d.push({type:"note_on",deviceId:"metronome",channel:1,note:a,velocity:1,time:0}),d.push({type:"note_off",deviceId:"metronome",channel:1,note:a,velocity:0,time:0});return t.lastTriggerTime=c,{stream:d}},compileConfig:e=>({mode:e.mode??"time",beatDenom:e.beatDenom??.25,note:e.note??60})});y(Vi);const Ai=R({id:"time.time",version:"1.0.0",displayName:"Time",metadata:{category:x.Utility,keywords:["time","seconds","clock"],description:"Outputs the current execution time in seconds."},inputs:{},outputs:{time:l,delta:l},isRealtime:()=>!0,execute:(e,i,o)=>({time:o.time||0,delta:o.clock.dt||0})}),Ri=R({id:"time.beat",version:"1.0.0",displayName:"Beat",metadata:{category:x.Utility,keywords:["beat","bar","clock","tempo"],description:"Outputs the current beat number."},inputs:{},outputs:{beat:l,delta:l},isRealtime:()=>!0,createState:()=>({lastBeat:-1}),execute:(e,i,o,t)=>{const n=o.clock.beat||0;let r=0;return t.lastBeat>=0&&(r=n-t.lastBeat),t.lastBeat=n,{beat:n,delta:r}}});y(Ai);y(Ri);const Ne={kind:"atomic",type:"number"},Te=16,qi=[{type:"number",label:"Target Note",path:"targetNote"}],Ei=R({id:"nicepattern.rhythmic_generator",version:"1.0.0",displayName:"Rhythmic Generator",metadata:{category:"NicePattern",keywords:["rhythm","generator","sequence","euclidean"],description:"Generates a rhythmic sequence based on density."},config:{targetNote:l},inputs:{density:{...l,defaultValue:.5}},outputs:{seq_out:se},ui:{inspector:{fields:qi}},execute:(e,i,o)=>{const t=i.targetNote||60,n=e.density??.5,r=[],s=Math.round(n*Te);for(let a=0;a<Te;a++)a*s%Te<s?r.push({noteIndex:t,velocity:1,hold:!1}):r.push({noteIndex:null,velocity:0,hold:!1});return{seq_out:r}},compileConfig:e=>({targetNote:e.targetNote??60})});y(Ei);class _e{constructor(i){this.state=i}next(){let i=this.state+=1831565813;return i=Math.imul(i^i>>>15,i|1),i^=i+Math.imul(i^i>>>7,i|61),((i^i>>>14)>>>0)/4294967296}nextRange(i,o){return Math.floor(this.next()*(o-i+1))+i}}const Di=16,Pi=[{type:"number",label:"Min Note",path:"minNote"},{type:"number",label:"Max Note",path:"maxNote"},{type:"number",label:"Seed",path:"seed"}],Li=R({id:"nicepattern.chaos_generator",version:"1.0.0",displayName:"Chaos Generator",metadata:{category:"NicePattern",keywords:["chaos","random","generator","sequence","stochastic"],description:"Generates a random sequence of notes."},config:{minNote:l,maxNote:l,seed:l},inputs:{density:{...l,defaultValue:.5}},outputs:{seq_out:se},ui:{inspector:{fields:Pi}},execute:(e,i,o)=>{const{minNote:t,maxNote:n,seed:r}=i,s=e.density??.5,a=new _e(r??12345),c=[];for(let u=0;u<Di;u++)if(a.next()<s){const d=a.nextRange(t||60,n||60);c.push({noteIndex:d,velocity:a.next()*.5+.5,hold:!1})}else c.push({noteIndex:null,velocity:0,hold:!1});return{seq_out:c}},compileConfig:e=>({minNote:e.minNote??60,maxNote:e.maxNote??60,seed:e.seed??12345})});y(Li);class Ie{constructor(i){this.config=i,this.output=0,this.lastActive=!1}update(i,o,t){let r=i.noteIndex!==null&&i.noteIndex!==void 0;if(r){let s=!1;this.lastActive?t&&!i.hold&&(this.onRelease(),s=!0):s=!0,s&&this.onTrigger(i.velocity,i.noteIndex)}else this.lastActive&&this.onRelease();this.process(r,i,o),this.lastActive=r}forceRelease(){this.onRelease(),this.lastActive=!1,this.output=0}getValue(){return this.output}}class Fi extends Ie{onTrigger(i,o){this.output=i}onRelease(){this.output=0}process(i){i&&this.output===0&&(this.output=1)}previewSequence(i,o){return i.map(t=>t.noteIndex!==null&&t.noteIndex!==void 0?t.velocity:0)}}class zi extends Ie{constructor(i,o=.96){super(i),this.decayRate=.96,this.decayRate=o}onTrigger(i,o){this.output=i}onRelease(){this.output=0}process(i,o){i&&(this.output*=this.decayRate)}previewSequence(i,o){const t=[];let n=0,r=!1;for(const s of i){const a=s.noteIndex!==null&&s.noteIndex!==void 0;a&&!r?n=s.velocity:!a&&r&&(n=0),a&&(n*=this.decayRate),t.push(n),r=a}return t}}class ji extends Ie{constructor(){super(...arguments),this.phase=0,this.duty=.5,this.freq=.2}onTrigger(i,o){this.duty=.5}onRelease(){}process(i,o,t){if(!i){this.output*=.85;return}this.duty*=.98,this.phase+=this.freq,this.phase>1&&(this.phase-=1),this.output=this.phase<this.duty?1:0}previewSequence(i,o){const t=[];let n=0,r=0,s=.5,a=!1;for(const c of i){const u=c.noteIndex!==null&&c.noteIndex!==void 0;u&&!a&&(s=.5),u?(s*=.98,r+=this.freq,r>1&&(r-=1),n=r<s?1:0):n*=.85,t.push(n),a=u}return t}}class Bi extends Ie{onTrigger(i,o){}onRelease(){this.output*=.85}process(i){i?this.output=Math.random():this.output*=.85}previewSequence(i,o){const t=[];let n=0,r=!1;const a=(c=>()=>{c|=0,c=c+1831565813|0;var u=Math.imul(c^c>>>15,1|c);return u=u+Math.imul(u^u>>>7,61|u)^u,((u^u>>>14)>>>0)/4294967296})(12345);for(const c of i){const u=c.noteIndex!==null&&c.noteIndex!==void 0;!u&&r&&(n*=.85),u?n=a():n*=.85,t.push(n),r=u}return t}}class Oe extends Ie{constructor(i,o,t){super(i),this.osc=null,this.gain=null,this.filter=null,this.ctx=o,this.frequency=t??440}get audioContext(){return this.ctx}set audioContext(i){this.ctx=i}safeParam(i,o,t){if(Number.isFinite(o)&&Number.isFinite(t))try{i.setValueAtTime(o,t)}catch{}}initVoice(i,o){if(!this.ctx||this.ctx.state==="suspended")return;this.cleanup(),this.osc=this.ctx.createOscillator(),this.gain=this.ctx.createGain(),this.filter=this.ctx.createBiquadFilter();const t=Number.isFinite(this.frequency)&&this.frequency>0?this.frequency:440;this.safeParam(this.osc.frequency,t,i),this.filter.type="lowpass";const n=800+o*2e3;this.safeParam(this.filter.frequency,n,i),this.safeParam(this.gain.gain,0,i);try{this.gain.gain.linearRampToValueAtTime(o,i+.005),this.gain.gain.setTargetAtTime(0,i+.005,.1)}catch{}this.osc.connect(this.filter),this.filter.connect(this.gain),this.gain.connect(this.ctx.destination),this.osc.start(i)}retirePreviousVoice(i){if(!this.osc||!this.gain||!this.filter)return;const o=this.osc,t=this.gain,n=this.filter;this.osc=null,this.gain=null,this.filter=null;try{try{t.gain.cancelAndHoldAtTime(i)}catch{t.gain.cancelScheduledValues(i),this.safeParam(t.gain,t.gain.value,i)}t.gain.linearRampToValueAtTime(0,i+.005);const s=i+.005+.01;o.stop(s),o.onended=()=>{o.disconnect(),n.disconnect(),t.disconnect(),o.dispose?.(),n.dispose?.(),t.dispose?.()}}catch{o.disconnect(),n.disconnect(),t.disconnect()}}cleanup(){this.retirePreviousVoice(this.ctx?.currentTime??0)}onTrigger(i,o){if(this.ctx?.state!=="suspended"){if(o!=null){const t=440*Math.pow(2,(o-69)/12);Number.isFinite(t)&&(this.frequency=t)}this.initVoice(this.ctx?.currentTime??0,i)}}onRelease(){if(this.ctx?.state!=="suspended"&&this.gain){const i=this.ctx?.currentTime??0;try{this.gain.gain.cancelAndHoldAtTime(i)}catch{this.gain.gain.cancelScheduledValues(i),this.safeParam(this.gain.gain,this.gain.gain.value,i)}try{this.gain.gain.linearRampToValueAtTime(0,i+.005)}catch{}if(this.osc)try{this.osc.stop(i+.01)}catch{}}}process(i,o){i&&o.hold&&this.osc}previewSequence(i,o){const t=[];let n=!1;for(const r of i){const s=r.noteIndex!==null&&r.noteIndex!==void 0;s&&!n?t.push(r.velocity):t.push(0),n=s}return t}}function we(e,i,o){return R({id:e,version:"1.0.0",displayName:i,metadata:{category:"NicePattern",keywords:["layer","effect","modifier"],description:`Layer node: ${i}`},config:{},inputs:{midi_in:{type:V,description:"Input MIDI stream",allowMultiConnection:!0},prev_layer:{type:Ne,description:"Previous layer output"}},outputs:{out:Ne},autoBroadcast:{midi_in:{combine:{reduce:"flatten"}}},ui:{inspector:{fields:[]}},isRealtime:()=>!0,createState:(t,n)=>({layer:new o({}),lastActive:!1,activeVelocity:0,activeNote:null}),execute:(t,n,r,s)=>{const a=s.layer,c=t.midi_in||[];for(const p of c)p.type==="note_on"?(s.lastActive=!0,s.activeVelocity=p.velocity,s.activeNote=p.note):p.type==="note_off"&&s.activeNote===p.note&&(s.lastActive=!1,s.activeNote=null);const u={noteIndex:s.lastActive?s.activeNote??60:null,velocity:s.activeVelocity,hold:!1},d=c.some(p=>p.type==="note_on");return a.update(u,r.clock.dt,d),{out:a.getValue()}},compileConfig:t=>({})})}const $i=we("nicepattern.gate_layer","Gate Layer",Fi),Gi=we("nicepattern.exp_layer","Exponential Layer",zi),Hi=we("nicepattern.pwm_layer","PWM Layer",ji),Ui=we("nicepattern.noise_layer","Noise Layer",Bi);y($i);y(Gi);y(Hi);y(Ui);const Yi=R({id:"nicepattern.tone_synth_layer",version:"1.0.0",displayName:"Tone Synth Layer",metadata:{category:"NicePattern",keywords:["synth","audio","sound","tone"],description:"Simple synthesizer layer using Tone.js."},config:{},inputs:{midi_in:{type:V,description:"Input MIDI stream",allowMultiConnection:!0},prev_layer:{type:Ne,description:"Previous layer output"}},outputs:{out:Ne},autoBroadcast:{midi_in:{combine:{reduce:"flatten"}}},ui:{inspector:{fields:[]}},isRealtime:()=>!0,createState:(e,i)=>({layer:new Oe({}),lastActive:!1,lastActiveNote:null,activeVelocity:0,contextId:""}),execute:(e,i,o,t)=>{const n=o.audio?.context;t.layer||(t.layer=new Oe({})),n&&t.contextId!==n.contextId&&(t.layer=new Oe({}),t.contextId=n.contextId);const r=t.layer,s=e.midi_in||[];let a=!1;for(const d of s)d.type==="note_on"?(t.lastActive=!0,t.lastActiveNote=d.note,t.activeVelocity=d.velocity,a=!0):d.type==="note_off"&&t.lastActiveNote===d.note&&(t.lastActive=!1,t.lastActiveNote=null);const c={noteIndex:t.lastActive?t.lastActiveNote:null,velocity:t.activeVelocity,hold:!1};return r.audioContext||(o.audio?.context?r.audioContext=o.audio.context:typeof window<"u"&&(r.audioContext=new(window.AudioContext||window.webkitAudioContext))),r.update(c,o.clock.dt,a),{out:r.getValue()}},compileConfig:e=>({})});y(Yi);function We(e){if(e===1)return[[0]];const i=We(e/2),o=[];for(let t=0;t<i.length;t++)o.push([...i[t],...i[t]]);for(let t=0;t<i.length;t++)o.push([...i[t],...i[t].map(n=>1-n)]);return o}function Le(e){let i=0;for(let o=0;o<e.length-1;o++)e[o]!==e[o+1]&&i++;return i}function Wi(e,i){const o=We(8).sort((a,c)=>Le(a)-Le(c));o[0]=[1,1,1,1,1,1,1,1];const t=[0,1,2,3,4,5,6,7],n=new _e(i);for(let a=t.length-1;a>0;a--){const c=n.nextRange(0,a);[t[a],t[c]]=[t[c],t[a]]}const r=Math.max(2,Math.min(8,e));return o.slice(0,r).map(a=>{const c=new Array(8);for(let u=0;u<8;u++)c[u]=a[t[u]];return c})}const Zi=[{type:"number",label:"Seed",path:"seed",step:1}],Ki=R({id:"nicepattern.orthomod",version:"1.0.0",displayName:"Orthomod",metadata:{category:"NicePattern",keywords:["envelope","modulation","orthogonal","hadamard"],description:"Orthogonal code-based envelope generator."},config:{seed:l},inputs:{midi_in:{type:V,description:"Trigger Input",allowMultiConnection:!0},decay:{type:l,defaultValue:1.2,description:"Decay Time (s)",range:[0,4],step:.01},curve:{type:l,defaultValue:1.5,description:"Response Curve",range:[.1,4],step:.1},relcurve:{type:l,defaultValue:12,description:"Release Curve",range:[.1,20],step:.1},resolution:{type:l,defaultValue:8,range:[2,8],step:1,description:"Codebook Size"},manual_phase:{type:l,defaultValue:-1,description:"Manual Phase Override (0-1)",suppressInputEditor:!0}},outputs:{env:{type:l,description:"Envelope Output (0-1)"},vec:{type:Re,description:"Channel Values [c1, c2, c3, c4]"},ch1:{type:l,description:"Channel 1"},ch2:{type:l,description:"Channel 2"},ch3:{type:l,description:"Channel 3"},ch4:{type:l,description:"Channel 4"}},autoBroadcast:{midi_in:{combine:{reduce:"flatten"}}},ui:{inspector:{fields:Zi}},isRealtime:()=>!0,createState:()=>({linearEnv:0,gateOpen:!1,active:!1,codes:[],lastSeed:-1,lastResolution:-1,currentEffectiveCurve:1.5,phase:0}),execute:(e,i,o,t)=>{const n=o.clock.dt;t.phase+=n;const r=t.phase,s=e.decay,a=typeof s=="number"&&Number.isFinite(s)?Math.max(.001,s):1.2,c=e.curve,u=typeof c=="number"&&Number.isFinite(c)?Math.max(.001,c):1.5,d=e.relcurve,b=typeof d=="number"&&Number.isFinite(d)?Math.max(.1,d):12,p=e.resolution,f=typeof p=="number"&&Number.isFinite(p)?Math.floor(Math.max(2,Math.min(8,p))):8,m=i.seed??12345,g=e.manual_phase,I=typeof g=="number"&&Number.isFinite(g)?g:-1;(m!==t.lastSeed||f!==t.lastResolution)&&(t.codes=Wi(f,m),t.lastSeed=m,t.lastResolution=f);const N=(e.midi_in||[]).flat();for(const D of N)D.type==="note_on"?(t.linearEnv=1,t.gateOpen=!0,t.active=!0):D.type==="note_off"&&(t.gateOpen=!1);let k=0;I>=0?(t.linearEnv=Math.max(0,Math.min(1,I)),t.active=!0,t.currentEffectiveCurve=1):(t.active&&(t.linearEnv-=n/Math.max(.01,a),t.linearEnv<=0&&(t.linearEnv=0,t.active=!1)),!t.gateOpen&&t.active?t.currentEffectiveCurve=b:t.currentEffectiveCurve=u);const _=Math.max(0,t.linearEnv),q=t.currentEffectiveCurve;k=Math.pow(_,q),Number.isNaN(k)&&(k=0);let J=1-k;J=Math.max(0,Math.min(.999,J));const E=t.codes.length,S=Math.floor(J*E),X=t.codes[S]||t.codes[0],h=15,w=r*h%1>.5?1:0,M=Math.abs(Math.sin(r*h*Math.PI*2)),C=[0,0,0,0],H=[0,0,0,0];if(t.active)for(let D=0;D<4;D++){const U=X[D*2]||0,Y=X[D*2+1]||0;let v=0;U===0&&Y===0?v=0:U===1&&Y===1?v=1:U===1&&Y===0?v=w:U===0&&Y===1&&(v=M),H[D]=v,C[D]=v*k,Number.isNaN(C[D])&&(C[D]=0)}const F=D=>Number.isFinite(D)?D:0;return{outputs:{env:F(k),vec:C.map(F),ch1:F(C[0]),ch2:F(C[1]),ch3:F(C[2]),ch4:F(C[3])},ui:{codes:t.codes,env:F(k),vec:C.map(F),rawVec:t.active?H.map(F):[0,0,0,0],activeCodeIndex:S,gate:t.gateOpen?1:0}}},compileConfig:e=>({seed:e?.seed??12345})});y(Ki);const Xi=()=>({initialized:!1,contextId:"",masterGain:null,voices:[],lastRoot:-1}),Qi=R({id:"nicepattern.tone4",version:"1.0.0",displayName:"Tone 4",metadata:{category:"NicePattern",keywords:["synth","additive","oscillator","audio"],description:"4-voice additive synth driven by vector input."},inputs:{vec:{type:Re,description:"Modulation Vector [c1, c2, c3, c4]"},root:{type:l,defaultValue:60,description:"Root Note (MIDI)",range:[0,127]},gain:{type:l,defaultValue:.5,description:"Master Volume"}},outputs:{},isRealtime:()=>!0,createState:Xi,execute:(e,i,o,t)=>{const n=o.audio?.context;if(!n||n.state==="suspended")return{};const r=n.currentTime;if(!t.initialized||t.contextId!==n.contextId){t.masterGain=n.createGain(),t?.masterGain?.connect(n.destination);const p=[1,1.5,2,3],f=["square","sawtooth","triangle","sine"];t.voices=p.map((m,g)=>{const I=n.createOscillator(),N=n.createGain();return I.type=f[g],I.connect(N),N.connect(t.masterGain),I.start(r),N.gain.setValueAtTime(0,r),{osc:I,gain:N,freqRatio:m,wave:f[g]}}),t.initialized=!0,t.contextId=n.contextId,t.lastRoot=-1}const s=Math.max(0,Math.min(1,e.gain??.5));t.masterGain&&t.masterGain.gain.setTargetAtTime(s,r,.05);const a=e.root,c=typeof a=="number"&&Number.isFinite(a)?Math.floor(Math.max(0,Math.min(127,a))):69,u=440*Math.pow(2,(c-69)/12);Math.abs(u-t.lastRoot)>.01&&(t.voices.forEach(p=>{t.lastRoot===-1?p.osc.frequency.setValueAtTime(u*p.freqRatio,r):p.osc.frequency.setTargetAtTime(u*p.freqRatio,r,.05)}),t.lastRoot=u);const d=e.vec,b=Array.isArray(d)&&d.length===4?d:[0,0,0,0];return t.voices.forEach((p,f)=>{const m=Math.max(0,Math.min(1,b[f]??0));p.gain.gain.setTargetAtTime(m,r,.02)}),{}}});y(Qi);const ie={gravity:800,magnetEpsilon:50,physicsRate:120,solverSteps:16,sphereCount:16,magnetRange:800,height:600};class Fe{constructor(i,o,t,n,r,s){this.id=i,this.radius=6+s.next()*8,this.mass=this.radius,this.restLength=20+Math.pow(s.next(),2)*150;const a=o*.1,c=o-a*2;this.x=a+c/(r-1)*n,this.y=t-this.restLength,this.vx=0,this.vy=0,this.isLatched=!1,this.tensionRatio=0,this.currentSpringForce=0,this.currentMagForce=0}update(i,o,t,n,r){this.currentMagForce=0,this.currentSpringForce=0,this.tensionRatio=0;const a=(o-this.restLength-this.y)*r.springK,u=r.gravity*this.mass+a;this.currentSpringForce=Math.max(0,u);const d=f=>{if(f>=ie.magnetRange)return 0;const m=ie.magnetEpsilon/(f*f+ie.magnetEpsilon);return r.magnetStrength*m},b=d(0);if(n){const f=this.y-this.radius-t;if(this.isLatched||f<=2)if(b>u){this.isLatched=!0,this.y=t+this.radius,this.vy=0,this.currentMagForce=b,this.tensionRatio=Math.max(0,Math.min(1,u/b));return}else this.isLatched=!1}else this.isLatched=!1;let p=u;if(n&&!this.isLatched){const f=Math.max(0,this.y-this.radius-t),m=-d(f);this.currentMagForce=Math.abs(m),p+=m}this.vy+=p/this.mass*i,this.vy*=r.damping,this.y+=this.vy*i,this.y+this.radius>o&&(this.y=o-this.radius,this.vy*=-.5),this.y-this.radius<t&&(this.y=t+this.radius,n?this.vy<0&&(this.vy=0):this.vy*=-.6)}}const Ji=[{type:"number",label:"Seed",path:"seed",step:1,min:0,max:999999}],en=R({id:"nicepattern.magneto",version:"1.0.0",displayName:"Magneto",metadata:{category:"NicePattern",keywords:["envelope","physics","magnet","modulator"],description:"Physics-based magnetic envelope generator."},config:{seed:{...l,defaultValue:1337}},inputs:{midi_in:{type:V,description:"Trigger Input",allowMultiConnection:!0},attack:{type:l,defaultValue:.2,range:[.01,2],step:.01,description:"Attack Time (s)"},decay:{type:l,defaultValue:.25,range:[.01,2],step:.01,description:"Decay Time (s)"},sustain:{type:l,defaultValue:.6,range:[0,1],step:.01,description:"Sustain Level (0-1)"},release:{type:l,defaultValue:.3,range:[.01,5],step:.01,description:"Release Time (s)"},peak:{type:l,defaultValue:.9,range:[.1,1],step:.01,description:"Peak Level (0-1, inverted)"},mag_flux:{type:l,defaultValue:2e6,range:[1e5,4e6],step:1e4,description:"Magnet Strength"},spring_k:{type:l,defaultValue:25e3,range:[1e3,5e4],step:100,description:"Spring Stiffness"},damping:{type:l,defaultValue:.999,range:[.9,1],step:.001,description:"Damping Factor"}},outputs:{env:{type:l,description:"Envelope Output (Tension)"},vec:Re,ch1:{type:l,description:"Channel 1 (Tension)"},ch2:{type:l,description:"Channel 2 (Extension)"},ch3:{type:l,description:"Channel 3 (Spring Force)"},ch4:{type:l,description:"Channel 4 (Mag Force)"}},autoBroadcast:{midi_in:{combine:{reduce:"flatten"}}},ui:{inspector:{fields:Ji}},isRealtime:()=>!0,createState:()=>{const e=[],o=ie.height,t=new _e(1337);for(let n=0;n<ie.sphereCount;n++)e.push(new Fe(n,600,o,n,ie.sphereCount,t));return{spheres:e,plateY:40,phase:"IDLE",sustainProgress:0,accumulator:0,lastGate:!1,isTouchingSim:!1,touchY:0}},onMessage:(e,i)=>{i.type==="manual_interaction"&&(e.isTouchingSim=i.active,typeof i.y=="number"&&(e.touchY=i.y))},execute:(e,i,o,t)=>{const n=o.clock.dt,r=e.midi_in||[];let s=t.lastGate;for(const O of r)O.type==="note_on"?s=!0:O.type==="note_off"&&(s=!1);const a=Math.max(.005,e.attack??.2),c=Math.max(.005,e.decay??.25),u=e.sustain??.6,d=Math.max(.005,e.release??.3),b=e.peak??.9,p=i.seed??1337,f=e.mag_flux??2e6,m=e.spring_k??25e3,g=e.damping??.999;if(t.currentSeed!==p||t.spheres.length===0){t.currentSeed=p;const O=new _e(p);t.spheres=[];const $=600,ne=ie.height;for(let A=0;A<ie.sphereCount;A++)t.spheres.push(new Fe(A,$,ne,A,ie.sphereCount,O))}const I=ie.height,N=I*.95,k=I*.1,_=40,q=k+b*(N-k),J=k+u*(N-k),E=Math.min(1,.05/Math.max(.001,a)),S=Math.min(1,.02/Math.max(.001,c)),X=Math.min(1,.02/Math.max(.001,d));s&&!t.lastGate?(t.phase="ATTACK",t.sustainProgress=0):!s&&t.lastGate&&(t.phase="RELEASE",t.sustainProgress=0),t.lastGate=s,t.accumulator+=n;const h=1/ie.physicsRate;let w=!1,M=0;for(;t.accumulator>=h&&M<5;){t.accumulator-=h,M++;let O=_,$=X;t.isTouchingSim?(t.phase="MANUAL",w=!0,O=t.touchY,O=Math.max(_,Math.min(N,O)),$=E,t.sustainProgress=0):s?((t.phase==="IDLE"||t.phase==="RELEASE"||t.phase==="MANUAL")&&(t.phase==="MANUAL"?t.phase="ATTACK":(t.phase="ATTACK",t.sustainProgress=0)),t.phase==="ATTACK"?(O=q,$=E,Math.abs(t.plateY-q)<10&&(t.phase="DECAY")):t.phase==="DECAY"?(O=J,$=S,Math.abs(t.plateY-J)<5&&(t.phase="SUSTAIN")):t.phase==="SUSTAIN"&&(O=J,$=.1,t.sustainProgress+=(1-t.sustainProgress)*2*h),w=!0):(t.phase="RELEASE",O=_,$=X,Math.abs(t.plateY-_)<15?(w=!1,t.phase="IDLE"):w=!0);const ne=O-t.plateY;t.plateY+=ne*$;const A=h/ie.solverSteps,ue={gravity:ie.gravity,springK:m,magnetStrength:f,damping:g};for(let L=0;L<ie.solverSteps;L++)t.spheres.forEach(W=>{W.update(A,I,t.plateY,w,ue)})}t.accumulator>h&&(t.accumulator=0);let C=0,H=0,F=0,D=0,U=0;t.spheres.forEach(O=>{O.isLatched&&(U++,C+=O.tensionRatio);const $=Math.max(0,I-O.restLength-O.y);H+=$,F+=O.currentSpringForce,D+=O.currentMagForce});const Y=U>0?C/U:0,v=Math.min(1,H/(I*ie.sphereCount*.4)),B=ie.sphereCount*m*I*.3,T=ie.sphereCount*f,P=Math.min(1,F/B),z=Math.min(1,D/T),ce=[Y,v,P,z],j={plateY:t.plateY,phase:t.phase,sustainProgress:t.sustainProgress,spheres:t.spheres.map(O=>({x:O.x,y:O.y,r:O.radius,l:O.isLatched,t:O.tensionRatio})),adsr:{attack:a,decay:c,sustain:u,release:d,peak:b},seed:p};return{outputs:{env:Y,vec:ce,ch1:Y,ch2:v,ch3:P,ch4:z},ui:j}},compileConfig:e=>({seed:e?.seed??1337})});y(en);const Ve=16,tn=R({id:"seq.tomidi",version:"1.0.0",displayName:"To MIDI",metadata:{category:"Sequence",keywords:["pattern","sequencer","combiner","event","midi"],description:"Converts sequence(s) into a MIDI stream."},config:{},inputs:{seq_in:{type:se,description:"Input sequence(s)",allowMultiConnection:!0}},outputs:{midi_out:V},autoBroadcast:!0,reshape:"none",isRealtime:()=>!0,createState:()=>({sequenceStates:new Map}),execute:(e,i,o,t)=>{let r=e.seq_in||[];r.length===1&&Array.isArray(r[0])&&r[0].length>0&&Array.isArray(r[0][0])&&(r=r[0]);const s=[],u=(Math.floor(o.clock.beat*4)%Ve+Ve)%Ve,d=new Set;r.forEach((b,p)=>d.add(p)),t.sequenceStates.forEach((b,p)=>d.add(p));for(const b of d){const p=r[b];t.sequenceStates.has(b)||t.sequenceStates.set(b,{lastStepIndex:-1,lastNoteIndex:null,lastHold:!1,activeNotes:new Map});const f=t.sequenceStates.get(b);if(!p&&f.lastNoteIndex===null){t.sequenceStates.delete(b);continue}let m={noteIndex:null,velocity:0,hold:!1};if(p&&p[u]&&(m=p[u]),u!==f.lastStepIndex||!p||m.noteIndex!==f.lastNoteIndex){const g=f.lastNoteIndex,I=f.lastHold,N=m.noteIndex!==null&&m.noteIndex!==void 0,k=N&&m.noteIndex===g,_=g!==null&&(!k||!I),q=N&&(!k||!I);_&&g!==null&&(s.push({type:"note_off",note:g,velocity:0,channel:1,deviceId:"tomidi",time:0}),f.activeNotes.delete(g),f.lastNoteIndex=null,f.lastHold=!1),q&&m.noteIndex!==null?(s.push({type:"note_on",note:m.noteIndex,velocity:m.velocity,channel:1,deviceId:"tomidi",time:0}),f.activeNotes.set(m.noteIndex,m.velocity),f.lastNoteIndex=m.noteIndex,f.lastHold=m.hold):k&&I&&(f.lastHold=m.hold),f.lastStepIndex=u}}return{midi_out:s}}});y(tn);const nn=R({id:"seq.sequencer",version:"1.0.0",displayName:"Sequencer",metadata:{category:"Sequence",keywords:["sequencer","step","pattern"],description:"16-step sequencer."},config:{sequence:{kind:"array",size:16,element:{kind:"record",fields:{noteIndex:l,velocity:l,hold:{kind:"atomic",type:"boolean"}}}}},inputs:{},outputs:{seq_out:se},ui:{},compileConfig:e=>{const i=Array(16).fill({noteIndex:null,velocity:0,hold:!1});return{sequence:e?.values?.sequence??i}},createState:()=>({currentStepIndex:0}),isRealtime:()=>!1,execute:(e,i,o,t)=>{const n=Array(16).fill({noteIndex:null,velocity:0,hold:!1});return{outputs:{seq_out:i.sequence||n},ui:{currentStepIndex:t.currentStepIndex}}}});y(nn);const on=R({id:"seq.oneshot",version:"1.0.0",displayName:"One Shot",metadata:{category:"Sequence",keywords:["player","trigger","oneshot","envelope"],description:"Plays a sequence once upon trigger."},config:{},autoBroadcast:{seq_in:{combine:{reduce:"first"}},trigger:{combine:{reduce:"flatten"}}},reshape:"none",inputs:{seq_in:{type:se,description:"Input sequence"},trigger:{type:V,description:"Trigger",allowMultiConnection:!0},duration:{type:l,defaultValue:4,description:"Duration (s)"}},outputs:{midi_out:V},isRealtime:()=>!0,createState:()=>({isPlaying:!1,startTime:0,lastStepIndex:-1,lastNoteIndex:null,lastHold:!1,activeNotes:new Map}),execute:(e,i,o,t)=>{const n=e.trigger||[];let r=!1;for(const g of n)if(g&&g.type==="note_on"&&g.velocity>0){r=!0;break}const s=o.audio?.context?.currentTime??0;r&&(t.isPlaying=!0,t.startTime=s);const a=e.seq_in||[],c=[];if(!t.isPlaying||!a||a.length===0)return t.lastNoteIndex!==null&&(c.push({type:"note_off",note:t.lastNoteIndex,velocity:0,channel:1,time:0,deviceId:"oneshot"}),t.lastNoteIndex=null,t.lastHold=!1),t.activeNotes.size>0&&t.activeNotes.clear(),{midi_out:c};const u=Math.max(.001,e.duration??4),b=(s-t.startTime)/u;if(b>=1)return t.isPlaying=!1,t.lastNoteIndex!==null&&(c.push({type:"note_off",note:t.lastNoteIndex,velocity:0,channel:1,time:0,deviceId:"oneshot"}),t.lastNoteIndex=null,t.lastHold=!1),{midi_out:c};const p=a.length,f=Math.floor(b*p);let m={noteIndex:null,velocity:0,hold:!1};if(a[f]&&(m=a[f]),f!==t.lastStepIndex||m.noteIndex!==t.lastNoteIndex){const g=t.lastNoteIndex,I=t.lastHold,N=m.noteIndex!==null,k=N&&m.noteIndex===g,_=g!==null&&(!k||!I),q=N&&(!k||!I);_&&g!==null&&(c.push({type:"note_off",note:g,velocity:0,channel:1,time:0,deviceId:"oneshot"}),t.activeNotes.delete(g),t.lastNoteIndex=null,t.lastHold=!1),q&&m.noteIndex!==null?(c.push({type:"note_on",note:m.noteIndex,velocity:m.velocity,channel:1,time:0,deviceId:"oneshot"}),t.activeNotes.set(m.noteIndex,m.velocity),t.lastNoteIndex=m.noteIndex,t.lastHold=m.hold):k&&I&&(t.lastHold=m.hold),t.lastStepIndex=f}return{midi_out:c}}}),sn=R({id:"seq.scan",version:"1.0.0",displayName:"Scan Sequence",metadata:{category:"Sequence",keywords:["player","scan","scrub"],description:"Plays a sequence by scanning through positions."},config:{},autoBroadcast:{seq_in:{combine:{reduce:"first"}}},reshape:"none",inputs:{seq_in:{type:se,description:"Input sequence"},pos:{type:l,defaultValue:0,description:"Position (0-1)"}},outputs:{midi_out:V},isRealtime:()=>!0,createState:()=>({lastStepIndex:-1,lastNoteIndex:null,lastHold:!1,activeNotes:new Map}),execute:(e,i,o,t)=>{const n=e.seq_in||[],r=e.pos??0,s=[];if(!n||n.length===0||r>=1||r<0)return t.lastNoteIndex!==null&&(s.push({type:"note_off",note:t.lastNoteIndex,velocity:0,channel:1,time:0,deviceId:"scan"}),t.lastNoteIndex=null,t.lastHold=!1),{midi_out:s};const a=n.length,c=Math.floor(r*a);let u={noteIndex:null,velocity:0,hold:!1};if(n[c]&&(u=n[c]),c!==t.lastStepIndex||u.noteIndex!==t.lastNoteIndex){const d=t.lastNoteIndex,b=t.lastHold,p=u.noteIndex!==null,f=p&&u.noteIndex===d,m=d!==null&&(!f||!b),g=p&&(!f||!b);m&&d!==null&&(s.push({type:"note_off",note:d,velocity:0,channel:1,time:0,deviceId:"scan"}),t.lastNoteIndex=null,t.lastHold=!1),g&&u.noteIndex!==null?(s.push({type:"note_on",note:u.noteIndex,velocity:u.velocity,channel:1,time:0,deviceId:"scan"}),t.lastNoteIndex=u.noteIndex,t.lastHold=u.hold):f&&b&&(t.lastHold=u.hold),t.lastStepIndex=c}return{midi_out:s}}});y(on);y(sn);const rn=R({id:"seq.crop",version:"1.0.0",displayName:"Crop Sequence",metadata:{category:"Sequence",keywords:["modifier","crop","slice"],description:"Mutes steps outside the specified range."},config:{mode:{kind:"atomic",type:"string",defaultValue:"start-end"}},autoBroadcast:{seq_in:{combine:{reduce:"first"}}},inputs:{seq_in:{type:se,description:"Input sequence"},start:{type:l,defaultValue:0},end:{type:l,defaultValue:1,optional:!0},length:{type:l,defaultValue:1,optional:!0}},outputs:{seq_out:se},ui:{inspector:{fields:[{type:"tab-bar",label:"Mode",path:"mode",options:[{label:"Start / End",value:"start-end"},{label:"Start / Length",value:"start-length"}]}]}},computeForwardPorts:(e,i)=>{const o=i.mode||"start-end",t={seq_in:se,start:{...l,defaultValue:0}};return o==="start-length"?t.length={...l,defaultValue:1}:t.end={...l,defaultValue:1},{inputs:{kind:"record",fields:t},outputs:{kind:"record",fields:{seq_out:se}}}},shouldRecompileOnConfigChange:()=>!0,compileConfig:e=>({mode:e.mode||"start-end"}),execute:(e,i)=>{const o=e.seq_in||[],t=i.mode||"start-end",n=o.map(c=>({...c})),r=e.start??0;let s=1;if(t==="start-length"){const c=e.length??1;s=r+c}else s=e.end??1;s<r&&(s=r);const a=n.length;for(let c=0;c<a;c++){const u=c/a;(u<r||u>=s)&&(n[c].noteIndex=null,n[c].velocity=0,n[c].hold=!1)}return{seq_out:n}}}),an=R({id:"seq.fill",version:"1.0.0",displayName:"Fill Sequence",metadata:{category:"Sequence",keywords:["generator","fill","range"],description:"Generates a sequence where steps inside the specified range are ON."},config:{mode:{kind:"atomic",type:"string",defaultValue:"start-length"},count:{...l,defaultValue:16}},inputs:{start:{type:l,defaultValue:0},end:{type:l,defaultValue:1,optional:!0},length:{type:l,defaultValue:.5,optional:!0}},outputs:{seq_out:se},ui:{inspector:{fields:[{type:"tab-bar",label:"Mode",path:"mode",options:[{label:"Start / End",value:"start-end"},{label:"Start / Length",value:"start-length"}],default:"start-length"},{type:"number",label:"Step Count",path:"count",min:1,max:128,step:1,default:16}]}},computeForwardPorts:(e,i)=>{const o=i.mode||"start-length",t={start:{...l,defaultValue:0}};return o==="start-length"?t.length={...l,defaultValue:.5}:t.end={...l,defaultValue:1},{inputs:{kind:"record",fields:t},outputs:{kind:"record",fields:{seq_out:se}}}},shouldRecompileOnConfigChange:()=>!0,compileConfig:e=>({mode:e.mode||"start-length",count:e.count??16}),execute:(e,i)=>{const o=i.count??16,t=i.mode||"start-length",n=[];for(let s=0;s<o;s++)n.push({noteIndex:null,velocity:0,hold:!1});const r=e.start??0;if(t==="start-length"){const s=e.length??.5,a=Math.round(s*o),c=Math.floor(r*o);for(let u=0;u<a;u++){const d=c+u;d>=0&&d<o&&(n[d]={noteIndex:60,velocity:1,hold:!1})}}else{const s=e.end??1;let a=r,c=s;c<a&&(c=a);for(let u=0;u<o;u++){const d=u/o;d>=a&&d<c&&(n[u]={noteIndex:60,velocity:1,hold:!1})}}return{seq_out:n}}});y(rn);y(an);const ye={noteIndex:null,velocity:0,hold:!1},he=e=>e.noteIndex!==null&&e.noteIndex!==void 0,Me=(e,i,o,t)=>R({id:`seq.${e}`,version:"1.0.0",displayName:i,metadata:{category:"Sequence",keywords:["logic",e,"binary"],description:o},config:{},inputs:{inputs:{type:se,description:"Sequences",allowMultiConnection:!0}},outputs:{seq_out:se},execute:n=>{const r=n.inputs||[];if(r.length===0)return{seq_out:[]};let s=0;if(r.forEach(c=>s=Math.max(s,c.length)),s===0)return{seq_out:[]};const a=[];for(let c=0;c<s;c++){let u={...ye};const d=r[0];d.length>0?u={...d[c%d.length]}:u={...ye};for(let b=1;b<r.length;b++){const p=r[b],f=p.length>0?p[c%p.length]:ye;u=t(u,f)}a.push(u)}return{seq_out:a}}}),ln=Me("xor","Sequence XOR","XORs multiple sequences.",(e,i)=>{const o=he(e),t=he(i);return o!==t?t?i:e:{...ye}}),cn=Me("sub","Sequence Subtract","Subtracts subsequent sequences from the first.",(e,i)=>he(i)?{...ye}:e),un=Me("and","Sequence AND","Output active only if both inputs active.",(e,i)=>he(e)&&he(i)?i:{...ye}),dn=Me("or","Sequence OR","Output active if any input active.",(e,i)=>he(i)?i:e),pn=R({id:"seq.negate",version:"1.0.0",displayName:"Sequence Negate",metadata:{category:"Sequence",keywords:["logic","not","invert"],description:"Inverts sequence activity."},config:{},autoBroadcast:{seq_in:{combine:{reduce:"first"}}},inputs:{seq_in:{type:se}},outputs:{seq_out:se},execute:e=>({seq_out:(e.seq_in||[]).map(t=>{const n={...t};return n.noteIndex!==null?(n.noteIndex=null,n.velocity=0,n.hold=!1):(n.noteIndex=60,n.velocity=1,n.hold=!1),n})})});y(ln);y(cn);y(un);y(dn);y(pn);const Ze=Q("math.add",{category:x.Math,keywords:["sum","plus"],description:"Adds a and b."},(e,i)=>e+i);y({version:"1.0.0",...Ze,displayName:"Add",aliases:["plus","sum"],extendedInputs:{a:{type:l,description:"Value A"},b:{type:l,description:"Value B"}},extendedOutputs:{result:{type:l,description:"Sum"}}});const Ke=Q("math.subtract",{category:x.Math,keywords:["minus","difference"],description:"Subtracts b from a."},(e,i)=>e-i);y({version:"1.0.0",...Ke,displayName:"Subtract",aliases:["minus","difference"],extendedInputs:{a:{type:l,description:"Minuend"},b:{type:l,description:"Subtrahend"}},extendedOutputs:{result:{type:l,description:"Result"}}});const Xe=Q("math.multiply",{category:x.Math,keywords:["times","product"],description:"Multiplies a and b."},(e,i)=>e*i);y({version:"1.0.0",...Xe,displayName:"Multiply",aliases:["times","product"],extendedInputs:{a:{type:l,description:"Factor A"},b:{type:l,description:"Factor B"}},extendedOutputs:{result:{type:l,description:"Product"}}});const Qe=Q("math.divide",{category:x.Math,keywords:["div","quotient"],description:"Divides a by b."},(e,i)=>e/i);y({version:"1.0.0",...Qe,displayName:"Divide",aliases:["div","quotient"],extendedInputs:{a:{type:l,description:"Dividend"},b:{type:l,description:"Divisor"}},extendedOutputs:{result:{type:l,description:"Quotient"}}});const Je=Q("math.pow",{category:x.Math,keywords:["power","exponent"],description:"Raises a to the power of b."},(e,i)=>Math.pow(e,i));y({version:"1.0.0",...Je,displayName:"Power",extendedInputs:{a:{type:l,description:"Base"},b:{type:l,description:"Exponent"}},extendedOutputs:{result:{type:l,description:"Result"}}});const et=Q("math.min",{category:x.Math,keywords:["minimum","smallest"],description:"Returns the smaller of a and b."},(e,i)=>Math.min(e,i));y({version:"1.0.0",...et,displayName:"Min",extendedInputs:{a:{type:l,description:"Value A"},b:{type:l,description:"Value B"}},extendedOutputs:{result:{type:l,description:"Minimum"}}});const tt=Q("math.max",{category:x.Math,keywords:["maximum","largest"],description:"Returns the larger of a and b."},(e,i)=>Math.max(e,i));y({version:"1.0.0",...tt,displayName:"Max",extendedInputs:{a:{type:l,description:"Value A"},b:{type:l,description:"Value B"}},extendedOutputs:{result:{type:l,description:"Maximum"}}});const it=ee({id:"math.fmod",metadata:{category:x.Math,keywords:["modulo","remainder"],description:"Floating point modulo operation."},inputs:{dividend:l,divisor:l},outputs:{div:l,mod:l},autoBroadcast:!0,execute:(e,i,o)=>{const{dividend:t,divisor:n}=e,r=Math.floor(t/n),s=t%n;return{div:r,mod:s}}});y({version:"1.0.0",...it,displayName:"FMod",extendedInputs:{dividend:{type:l,description:"Dividend"},divisor:{type:l,description:"Divisor",defaultValue:1,range:[0,10]}},extendedOutputs:{div:{type:l,description:"The integer division result."},mod:{type:l,description:"The remainder."}}});const nt=Q("logic.and",{category:x.Logic,keywords:["boolean","&&"],description:"Logical AND (1 if both non-zero, else 0)."},(e,i)=>e!==0&&i!==0?1:0);y({version:"1.0.0",...nt,displayName:"AND",extendedInputs:{a:{type:l,description:"Value A"},b:{type:l,description:"Value B"}},extendedOutputs:{result:{type:l,description:"Result"}}});const ot=Q("logic.or",{category:x.Logic,keywords:["boolean","||"],description:"Logical OR (1 if either non-zero, else 0)."},(e,i)=>e!==0||i!==0?1:0);y({version:"1.0.0",...ot,displayName:"OR",extendedInputs:{a:{type:l,description:"Value A"},b:{type:l,description:"Value B"}},extendedOutputs:{result:{type:l,description:"Result"}}});const st=Q("logic.xor",{category:x.Logic,keywords:["boolean","^"],description:"Logical XOR (1 if different truthiness, else 0)."},(e,i)=>e!==0!=(i!==0)?1:0);y({version:"1.0.0",...st,displayName:"XOR",extendedInputs:{a:{type:l,description:"Value A"},b:{type:l,description:"Value B"}},extendedOutputs:{result:{type:l,description:"Result"}}});const rt=Q("logic.equals",{category:x.Logic,keywords:["==","equality"],description:"Returns 1 if a equals b, else 0."},(e,i)=>e===i?1:0);y({version:"1.0.0",...rt,displayName:"Equals",extendedInputs:{a:{type:l,description:"Value A"},b:{type:l,description:"Value B"}},extendedOutputs:{result:{type:l,description:"Result"}}});const at=Q("logic.greater_than",{category:x.Logic,keywords:[">","gt"],description:"Returns 1 if a > b, else 0."},(e,i)=>e>i?1:0);y({version:"1.0.0",...at,displayName:"Greater Than",extendedInputs:{a:{type:l,description:"Value A"},b:{type:l,description:"Value B"}},extendedOutputs:{result:{type:l,description:"Result"}}});const lt=Q("logic.less_than",{category:x.Logic,keywords:["<","lt"],description:"Returns 1 if a < b, else 0."},(e,i)=>e<i?1:0);y({version:"1.0.0",...lt,displayName:"Less Than",extendedInputs:{a:{type:l,description:"Value A"},b:{type:l,description:"Value B"}},extendedOutputs:{result:{type:l,description:"Result"}}});var fn=Object.freeze({__proto__:null,primitive_add:Ze,primitive_and:nt,primitive_divide:Qe,primitive_equals:rt,primitive_fmod:it,primitive_greater_than:at,primitive_less_than:lt,primitive_max:tt,primitive_min:et,primitive_multiply:Xe,primitive_or:ot,primitive_pow:Je,primitive_subtract:Ke,primitive_xor:st});const ct=Q("math.abs",{category:x.Math,keywords:["absolute","magnitude"],description:"Returns the absolute value of a."},e=>Math.abs(e),"unary");y({version:"1.0.0",...ct,displayName:"Abs",extendedInputs:{a:{type:l,description:"Value"}},extendedOutputs:{result:{type:l,description:"Absolute Value"}}});const ut=Q("math.negate",{category:x.Math,keywords:["negative","invert"],description:"Negates a."},e=>-e,"unary");y({version:"1.0.0",...ut,displayName:"Negate",extendedInputs:{a:{type:l,description:"Value"}},extendedOutputs:{result:{type:l,description:"Negated Value"}}});const dt=Q("math.ceil",{category:x.Math,keywords:["ceiling","round up"],description:"Rounds a up to the nearest integer."},e=>Math.ceil(e),"unary");y({version:"1.0.0",...dt,displayName:"Ceil",extendedInputs:{a:{type:l,description:"Value"}},extendedOutputs:{result:{type:l,description:"Ceiling"}}});const pt=Q("math.floor",{category:x.Math,keywords:["floor","round down"],description:"Rounds a down to the nearest integer."},e=>Math.floor(e),"unary");y({version:"1.0.0",...pt,displayName:"Floor",extendedInputs:{a:{type:l,description:"Value"}},extendedOutputs:{result:{type:l,description:"Floor"}}});const ft=Q("math.round",{category:x.Math,keywords:["round","nearest"],description:"Rounds a to the nearest integer."},e=>Math.round(e),"unary");y({version:"1.0.0",...ft,displayName:"Round",extendedInputs:{a:{type:l,description:"Value"}},extendedOutputs:{result:{type:l,description:"Rounded Value"}}});const mt=Q("math.sin",{category:x.Math,keywords:["sine"],description:"Returns the sine of a (radians)."},e=>Math.sin(e),"unary");y({version:"1.0.0",...mt,displayName:"Sin",extendedInputs:{a:{type:l,description:"Value (Radians)"}},extendedOutputs:{result:{type:l,description:"Sine"}}});const yt=Q("math.cos",{category:x.Math,keywords:["cosine"],description:"Returns the cosine of a (radians)."},e=>Math.cos(e),"unary");y({version:"1.0.0",...yt,displayName:"Cos",extendedInputs:{a:{type:l,description:"Value (Radians)"}},extendedOutputs:{result:{type:l,description:"Cosine"}}});const ht=Q("math.tan",{category:x.Math,keywords:["tangent"],description:"Returns the tangent of a (radians)."},e=>Math.tan(e),"unary");y({version:"1.0.0",...ht,displayName:"Tan",extendedInputs:{a:{type:l,description:"Value (Radians)"}},extendedOutputs:{result:{type:l,description:"Tangent"}}});const gt=Q("math.sqrt",{category:x.Math,keywords:["square root"],description:"Returns the square root of a."},e=>Math.sqrt(e),"unary");y({version:"1.0.0",...gt,displayName:"Sqrt",extendedInputs:{a:{type:l,description:"Value"}},extendedOutputs:{result:{type:l,description:"Square Root"}}});const vt=Q("logic.not",{category:x.Logic,keywords:["!","invert"],description:"Logical NOT (1 if zero, 0 if non-zero)."},e=>e===0?1:0,"unary");y({version:"1.0.0",...vt,displayName:"NOT",extendedInputs:{a:{type:l,description:"Value"}},extendedOutputs:{result:{type:l,description:"Result"}}});var mn=Object.freeze({__proto__:null,primitive_abs:ct,primitive_ceil:dt,primitive_cos:yt,primitive_floor:pt,primitive_negate:ut,primitive_not:vt,primitive_round:ft,primitive_sin:mt,primitive_sqrt:gt,primitive_tan:ht});const ae=(e,i,o,t=x.Math)=>{const n=ee({id:e,metadata:{category:t,description:`Apply ${e.split(".").pop()} to all inputs.`},inputs:{values:{kind:"array",element:K,size:"dynamic",allowMultiConnection:!0}},outputs:{result:l},computeForwardPorts:(r,s,a)=>{const c=r.fields.values;let u=l;if(c&&c.kind==="array"){const d=c.element;(d.kind==="array"||d.kind==="record")&&(u=d)}return{inputs:{kind:"record",fields:{values:c}},outputs:{kind:"record",fields:{result:u}}}},execute:r=>{const s=r.values;if(!s||s.length===0)return{result:0};const a=s[0],c=Array.isArray(a);let u=!1,d=[];if(!c&&typeof a=="object"&&a!==null&&typeof a.x=="number"&&typeof a.y=="number"&&(u=!0,d=["x","y"],typeof a.z=="number"&&d.push("z"),typeof a.w=="number"&&d.push("w")),c||u||typeof a=="number"){const b=c?a.length:u?d.length:1,p=new Array(b);for(let f=0;f<b;f++){let m=c?a[f]:u?a[d[f]]:a;for(let g=1;g<s.length;g++){const I=s[g];let N;if(Array.isArray(I))N=I[f]??0;else if(typeof I=="object"&&I!==null&&"x"in I){const k=d[f];N=I[k],N===void 0&&(N=0)}else N=I;m=o(m,N)}p[f]=m}if(u){const f={};return d.forEach((m,g)=>f[m]=p[g]),{result:f}}else if(!c)return{result:p[0]};return{result:p}}else return{result:0}}});return y({version:"1.0.0",...n,displayName:i,extendedInputs:{values:{type:{kind:"array",element:l,size:"dynamic"},description:"Values to process.",suppressInputEditor:!0,suppressLabel:!0,allowMultiConnection:!0}},extendedOutputs:{result:{type:l,description:"Result"}}}),n},yn=ae("math.all.add","Sum All",(e,i)=>e+i),hn=ae("math.all.subtract","Subtract All",(e,i)=>e-i),gn=ae("math.all.multiply","Multiply All",(e,i)=>e*i),vn=ae("math.all.divide","Divide All",(e,i)=>e/i),bn=ae("math.all.pow","Power All",(e,i)=>Math.pow(e,i)),xn=ae("math.all.min","Min All",(e,i)=>Math.min(e,i)),In=ae("math.all.max","Max All",(e,i)=>Math.max(e,i)),kn=ae("logic.all.and","AND All",(e,i)=>e&&i?1:0,x.Logic),Nn=ae("logic.all.or","OR All",(e,i)=>e||i?1:0,x.Logic),_n=ae("logic.all.xor","XOR All",(e,i)=>!!e!=!!i?1:0,x.Logic),wn=ae("logic.all.equals","Equals All",(e,i)=>e===i?1:0,x.Logic),Mn=ae("logic.all.greater_than","Greater Than All",(e,i)=>e>i?1:0,x.Logic),Cn=ae("logic.all.less_than","Less Than All",(e,i)=>e<i?1:0,x.Logic);var Sn=Object.freeze({__proto__:null,primitive_all_add:yn,primitive_all_and:kn,primitive_all_divide:vn,primitive_all_equals:wn,primitive_all_greater_than:Mn,primitive_all_less_than:Cn,primitive_all_max:In,primitive_all_min:xn,primitive_all_multiply:gn,primitive_all_or:Nn,primitive_all_pow:bn,primitive_all_subtract:hn,primitive_all_xor:_n});const bt=ee({id:"math.pi",metadata:{category:x.Math,keywords:["pi","constant"],description:"Returns the value of Pi."},inputs:{},outputs:{result:l},execute:()=>({result:Math.PI})});y({version:"1.0.0",...bt,displayName:"Pi",extendedOutputs:{result:{type:l,description:"Pi"}}});const xt=ee({id:"math.e",metadata:{category:x.Math,keywords:["e","euler","constant"],description:"Returns the value of Euler's number."},inputs:{},outputs:{result:l},execute:()=>({result:Math.E})});y({version:"1.0.0",...xt,displayName:"E",extendedOutputs:{result:{type:l,description:"Euler's Number"}}});var Tn=Object.freeze({__proto__:null,primitive_e:xt,primitive_pi:bt});const It=ee({id:"math.clamp",metadata:{category:x.Math,keywords:["limit","range"],description:"Clamps a value between a minimum and maximum."},inputs:{value:l,min:{...l,defaultValue:0},max:{...l,defaultValue:1}},outputs:{result:l},autoBroadcast:{value:{combine:"collect"},min:{combine:"collect"},max:{combine:"collect"}},reshape:"vector",execute:e=>{const{value:i,min:o,max:t}=e;return{result:Math.max(o,Math.min(i,t))}}});y({version:"1.0.0",...It,displayName:"Clamp",extendedInputs:{value:{type:l,description:"Value to clamp."},min:{type:l,description:"Minimum value.",defaultValue:0,range:[0,1]},max:{type:l,description:"Maximum value.",defaultValue:1,range:[0,1]}},extendedOutputs:{value:{type:l,description:"The clamped value."}}});const kt=ee({id:"math.lerp",metadata:{category:x.Math,keywords:["lerp","mix","interpolate"],description:"Linear interpolation between a and b."},inputs:{a:l,b:l,t:l},config:{clamp:{kind:"atomic",type:"boolean",optional:!0}},outputs:{result:l},autoBroadcast:!0,execute:(e,i)=>{const{a:o,b:t,t:n}=e,r=i.clamp!==!1,s=o+(t-o)*n;return{result:r?Math.max(Math.min(s,Math.max(o,t)),Math.min(o,t)):s}}});y({version:"1.0.0",...kt,displayName:"Lerp",extendedInputs:{a:{type:l,description:"Start Value"},b:{type:l,description:"End Value"},t:{type:l,description:"Interpolant (0-1)"}},extendedOutputs:{result:{type:l,description:"Interpolated Value"}},compileConfig:e=>({fields:{clamp:e.clamp??!0},untagged:[]})});const Nt=ee({id:"math.map",metadata:{category:x.Math,keywords:["map","remap","range"],description:"Maps a value from one range to another."},inputs:{value:l,inMin:l,inMax:l,outMin:l,outMax:l},outputs:{result:l},autoBroadcast:!0,execute:e=>{const{value:i,inMin:o,inMax:t,outMin:n,outMax:r}=e;return{result:n+(i-o)*(r-n)/(t-o)}}});y({version:"1.0.0",...Nt,displayName:"Map",extendedInputs:{value:{type:l,description:"Input Value"},inMin:{type:l,description:"Input Min",defaultValue:0},inMax:{type:l,description:"Input Max",defaultValue:1},outMin:{type:l,description:"Output Min",defaultValue:0},outMax:{type:l,description:"Output Max",defaultValue:1}},extendedOutputs:{result:{type:l,description:"Mapped Value"}}});var On=Object.freeze({__proto__:null,primitive_clamp:It,primitive_lerp:kt,primitive_map:Nt});function Vn(e){if(!e)return;const i=e.type;if(!(!i||i==="any")){if(i==="float")return{kind:"atomic",type:"number"};if(i==="string")return{kind:"atomic",type:"string"};if(i.startsWith("float")){const o=parseInt(i.slice(5));if(!isNaN(o))return{kind:"array",size:o,element:{kind:"atomic",type:"number"}}}}}const _t={kind:"record",fields:{name:{kind:"atomic",type:"string"},type:K}},wt={id:"io.input",kind:"primitive",metadata:{category:x.IO,keywords:["source","in"],description:"Graph input node."},configType:_t,ui:{inspector:{fields:[{type:"structor-type",label:"Type",path:"type",default:"float"},{type:"string",label:"Name",path:"name"}]}},computeForwardPorts:(e,i,o)=>{let t=e.fields.value;if(!t){const n=Vn(i);n&&(t=n)}return t||(t={kind:"atomic",type:"number"}),{inputs:{kind:"record",fields:{value:{kind:"atomic",type:"number"}}},outputs:{kind:"record",fields:{value:t}}}},execute:(e,i,o)=>{const n=i?.fields?.name??"value";return{fields:{value:e.fields[n]!==void 0?e.fields[n]:e.fields.value}}}};y({version:"1.0.0",...wt,displayName:"Input",aliases:["in","source"],extendedOutputs:{value:{type:K,description:"The input value.",suppressInputEditor:!0,suppressLabel:!0}},compileConfig:e=>{const i=me(e,_t);return e.values&&(i.values=e.values),i}});var An=Object.freeze({__proto__:null,primitive_input:wt});const Mt={id:"io.output",kind:"primitive",metadata:{category:x.IO,keywords:["sink","out"],description:"Graph output node."},computeForwardPorts:(e,i,o)=>{const t=e.fields.value||{kind:"atomic",type:"any"};return{inputs:{kind:"record",fields:{value:t}},outputs:{kind:"record",fields:{value:t}}}},execute:(e,i,o)=>({fields:{value:e.fields.value}})};y({version:"1.0.0",...Mt,displayName:"Output",aliases:["out","sink"],extendedInputs:{value:{type:K,description:"The output value.",suppressInputEditor:!0,suppressLabel:!0}},extendedOutputs:{value:{type:K,description:"The graph output value.",suppressInputEditor:!0,suppressLabel:!0}}});var Rn=Object.freeze({__proto__:null,primitive_output:Mt});function qn(e){if(!e)return;const i=e.type;if(!(!i||i==="any")){if(i==="float")return{kind:"atomic",type:"number"};if(i==="string")return{kind:"atomic",type:"string"};if(i.startsWith("float")){const o=parseInt(i.slice(5));if(!isNaN(o))return{kind:"array",size:o,element:{kind:"atomic",type:"number"}}}}}function fe(e,i,o,t){if(!e||!e.includes("#"))return e;let n="";return o===1?n=t==="input"?"in":"out":o<=4?n=["x","y","z","w"][i]:n=i.toString(),e.replace(/#/g,n)}const qe=(e,i,o)=>{const n=o.loadedSubgraphs;if(!n)return{inputs:{kind:"record",fields:{}},outputs:{kind:"record",fields:{}}};const r=i.subgraphId,s=n.get(r);if(s){const a=Object.values(s.inner.nodes),c={},u=a.filter(p=>p.config.typeId==="io.input"||p.config.typeId==="input").sort((p,f)=>p.y-f.y);u.forEach((p,f)=>{let m=p.config.name||"value";m=fe(m,f,u.length,"input");const g=qn(p.config);c[m]=g||{kind:"atomic",type:"any"}});const d={},b=a.filter(p=>p.config.typeId==="io.output"||p.config.typeId==="output").sort((p,f)=>p.y-f.y);return b.forEach((p,f)=>{let m=p.config.name||"value";m=fe(m,f,b.length,"output"),d[m]={kind:"atomic",type:"any"}}),{inputs:{kind:"record",fields:c},outputs:{kind:"record",fields:d}}}return{inputs:{kind:"record",fields:{}},outputs:{kind:"record",fields:{}}}},Ct=ee({id:"core.subgraph",subgraphExpansionTag:"inline",metadata:{category:x.Core,keywords:["nested","graph"],description:"Executes a nested subgraph."},config:{subgraphId:{kind:"atomic",type:"string"}},inputs:{},outputs:{},ui:{inspector:{fields:[{type:"string",label:"Subgraph ID",path:"subgraphId"}]}},getDisplayLabel:e=>{if(e.subgraphId){const i=e.subgraphId.split(".");return i[i.length-1]}},computeForwardPorts:qe,execute:(e,i,o)=>({fields:{}})});y({version:"1.0.0",...Ct,displayName:"Subgraph"});var En=Object.freeze({__proto__:null,computeSubgraphPorts:qe,primitive_subgraph:Ct,resolvePortName:fe});const St=ee({id:"core.thensubgraph",subgraphExpansionTag:"onTrigger",metadata:{category:x.Core,keywords:["nested","graph","conditional","midi","trigger"],description:"Executes a nested subgraph when a MIDI Note On event is received."},config:{subgraphId:{kind:"atomic",type:"string"}},inputs:{midi_in:V},outputs:{},ui:{inspector:{fields:[{type:"string",label:"Subgraph ID",path:"subgraphId"}]}},getDisplayLabel:e=>{if(e.subgraphId){const i=e.subgraphId.split(".");return`OnNote: ${i[i.length-1]}`}return"OnNote"},computeForwardPorts:((e,i,o)=>{const t=qe(e,i,o);return{inputs:{kind:"record",fields:{...t.inputs.fields,midi_in:V}},outputs:t.outputs}}),execute:(e,i,o)=>{const t=e.midi_in||[],n=Array.isArray(t)?t:[];let r=!1;for(const s of n)if(s.type==="note_on"&&(s.velocity??0)>0){r=!0;break}return r&&o.executeSubgraph&&o.executeSubgraph("onTrigger"),{fields:{}}}});y(St);var Dn=Object.freeze({__proto__:null,primitive_thensubgraph:St});const Tt=ee({id:"core.pack",metadata:{category:x.Core,keywords:["pack","record","struct","vector"],description:"Packs inputs into a record or vector."},config:{targetType:{kind:"atomic",type:"string",defaultValue:"infer"}},inputs:{},outputs:{result:K},ui:{inspector:{fields:[{type:"tab-bar",label:"Target Type",path:"targetType",options:[{label:"Infer",value:"infer"},{label:"float2",value:"float2"},{label:"float3",value:"float3"},{label:"float4",value:"float4"}]}]}},computeBackwardPorts:(e,i,o)=>{const t=i?.targetType||"infer";let n=null;if(t==="infer"){const s=e.fields.result;s&&s.kind==="record"&&(s.fields.x&&s.fields.y&&s.fields.z&&s.fields.w?n="float4":s.fields.x&&s.fields.y&&s.fields.z?n="float3":s.fields.x&&s.fields.y&&(n="float2"))}else n=t;const r={kind:"record",fields:{}};return n==="float4"?r.fields={x:l,y:l,z:l,w:l}:n==="float3"?r.fields={x:l,y:l,z:l}:n==="float2"&&(r.fields={x:l,y:l}),{inputRequirements:r,backwardMetadata:{inferredType:n}}},computeForwardPorts:(e,i,o,t)=>{const n=i,r=n?.targetType||n?.fields?.targetType||"infer";let s=r!=="infer"?r:t?.inferredType||"float2";const a={},c={};return["float2","float3","float4"].includes(s)||(s="float2"),s==="float4"?(a.x=l,a.y=l,a.z=l,a.w=l,c.result={kind:"array",size:4,element:l,hint:"float4"}):s==="float3"?(a.x=l,a.y=l,a.z=l,c.result={kind:"array",size:3,element:l,hint:"float3"}):(a.x=l,a.y=l,c.result={kind:"array",size:2,element:l,hint:"float2"}),{inputs:{kind:"record",fields:a},outputs:{kind:"record",fields:c}}},shouldRecompileOnConfigChange:(e,i)=>e?.targetType!==i?.targetType,execute:(e,i)=>{const o=e?.fields||{};let t=i?.targetType||"infer";return t==="infer"&&(o.w!==void 0?t="float4":o.z!==void 0?t="float3":o.y!==void 0&&o.x!==void 0?t="float2":t="record"),t==="float4"?{result:[o.x??0,o.y??0,o.z??0,o.w??0]}:t==="float3"?{result:[o.x??0,o.y??0,o.z??0]}:t==="float2"?{result:[o.x??0,o.y??0]}:{result:{fields:o}}}});y({version:"1.0.0",...Tt,displayName:"Pack",extendedOutputs:{result:{type:K,description:"Record"}}});var Pn=Object.freeze({__proto__:null,primitive_pack:Tt});const Ot=ee({id:"core.unpack",metadata:{category:x.Core,keywords:["unpack","destructure","split"],description:"Unpacks a record or fixed-length vector into outputs."},config:{},inputs:{record:K},computeForwardPorts:(e,i,o)=>{const t=e.fields.record;let n={};if(t){if(t.kind==="record")n=t.fields;else if(t.kind==="array"&&typeof t.size=="number"&&t.size<=16){const r=t.size;if(r===2)n.x=t.element,n.y=t.element;else if(r===3)n.x=t.element,n.y=t.element,n.z=t.element;else if(r===4)n.x=t.element,n.y=t.element,n.z=t.element,n.w=t.element;else for(let s=0;s<r;s++)n[s.toString()]=t.element}}return{inputs:{kind:"record",fields:{record:t||K}},outputs:{kind:"record",fields:n}}},outputs:{},dynamicOutputType:K,execute:e=>{let i=e.record;if(!i)return{};if(Array.isArray(i)&&i.length===1&&typeof i[0]=="object"&&i[0]!==null){const o=i[0];("x"in o||"fields"in o||Object.keys(o).length>0)&&(i=o)}if(Array.isArray(i)){const o=i.length,t={};if(o===2)t.x=i[0],t.y=i[1];else if(o===3)t.x=i[0],t.y=i[1],t.z=i[2];else if(o===4)t.x=i[0],t.y=i[1],t.z=i[2],t.w=i[3];else for(let n=0;n<o;n++)n<16&&(t[n.toString()]=i[n]);return t}return typeof i=="object"&&i!==null?"fields"in i?i.fields:i:{}}});y({version:"1.0.0",...Ot,displayName:"Unpack",extendedInputs:{record:{type:K,description:"Record to unpack"}}});var Ln=Object.freeze({__proto__:null,primitive_unpack:Ot});function Vt(e){return e&&e.kind==="array"&&e.element?.kind==="record"?"midi":"primitive"}function At(e,i){if(i==="primitive")if(Array.isArray(e)){for(const o of e)if(o)return!0;return!1}else return!!e;else{const o=e||[];if(Array.isArray(o)){for(const t of o)if(t&&t.type==="note_on"&&(t.velocity??0)>0)return!0}return!1}}const Rt=ee({id:"core.ifthen",subgraphExpansionTag:"onTrigger",metadata:{category:x.Core,keywords:["group","conditional","spatial","if","then"],description:"Spatially groups nodes and executes them when a MIDI Note On event is received."},config:{width:{kind:"atomic",type:"number",defaultValue:3},height:{kind:"atomic",type:"number",defaultValue:3},regionX:{kind:"atomic",type:"number",defaultValue:0,optional:!0},regionY:{kind:"atomic",type:"number",defaultValue:0,optional:!0},visibility:{kind:"atomic",type:"string",defaultValue:"auto",optional:!0},mode:{kind:"atomic",type:"string",defaultValue:"midi",optional:!0}},inputs:{midi_in:V},outputs:{},ui:{inspector:{fields:[{type:"number",label:"Width",path:"width",min:1,step:1},{type:"number",label:"Height",path:"height",min:1,step:1},{type:"number",label:"Region X (Offset)",path:"regionX",step:1},{type:"number",label:"Region Y (Offset)",path:"regionY",step:1},{type:"tab-bar",label:"Visibility",path:"visibility",options:[{label:"Auto",value:"auto"},{label:"Show",value:"show"},{label:"Hide",value:"hide"}],default:"auto"}]}},getDisplayLabel:()=>"IfThen",getRegion:e=>({x:e.regionX??0,y:e.regionY??0,width:e.width??1,height:e.height??1,visibility:e.visibility||ze.Show}),getChildren:(e,i)=>{const o=[],t=e.config,n=t.regionX??0,r=t.regionY??0,s=t.width??1,a=t.height??1,c=e.x+n,u=e.y+r,d=c+s,b=u+a;for(const p of Object.values(i))p.id!==e.id&&p.x>=c&&p.x<d&&p.y>=u&&p.y<b&&o.push(p.id);return o},execute:(e,i,o)=>{const t=i.mode||"midi",n=e.midi_in;return At(n,t)&&o.executeSubgraph&&o.executeSubgraph("onTrigger"),{fields:{}}},computeForwardPorts:(e,i,o)=>{const t=e.fields.midi_in;let n="midi",r=V;return t&&(n=Vt(t),n==="primitive"&&(r=t)),{inputs:{kind:"record",fields:{midi_in:r}},outputs:{kind:"record",fields:{}},forwardMetadata:{mode:n}}},compileConfig:(e,i)=>({fields:{...e,mode:i?.mode||"midi"}})});y(Rt);var Fn=Object.freeze({__proto__:null,primitive_ifthen:Rt});function qt(e){return typeof e=="number"?l:typeof e=="string"?{kind:"atomic",type:"string"}:typeof e=="boolean"?{kind:"atomic",type:"boolean"}:Array.isArray(e)?{kind:"array",element:e.length>0?qt(e[0]):K,size:e.length}:K}const Et={id:"data.literal",kind:"primitive",metadata:{category:x.Data,keywords:["value","constant"],description:"Outputs a constant value."},configType:{kind:"atomic",type:"any"},computeForwardPorts:(e,i,o)=>({inputs:{kind:"record",fields:{}},outputs:{kind:"record",fields:{value:qt(i)}}}),execute:(e,i,o)=>({fields:{value:i&&typeof i=="object"&&"value"in i?i.value:i}})};y({version:"1.0.0",...Et,displayName:"Literal",extendedOutputs:{value:{type:K,description:"The literal value."}},compileConfig:e=>e?.literal?.value??0});var zn=Object.freeze({__proto__:null,primitive_literal:Et});const Dt=ee({id:"util.hub",metadata:{category:x.Utility,keywords:["hub","reroute"],description:"Passes input to output."},inputs:{value:K},outputs:{value:K},autoBroadcast:!0,execute:e=>({value:e.value})});y({version:"1.0.0",...Dt,displayName:"Hub",extendedInputs:{value:{type:K,description:"Input",suppressInputEditor:!0,suppressLabel:!0}},extendedOutputs:{value:{type:K,description:"Output",suppressLabel:!0}}});const Pt=ee({id:"data.float",metadata:{category:x.Data,keywords:["float","number","slider"],description:"Float value with slider."},inputs:{value:l},outputs:{value:l},autoBroadcast:!0,execute:e=>({value:e.value})});y({version:"1.0.0",...Pt,displayName:"Float",extendedInputs:{value:{type:l,description:"Value",defaultValue:0}},extendedOutputs:{value:{type:l,description:"Value"}},compileConfig:e=>({values:{value:e.value??0},fields:{},untagged:[]})});var jn=Object.freeze({__proto__:null,primitive_float:Pt,primitive_hub:Dt});const Lt={id:"functional.apply",kind:"primitive",metadata:{category:x.Functional,keywords:["call","invoke"],description:"Applies a functor to an input value."},computeForwardPorts:(e,i,o)=>{const t=e.fields.functor;return{inputs:e,outputs:{kind:"record",fields:{result:t?t.output:{kind:"atomic",type:"any"}}}}},execute:(e,i,o)=>{const t=e.fields.functor,n=e.fields.input;return{fields:{result:t(n)}}}};y({version:"1.0.0",...Lt,displayName:"Apply Functor",extendedInputs:{functor:{type:{kind:"functor",input:K,output:K},description:"The functor to apply."},value:{type:K,description:"The value to apply the functor to."}},extendedOutputs:{result:{type:K,description:"The result of the functor application."}}});var Bn=Object.freeze({__proto__:null,primitive_apply:Lt});const Ft=ee({id:"logic.select",metadata:{category:x.Logic,keywords:["switch","case","mux","conditional","select"],description:"Selects an output value from multiple inputs based on a control value."},inputs:{},config:{count:{kind:"atomic",type:"number",defaultValue:2},mode:{kind:"atomic",type:"string",defaultValue:"value"},base:{kind:"atomic",type:"number",defaultValue:0,optional:!0},step:{kind:"atomic",type:"number",defaultValue:1,optional:!0}},outputs:{result:Z},autoBroadcast:!1,computeForwardPorts:(e,i,o)=>{const t=i.fields,n=t.count||2,r=t.mode||"value",s={value:l},a=[];for(let u=0;u<n;u++)if(r==="range"){const d=`val_${u}`;s[d]={...l,description:`Case ${u+1} Value`},e.fields&&e.fields[d]&&a.push(e.fields[d])}else r==="value"?(s[`match_${u}`]={...l,description:`Case ${u+1} Match`},s[`val_${u}`]={...l,description:`Case ${u+1} Value`},e.fields&&e.fields[`val_${u}`]&&a.push(e.fields[`val_${u}`])):r==="zone"&&(s[`threshold_${u}`]={...l,description:`Case ${u+1} Threshold`},s[`val_${u}`]={...l,description:`Case ${u+1} Value`},e.fields&&e.fields[`val_${u}`]&&a.push(e.fields[`val_${u}`]));const c=Ae(a);return{inputs:{kind:"record",fields:s},outputs:{kind:"record",fields:{result:c}}}},compileConfig:e=>({fields:{count:e.count||2,mode:e.mode||"value",base:e.base||0,step:e.step||1}}),shouldRecompileOnConfigChange:(e,i)=>{const o=e,t=i;return o.count!==t?.count||o.mode!==t?.mode},execute:(e,i,o)=>{const t=i.count??2,n=i.mode??"value",r=i.base??0,s=i.step??1,a={value:{type:l}};for(let p=0;p<t;p++){const f=`val_${p}`;a[f]={type:Z},n==="value"?a[`match_${p}`]={type:l}:n==="zone"&&(a[`threshold_${p}`]={type:l})}const c=Gt(o,a,e),u=c.value??0;let d=-1;if(n==="range")if(s===0)d=0;else{const p=Math.round((u-r)/s);d=Math.max(0,Math.min(t-1,p))}else if(n==="value")for(let f=0;f<t;f++){const m=c[`match_${f}`]??f+1;if(Math.abs(u-m)<1e-4){d=f;break}}else if(n==="zone")for(let p=0;p<t;p++){const f=c[`threshold_${p}`]??1/0;if(u<=f){d=p;break}}let b=0;return d!==-1?b=c[`val_${d}`]??0:b=0,{result:b}}});y({version:"1.0.0",...Ft,displayName:"Select",extendedInputs:{value:{type:l,description:"Control Value"}},extendedOutputs:{result:{type:Z,description:"Selected Value"}},ui:{inspector:{fields:[{type:"number",label:"Count",path:"count",min:2,max:32,step:1,default:2},{type:"tab-bar",label:"Mode",path:"mode",default:"value",options:[{label:"Value (Match)",value:"value"},{label:"Range (Index)",value:"range"},{label:"Zone (Threshold)",value:"zone"}]},{type:"number",label:"Base Index",path:"base",step:1,default:0,visible:e=>e.mode==="range"},{type:"number",label:"Step Size",path:"step",step:1,default:1,visible:e=>e.mode==="range"}]}}});var $n=Object.freeze({__proto__:null,logic_select:Ft});const zt=ee({id:"logic.latch",metadata:{category:x.Logic,keywords:["latch","sample","hold","trigger","store"],description:"Stores and outputs a value when the trigger condition is met."},config:{initMode:{kind:"atomic",type:"string",defaultValue:"auto"},mode:{kind:"atomic",type:"string",defaultValue:"midi",optional:!0}},inputs:{condition:V,value:Z,init:Z},outputs:{result:Z},autoBroadcast:!1,createState:()=>({currentValue:void 0,initialized:!1}),computeForwardPorts:(e,i,o)=>{const n=i.fields.initMode||"auto",r=(e.fields||e).condition,s=Vt(r),a=(e.fields||e).value||Z;let c=(e.fields||e).init||Z;n==="auto"&&(c=a);const u=Ae([a,c]),d={condition:r||V,value:a};return n==="manual"&&(d.init=c),{inputs:{kind:"record",fields:d},outputs:{kind:"record",fields:{result:u}},forwardMetadata:{mode:s}}},compileConfig:(e,i)=>({fields:{initMode:e.initMode||"auto",mode:i?.mode||"midi"}}),shouldRecompileOnConfigChange:(e,i)=>{const o=e,t=i;return o.initMode!==t?.initMode},execute:(e,i,o,t)=>{const n=e.condition,r=e.value,s=e.init,a=i.mode||"midi",c=i.initMode||"auto";At(n,a)&&(t.currentValue=r,t.initialized=!0);let u=t.currentValue;return t.initialized||(c==="auto"&&(u=r),t.initialized||(t.currentValue=c==="auto"?r:s,t.initialized=!0,u=t.currentValue)),{result:u}}});y({version:"1.0.0",...zt,inputs:{},displayName:"Latch",extendedInputs:{condition:{type:V,description:"Trigger"},value:{type:Z,description:"Value to Latch"},init:{type:Z,description:"Initial Value"}},extendedOutputs:{result:{type:Z,description:"Latched Value"}},ui:{inspector:{fields:[{type:"tab-bar",label:"Init Mode",path:"initMode",default:"auto",options:[{label:"Auto (Use Value)",value:"auto"},{label:"Manual",value:"manual"}]}]}}});var Gn=Object.freeze({__proto__:null,logic_latch:zt});const jt=ee({id:"logic.delay",metadata:{category:x.Logic,keywords:["delay","z-1","feedback","memory","prev"],description:"Outputs the value from the previous frame (z)."},config:{initMode:{kind:"atomic",type:"string",defaultValue:"auto"}},inputs:{value:Z,init:Z},outputs:{result:Z},autoBroadcast:!1,isRealtime:()=>!0,createState:()=>({storedValue:void 0,initialized:!1}),computeForwardPorts:(e,i,o)=>{const n=i.fields.initMode||"auto",r=(e.fields||e).value||Z;let s=(e.fields||e).init||Z;n==="auto"&&(s=r);const a=Ae([r,s]),c={value:r};return n==="manual"&&(c.init=s),{inputs:{kind:"record",fields:c},outputs:{kind:"record",fields:{result:a}}}},compileConfig:(e,i)=>({fields:{initMode:e.initMode||"auto"}}),shouldRecompileOnConfigChange:(e,i)=>{const o=e,t=i;return o.initMode!==t?.initMode},cycleBreakingPorts:["value"],execute:(e,i,o,t)=>{const n=e.init,r=i.initMode||"auto";let s;return t.initialized?s=t.storedValue:(r==="auto"?s=e.value:s=n,t.initialized=!0),e.value!==void 0&&(t.storedValue=e.value),{result:s}},consolidate:(e,i,o,t)=>{e.value!==void 0&&(t.storedValue=e.value),t.initialized=!0}});y({version:"1.0.0",...jt,inputs:{},displayName:"Delay",extendedInputs:{value:{type:Z,description:"Input Value"},init:{type:Z,description:"Initial Value"}},extendedOutputs:{result:{type:Z,description:"Delayed Value"}},ui:{inspector:{fields:[{type:"tab-bar",label:"Init Mode",path:"initMode",default:"auto",options:[{label:"Auto (Use Value)",value:"auto"},{label:"Manual",value:"manual"}]}]}}});var Hn=Object.freeze({__proto__:null,logic_delay:jt});const Un=[fn,mn,Sn,Tn,On,An,Rn,En,Dn,Pn,Ln,Fn,zn,jn,Bn,$n,Gn,Hn];Un.flatMap(e=>Object.values(e).filter(i=>typeof i=="object"&&i!==null&&"kind"in i&&i.kind==="primitive"));function Yn(e,i,o){const t={},n={},r={},s={},a=[],c={},u={},d={},b={};function p(h,w,M={},C=null,H=new Set,F=void 0,D=void 0){const U=new Map,Y=new Set;for(const v of Object.values(h.inner.nodes)){const B=o.getNodeType(v.config.typeId);if(B&&B.getChildren){const T=B.getChildren(v,h.inner.nodes);for(const P of T){if(U.has(P)){console.warn(`Node ${P} is owned by multiple parents! Keeping ${U.get(P)}, ignoring ${v.id}.`);continue}U.set(P,v.id)}T.length>0&&Y.add(v.id)}}for(const v of Object.values(h.inner.nodes)){if(U.has(v.id))continue;const B=w+v.id,T=o.getNodeType(v.config.typeId);if(T&&T.getChildren){const P=T.getChildren(v,h.inner.nodes);if(P.length>0){const ce={inner:{nodes:{},connections:{}}},j=new Set(P);P.forEach(A=>{ce.inner.nodes[A]=h.inner.nodes[A]}),Object.values(h.inner.connections).forEach(A=>{j.has(A.fromNodeId)&&j.has(A.toNodeId)&&(ce.inner.connections[A.id]=A)});const O=T?.definition?.subgraphExpansionTag;let $=F,ne=D;O&&O!=="inline"&&($=O,ne=B),p(ce,B+".",v.config.values||{},v.id,H,$,ne)}const z=T?.compileConfig?T.compileConfig(v.config):v.config;t[B]={definitionId:v.config.typeId,defaultConfig:z,executionOwnerId:D},n[B]=v.config}else if(T?.definition?.subgraphExpansionTag){const P=T.definition.subgraphExpansionTag,z=v.config.subgraphId;if(H.has(z)){console.error(`Cycle detected: Subgraph ${z} includes itself (stack: ${Array.from(H).join(" -> ")}). Skipping.`);continue}const ce=i.get(z);if(!ce){console.warn(`Subgraph ${z} not found for node ${v.id}`);continue}let j=F,O=D;P!=="inline"&&(j=P,O=B);const $=new Set(H);$.add(z),p(ce,B+".",v.config.values||{},v.id,$,j,O);const ne=T?.compileConfig?T.compileConfig(v.config):v.config;t[B]={definitionId:v.config.typeId,defaultConfig:ne,executionOwnerId:D},n[B]=v.config}else{const{typeId:P}=v.config,z=o.getNodeType(P),ce=z?.compileConfig?z.compileConfig(v.config):v.config,j={definitionId:P,defaultConfig:ce,executionTag:F,executionOwnerId:D},O=B;if(t[O]=j,n[O]=v.config,s[v.id]=O,w===""){if(v.config.typeId==="io.input"||v.config.typeId==="input"){const A=v.config.name||v.id;c[A]={nodeId:B,port:"value"}}else if(v.config.typeId==="io.output"||v.config.typeId==="output"){const A=v.config.name||v.id;u[A]={nodeId:B,port:"value"}}}if(w!==""&&(v.config.typeId==="io.input"||v.config.typeId==="input")){const A=Object.values(h.inner.nodes).filter(L=>L.config.typeId==="io.input"||L.config.typeId==="input").sort((L,W)=>L.y-W.y),ue=A.findIndex(L=>L.id===v.id);if(ue!==-1){const L=v.config.name||"value",W=fe(L,ue,A.length,"input"),de=M[W];j.defaultConfig||(j.defaultConfig={fields:{}}),de!==void 0&&(j.defaultConfig.values||(j.defaultConfig.values={}),j.defaultConfig.values[W]=de),j.defaultConfig.fields?j.defaultConfig.fields.name=W:j.defaultConfig.name=W,j.defaultConfig.values||(j.defaultConfig.values={}),Object.prototype.hasOwnProperty.call(j.defaultConfig.values,W)||(j.defaultConfig.values[W]=void 0),C&&(d[C]||(d[C]={}),d[C][W]=B)}}if(w!==""&&(v.config.typeId==="io.output"||v.config.typeId==="output")&&C){const A=Object.values(h.inner.nodes).filter(L=>L.config.typeId==="io.output"||L.config.typeId==="output").sort((L,W)=>L.y-W.y),ue=A.findIndex(L=>L.id===v.id);if(ue!==-1){const L=v.config.name||"value",W=fe(L,ue,A.length,"output");b[C]||(b[C]={}),b[C][W]=B}}let $=[];z&&(Array.isArray(z.inputs)?$=z.inputs:z.inputs&&z.inputs.kind==="record"&&($=Object.entries(z.inputs.fields||{}).map(([A,ue])=>({name:A,defaultValue:ue.defaultValue}))));const ne=new Set($.map(A=>A.name));v.config.values&&Object.keys(v.config.values).forEach(A=>ne.add(A));for(const A of ne)if(!Object.values(h.inner.connections).some(L=>L.toNodeId===v.id&&L.toPort===A)){let L=v.config.values?.[A];if(L===void 0){const W=$.find(de=>de.name===A);W&&W.defaultValue!==void 0?L=W.defaultValue:W&&W.type&&W.type.defaultValue!==void 0&&(L=W.type.defaultValue)}L!==void 0&&(j.defaultConfig||(j.defaultConfig={fields:{}}),j.defaultConfig.values||(j.defaultConfig.values={}),j.defaultConfig.values[A]=L)}}}for(const v of Object.values(h.inner.connections)){let B=w+v.fromNodeId;U.has(v.fromNodeId)&&(B=w+U.get(v.fromNodeId)+"."+v.fromNodeId);let T=B,P=v.fromPort;const z=h.inner.nodes[v.fromNodeId],j=(z?o.getNodeType(z.config.typeId):void 0)?.definition?.subgraphExpansionTag;if(z&&j){const le=z.config.subgraphId,ge=i.get(le);if(ge){const ve=Object.values(ge.inner.nodes).filter(re=>re.config.typeId==="io.output"||re.config.typeId==="output").sort((re,pe)=>re.y-pe.y),be=ve.find((re,pe)=>{const Ce=re.config.name||"value";return fe(Ce,pe,ve.length,"output")===P});be&&(T=B+"."+be.id,P="value")}}let O=w+v.toNodeId;U.has(v.toNodeId)&&(O=w+U.get(v.toNodeId)+"."+v.toNodeId);let $=O,ne=v.toPort;const A=h.inner.nodes[v.toNodeId],L=(A?o.getNodeType(A.config.typeId):void 0)?.definition?.subgraphExpansionTag;if(A&&L){const le=A.config.subgraphId,ge=i.get(le);if(ge){const ve=Object.values(ge.inner.nodes).filter(re=>re.config.typeId==="io.input"||re.config.typeId==="input").sort((re,pe)=>re.y-pe.y),be=ve.find((re,pe)=>{const Ce=re.config.name||"value";return fe(Ce,pe,ve.length,"input")===ne});be&&($=O+"."+be.id,ne=ne)}}let W=!0;z&&j&&j==="inline"&&T===B&&(W=!1);let de=!0;if(A&&L&&L==="inline"&&$===O&&(de=!1),W&&de){if(a.push({fromNode:T,fromPort:P,toNode:$,toPort:ne}),U.has(v.fromNodeId)){const le=w+U.get(v.fromNodeId);le!==$&&a.push({fromNode:le,fromPort:"___control___",toNode:$,toPort:"___control___"})}if(j&&j!=="inline"){const le=B;T!==le&&a.push({fromNode:le,fromPort:"___control___",toNode:$,toPort:"___control___"})}if(L&&L!=="inline"){const le=O;$!==le&&a.push({fromNode:T,fromPort:"___control___",toNode:le,toPort:"___control___"})}}}}p(e.graph,"");const f=new Map,m=new Map;Object.keys(t).forEach(h=>m.set(h,0)),a.forEach((h,w)=>{!t[h.fromNode]||!t[h.toNode]||(f.has(h.fromNode)||f.set(h.fromNode,[]),f.get(h.fromNode).push({toNode:h.toNode,connIndex:w}),m.set(h.toNode,(m.get(h.toNode)||0)+1))});const g=[],I=[],N=new Set;for(const[h,w]of m)w===0&&I.push(h);for(;g.length<Object.keys(t).length;){if(I.length===0){const h=Object.keys(t).filter(M=>!g.includes(M));let w=!1;for(const M of h){const C=t[M],H=o.get(C.definitionId);if(H&&H.kind==="primitive"&&H.cycleBreakingPorts&&H.cycleBreakingPorts.length>0){const F=new Set(H.cycleBreakingPorts);let D=0;a.forEach((U,Y)=>{U.toNode===M&&h.includes(U.fromNode)&&F.has(U.toPort.toString())&&(m.set(M,(m.get(M)||0)-1),N.add(Y),D++)}),D>0&&(w=!0,(m.get(M)||0)<=0&&I.push(M))}}if(!w&&h.length>0){let M=1/0,C=h[0];for(const H of h){const F=m.get(H)||0;F<M&&(M=F,C=H)}I.push(C)}if(I.length===0)break}if(I.length>0){const h=I.shift();if(g.push(h),f.has(h))for(const{toNode:w,connIndex:M}of f.get(h))N.add(M),m.set(w,(m.get(w)||0)-1),m.get(w)===0&&I.push(w)}}if(g.length!==Object.keys(t).length){console.warn("Graph contains cycles! Forced execution order.");for(const h of Object.keys(t))g.includes(h)||g.push(h)}const k=a.filter((h,w)=>N.has(w)).filter(h=>t[h.fromNode]&&t[h.toNode]),_=new Map,q=new Map,J=new Map;for(const h of g)q.set(h,{});const E={repository:o,broadcast:()=>{},loadedSubgraphs:i};for(let h=g.length-1;h>=0;h--){const w=g[h],M=t[w],C=o.get(M.definitionId);if(C&&C.kind==="primitive"){const H={kind:"record",fields:q.get(w)||{}},F=M.defaultConfig||{fields:{}};let D={kind:"record",fields:C.inputs?{...C.inputs}:{}};if(C.computeBackwardPorts)try{const Y=C.computeBackwardPorts(H,F,E);D={kind:"record",fields:{...D.fields,...Y.inputRequirements.fields}},Y.backwardMetadata&&J.set(w,Y.backwardMetadata)}catch(Y){console.warn(`Backward pass failed for ${w} (${C.id}):`,Y)}const U=k.filter(Y=>Y.toNode===w);for(const Y of U){const v=Y.fromNode,B=Y.fromPort.toString(),T=Y.toPort.toString();if(D.fields[T]){const P=q.get(v);P[B]=D.fields[T]}}}}for(const h of g){const w=t[h],M=o.get(w.definitionId);if(!M)continue;const C={},H=k.filter(T=>T.toNode===h),F=new Map;for(const T of H){if(!_.has(T.fromNode))continue;const P=_.get(T.fromNode)?.outputs;if(P&&P.kind==="record"){const z=T.fromPort.toString();P.fields[z]&&(F.has(T.toPort.toString())||F.set(T.toPort.toString(),[]),F.get(T.toPort.toString()).push(P.fields[z]))}}const D=M.inputs||{};for(const[T,P]of F){const z=D[T];z&&"kind"in z&&z.kind==="array"?P.length>0&&(C[T]={kind:"array",element:P[0],size:P.length}):P.length>0&&(C[T]=P[P.length-1])}const U={kind:"record",fields:C},Y=w.defaultConfig||{fields:{}};let v,B=U;try{if(M.kind==="primitive"&&M.computeForwardPorts){const T=M.computeForwardPorts(U,Y,E,J.get(h));B=T.inputs,v=T.outputs,T.forwardMetadata&&(r[h]=T.forwardMetadata)}else v=M.outputs&&M.outputs.kind==="record"?M.outputs:{kind:"record",fields:{}}}catch(T){console.warn(`Failed to compute output types for node ${h} (${M.id}):`,T),v={kind:"record",fields:{}}}_.set(h,{inputs:B,outputs:v})}for(const h of g){const w=t[h],M=o.get(w.definitionId),C=r[h];if(C&&M&&M.kind==="primitive"&&M.compileConfig){const H=n[h];if(H)try{const F=M.compileConfig(H,C),D=w.defaultConfig?.values;w.defaultConfig=F,D&&(w.defaultConfig.values||(w.defaultConfig.values={}),Object.assign(w.defaultConfig.values,D))}catch(F){console.warn(`Re-compilation failed for ${h} (${M.id}):`,F)}}}const S={};for(const[h,w]of _)S[h]=w;return{graph:{id:"compiled-graph",kind:"graph",type:{kind:"graph",inputs:{kind:"record",fields:{}},outputs:{kind:"record",fields:{}}},nodes:t,connections:k,inputs:c,outputs:u,executionOrder:g,virtualInputMappings:d},inferredTypes:S,virtualInputMappings:d,outputRemappings:b,nodeMetadata:r,idMap:s}}self.onerror=e=>{console.error("Compiler Worker Error (Global):",e)};self.onmessage=async e=>{const{type:i}=e.data;if(i==="COMPILE_GRAPH"){const{state:o,subgraphs:t}=e.data;try{const n=new Map(Object.entries(t)),r=new Set;o.graph&&o.graph.inner&&o.graph.inner.nodes&&Object.values(o.graph.inner.nodes).forEach(g=>r.add(g.config.typeId)),n.forEach(g=>{g.inner&&g.inner.nodes&&Object.values(g.inner.nodes).forEach(I=>r.add(I.config.typeId))});const s=new Set,a=[];for(const g of r){if(s.has(g))continue;s.add(g);const I=xe.getNodeType(g);I&&I.definition&&I.definition.loadCompileDeps&&a.push(I.definition.loadCompileDeps())}a.length>0&&await Promise.all(a);const{graph:c,inferredTypes:u,virtualInputMappings:d,outputRemappings:b,nodeMetadata:p,idMap:f}=Yn(o,n,xe),m={type:"GRAPH_COMPILED",graph:c,inferredTypes:u,virtualInputMappings:d,outputRemappings:b,nodeMetadata:p,idMap:f};self.postMessage(m)}catch(n){console.error("Compiler Worker Error:",n)}}else if(i==="COMPILE_CONFIGS")try{const{nodes:o}=e.data,t=new Set;o.forEach(a=>t.add(a.typeId));const n=[],r=new Set;for(const a of t){if(r.has(a))continue;r.add(a);const c=xe.getNodeType(a);c&&c.definition&&c.definition.loadCompileDeps&&n.push(c.definition.loadCompileDeps())}n.length>0&&await Promise.all(n);const s={};for(const a of o){const c=xe.getNodeType(a.typeId);c&&c.compileConfig?s[a.id]=c.compileConfig(a.config):s[a.id]=a.config}self.postMessage({type:"CONFIGS_COMPILED",configs:s})}catch(o){console.error("Compiler Worker Error (Multi Config):",o)}};
//# sourceMappingURL=compiler.worker-Bo2AcOGZ.js.map
