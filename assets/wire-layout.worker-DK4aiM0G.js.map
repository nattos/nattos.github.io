{"version":3,"file":"wire-layout.worker-DK4aiM0G.js","sources":["../src/utils/min-heap.ts","../src/layout/wire-layout.ts","../src/workers/wire-layout.worker.ts"],"sourcesContent":["\nexport interface HeapItem {\n  key: number; // Packed integer coordinate\n  fScore: number;\n}\n\nexport class MinHeap {\n  private items: HeapItem[] = [];\n\n  push(key: number, fScore: number) {\n    this.items.push({ key, fScore });\n    this.bubbleUp(this.items.length - 1);\n  }\n\n  pop(): HeapItem | undefined {\n    if (this.items.length === 0) return undefined;\n    const root = this.items[0];\n    const last = this.items.pop();\n    if (this.items.length > 0 && last) {\n      this.items[0] = last;\n      this.bubbleDown(0);\n    }\n    return root;\n  }\n\n  size(): number {\n    return this.items.length;\n  }\n\n  private bubbleUp(index: number) {\n    while (index > 0) {\n      const parentIndex = Math.floor((index - 1) / 2);\n      if (this.items[index].fScore >= this.items[parentIndex].fScore) break;\n      this.swap(index, parentIndex);\n      index = parentIndex;\n    }\n  }\n\n  private bubbleDown(index: number) {\n    const length = this.items.length;\n    const element = this.items[index];\n\n    while (true) {\n      let leftChildIndex = 2 * index + 1;\n      let rightChildIndex = 2 * index + 2;\n      let leftChild, rightChild;\n      let swap = null;\n\n      if (leftChildIndex < length) {\n        leftChild = this.items[leftChildIndex];\n        if (leftChild.fScore < element.fScore) {\n          swap = leftChildIndex;\n        }\n      }\n\n      if (rightChildIndex < length) {\n        rightChild = this.items[rightChildIndex];\n        if (\n          (swap === null && rightChild.fScore < element.fScore) ||\n          (swap !== null && rightChild.fScore < leftChild!.fScore)\n        ) {\n          swap = rightChildIndex;\n        }\n      }\n\n      if (swap === null) break;\n      this.swap(index, swap);\n      index = swap;\n    }\n  }\n\n  private swap(i: number, j: number) {\n    const temp = this.items[i];\n    this.items[i] = this.items[j];\n    this.items[j] = temp;\n  }\n}\n","import { MinHeap } from '../utils/min-heap';\n\n/**\n * Wire Layout Engine\n *\n * Computes wires on a Logical Grid using A* with Gap bias.\n */\n\nexport interface GridPoint {\n    x: number;\n    y: number;\n}\n\nexport interface WireDef {\n    id: string;\n    start: GridPoint; // Node coordinates (x,y)\n    end: GridPoint;   // Node coordinates (x,y)\n    fromPort: string;\n    toPort: string;\n    startOffset?: number; // Row offset from start node top\n    endOffset?: number;   // Row offset from end node top\n}\n\nexport enum SegmentType {\n    Horizontal = 'h',\n    Vertical = 'v',\n    CornerTL = 'ctl',\n    CornerTR = 'ctr',\n    CornerBL = 'cbl',\n    CornerBR = 'cbr',\n    Start = 'start', // Stub?\n    End = 'end'\n}\n\nexport interface WireSegment {\n    id: string;\n    wireId: string;\n    x: number;\n    y: number;\n    type: SegmentType;\n    lane?: number;\n    totalLanes?: number;\n    length?: number;\n    clipTopRem?: number; // If set, clip vertical top to this Rem's offset\n    clipBotRem?: number; // If set, clip vertical bot to this Rem's offset\n}\n\nexport interface LayoutResult {\n    segments: WireSegment[];\n    wires: Record<string, { path: GridPoint[] }>;\n}\n\n// Obstacle Map: \"x,y\" -> Set of Logical Lanes blocked?\n// Or simpler: We just block coordinate strings \"x,logicY\".\n// BUT to support \"Wormholes\", we need to know the 'Height' of each Node Column.\n// Map: `${x},${gridRow}` -> Height (number of used lanes 0..H-1).\ninterface Obstacle {\n    x: number;\n    y: number;\n    height?: number; // Logical height (1..32)\n}\n\ninterface InternalObstacle {\n    x: number;\n    y: number; // Logical Y\n}\n\nexport interface LayoutOptions {\n    obstacles?: Obstacle[];\n    algorithm?: 'astar' | 'greedy';\n    previousResult?: LayoutResult;\n}\n\nfunction pack(x: number, y: number): number {\n    return (x & 0xFFFF) | (y << 16);\n}\n\nfunction unpack(key: number): GridPoint {\n    return { x: key & 0xFFFF, y: key >>> 16 };\n}\n\nfunction getKey(p: GridPoint) { return `${p.x},${p.y}`; }\nfunction pointsEqual(a: GridPoint, b: GridPoint) { return a.x === b.x && a.y === b.y; }\n\nexport function computeWireLayout(wires: WireDef[], options: LayoutOptions = {}): LayoutResult {\n    const segments: WireSegment[] = [];\n    const wirePaths: Record<string, { path: GridPoint[] }> = {};\n\n    // 1. Build Obstacle Map (Logical Coordinates) using Packed Integers\n    const obstacles = new Set<number>();\n    const colHeightMap = new Map<string, number>();\n\n    // Config: Logical Scale\n    // X: Odd = Node, Even = Gap. (Base x*2+1).\n    // Y: 1 Logical Unit = 1 Grid Row (Possible Lanes).\n    // Increased to 32 to support high port count nodes.\n    const LOGICAL_Y_SCALE = 32;\n\n    for (const obs of (options.obstacles || [])) {\n        const lx = obs.x * 2 + 1;\n        const basePathY = obs.y * LOGICAL_Y_SCALE;\n\n        if (obs.height && obs.height > 1) {\n            // Register Column Height\n            colHeightMap.set(`${lx},${obs.y}`, obs.height);\n\n            const effectiveH = Math.min(obs.height, 31); // Don't block gap lane\n            for (let i = 0; i < effectiveH; i++) {\n                obstacles.add(pack(lx, basePathY + i));\n            }\n        } else {\n            // Default\n            colHeightMap.set(`${lx},${obs.y}`, 1);\n            obstacles.add(pack(lx, basePathY));\n        }\n    }\n\n    const toLogical = (p: GridPoint) => ({\n        // Logical Grid aligned with GraphGrid:\n        // Nodes are at Odd X (1, 3, 5).\n        // Gaps are at Even X (0, 2, 4, 6).\n        // Y: 1 Unit = 1 Row.\n        x: p.x * 2 + 1,\n        y: p.y * LOGICAL_Y_SCALE\n    });\n\n    const gridUsage = new Map<number, number>();\n\n    // 2. Route Wires\n    for (const wire of wires) {\n        // const startNode = toLogical(wire.start);\n        // const endNode = toLogical(wire.end);\n\n        const startP = { x: wire.start.x * 2 + 2, y: wire.start.y * LOGICAL_Y_SCALE + (wire.startOffset || 0) };\n        const endP = { x: wire.end.x * 2, y: wire.end.y * LOGICAL_Y_SCALE + (wire.endOffset || 0) };\n\n        let path: GridPoint[] = [];\n\n        // Simple case: Direct connection?\n        if (pointsEqual(startP, endP)) {\n            path = [startP];\n        } else {\n            // A* Search Optimized with MinHeap and Integer Keys\n            const openSet = new MinHeap();\n            const cameFrom = new Map<number, number>();\n            const gScore = new Map<number, number>();\n            // fScore is stored in the heap item\n\n            const startKey = pack(startP.x, startP.y);\n            const endKey = pack(endP.x, endP.y);\n\n            gScore.set(startKey, 0);\n\n            // Heuristic\n            const h = (ax: number, ay: number) => Math.abs(ax - endP.x) + Math.abs(ay - endP.y);\n\n            openSet.push(startKey, h(startP.x, startP.y));\n\n            const visited = new Set<number>();\n\n            // Safety Bounds\n            const searchMinY = -1;\n            const searchMaxY = Math.max(startP.y, endP.y) + 256; // Allow some slack but prevent infinity\n            let safetyCounter = 0;\n            const SAFETY_LIMIT = 50000; // Increased limit because heap is fast\n\n            while (openSet.size() > 0) {\n                safetyCounter++;\n                if (safetyCounter > SAFETY_LIMIT) {\n                    console.warn(`WireLayout: A* Safety Limit Reached (${SAFETY_LIMIT}) for wire ${wire.id}`);\n                    break;\n                }\n\n                const currentItem = openSet.pop();\n                if (!currentItem) break;\n                const currentKey = currentItem.key;\n\n                // If we found the goal\n                if (currentKey === endKey) {\n                    // Reconstruct\n                    let currKey = currentKey;\n                    path = [unpack(currKey)];\n                    while (cameFrom.has(currKey)) {\n                        currKey = cameFrom.get(currKey)!;\n                        path.unshift(unpack(currKey));\n                    }\n                    break;\n                }\n\n                // If already visited with a lower cost? Heap doesn't support update key easily,\n                // so we might pop duplicates.\n                if (visited.has(currentKey)) continue;\n                visited.add(currentKey);\n\n                const cP = unpack(currentKey);\n\n                // Neighbors\n                // Generate directly\n                const neighborsX = [cP.x + 1, cP.x - 1];\n                const neighborsY = [cP.y, cP.y];\n\n                // Vertical Steps: Only allow Vertical movement in GAP Columns (Even X).\n                if (cP.x % 2 === 0) {\n                    if (cP.y > searchMinY) { neighborsX.push(cP.x); neighborsY.push(cP.y - 1); }\n                    if (cP.y < searchMaxY) { neighborsX.push(cP.x); neighborsY.push(cP.y + 1); }\n                }\n\n                for (let i = 0; i < neighborsX.length; i++) {\n                    const nx = neighborsX[i];\n                    const ny = neighborsY[i];\n\n                    if (ny < searchMinY || ny > searchMaxY) continue; // Boundary Check\n\n                    const nKey = pack(nx, ny);\n                    if (visited.has(nKey)) continue;\n\n                    let cost = 1;\n                    const isEnd = (nKey === endKey);\n\n                    // Obstacle Check\n                    if (obstacles.has(nKey) && !isEnd) {\n                        continue; // Blocked\n                    }\n\n                    // Turn Penalty (Direction Change)\n                    const prevKey = cameFrom.get(currentKey);\n                    if (prevKey !== undefined) {\n                        const prevP = unpack(prevKey);\n                        if (prevP.x !== nx && prevP.y !== ny) {\n                            cost += 1;\n                            // Gap Turn Penalty: Turning in Gap Column (Even X)\n                            if (cP.x % 2 === 0) {\n                                cost += 20;\n                            }\n                        }\n                    }\n\n                    const tentativeG = (gScore.get(currentKey) || 0) + cost;\n\n                    if (tentativeG < (gScore.get(nKey) || Infinity)) {\n                        cameFrom.set(nKey, currentKey);\n                        gScore.set(nKey, tentativeG);\n                        const f = tentativeG + h(nx, ny);\n                        openSet.push(nKey, f);\n                    }\n                }\n            }\n        }\n\n        // Check if path found\n        if (path.length === 0) {\n            // Fallback\n            path = [startP, endP];\n        }\n\n        // Deduplication\n        if (path.length > 0) {\n            const dedup: GridPoint[] = [path[0]];\n            for (let i = 1; i < path.length; i++) {\n                const prev = dedup[dedup.length - 1];\n                const curr = path[i];\n                if (!pointsEqual(prev, curr)) {\n                    dedup.push(curr);\n                }\n            }\n            path = dedup;\n        }\n\n        wirePaths[wire.id] = { path };\n        for (const p of path) {\n            const k = pack(p.x, p.y);\n            gridUsage.set(k, (gridUsage.get(k) || 0) + 1);\n        }\n    }\n\n    // 3. Convert to Segments\n    const currentUsage = new Map<number, number>();\n    const GAP_LANE_INDEX = LOGICAL_Y_SCALE - 1;\n\n    for (const wire of wires) {\n        const path = wirePaths[wire.id].path;\n        if (!path || path.length === 0) continue;\n\n        // Add Start Stub\n        const startNode = toLogical(wire.start);\n        segments.push({\n            id: `${wire.id}-start`,\n            wireId: wire.id,\n            x: startNode.x,\n            y: startNode.y + (wire.startOffset || 0),\n            type: SegmentType.Start,\n            lane: 0,\n            totalLanes: 1,\n            length: 1\n        });\n\n        // Add End Stub\n        const endNode = toLogical(wire.end);\n        const endStubY = endNode.y + (wire.endOffset || 0);\n        segments.push({\n            id: `${wire.id}-end`,\n            wireId: wire.id,\n            x: endNode.x,\n            y: endStubY,\n            type: SegmentType.End,\n            lane: 0,\n            totalLanes: 1,\n            length: 1\n        });\n\n        for (let i = 0; i < path.length; i++) {\n            const p = path[i];\n            const k = pack(p.x, p.y); // Use packed key for usage map\n            const total = gridUsage.get(k) || 1;\n            const index = currentUsage.get(k) || 0;\n            currentUsage.set(k, index + 1);\n\n            // Determine Type\n            const prev = i > 0 ? path[i - 1] : null;\n            const next = i < path.length - 1 ? path[i + 1] : null;\n\n            let type = SegmentType.Horizontal;\n\n            if (prev && next) {\n                const dx1 = p.x - prev.x;\n                const dy1 = p.y - prev.y;\n                const dx2 = next.x - p.x;\n                const dy2 = next.y - p.y;\n\n                if (dx1 !== 0 && dx2 !== 0) type = SegmentType.Horizontal;\n                else if (dy1 !== 0 && dy2 !== 0) type = SegmentType.Vertical;\n                else {\n                    if (dx1 === 1 && dy2 > 0) type = SegmentType.CornerTR;\n                    else if (dx1 === 1 && dy2 < 0) type = SegmentType.CornerBR;\n                    else if (dx1 === -1 && dy2 > 0) type = SegmentType.CornerTL;\n                    else if (dx1 === -1 && dy2 < 0) type = SegmentType.CornerBL;\n                    else if (dy1 > 0 && dx2 === 1) type = SegmentType.CornerBL;\n                    else if (dy1 > 0 && dx2 === -1) type = SegmentType.CornerBR;\n                    else if (dy1 < 0 && dx2 === 1) type = SegmentType.CornerTL;\n                    else if (dy1 < 0 && dx2 === -1) type = SegmentType.CornerTR;\n                }\n            } else if (!prev) {\n                if (!next) {\n                    type = SegmentType.Horizontal;\n                } else {\n                    type = (next.x !== p.x) ? SegmentType.Horizontal : SegmentType.Vertical;\n                }\n                if (next) {\n                    if (next.y < p.y) type = SegmentType.CornerBR;\n                    else if (next.y > p.y) type = SegmentType.CornerTR;\n                }\n            } else if (!next) {\n                if (prev) {\n                    const isRight = endNode.x > p.x;\n                    if (prev.y < p.y) {\n                        type = isRight ? SegmentType.CornerBL : SegmentType.CornerBR;\n                    } else if (prev.y > p.y) {\n                        type = isRight ? SegmentType.CornerTL : SegmentType.CornerTR;\n                    } else {\n                        type = SegmentType.Horizontal;\n                    }\n                }\n            }\n\n            let clipTopRem = undefined;\n            let clipBotRem = undefined;\n\n            const gridY = Math.floor(p.y / LOGICAL_Y_SCALE);\n            const rem = p.y % LOGICAL_Y_SCALE;\n            const isNodeRow = rem < GAP_LANE_INDEX;\n\n            // Clipping Logic\n            if (isNodeRow) {\n                if (prev) {\n                    if (prev.x === p.x && prev.y < p.y) {\n                        const prevGridY = Math.floor(prev.y / LOGICAL_Y_SCALE);\n                        if (prevGridY === gridY) {\n                            if ((prev.y % LOGICAL_Y_SCALE) < GAP_LANE_INDEX) {\n                                clipTopRem = prev.y % LOGICAL_Y_SCALE;\n                            }\n                        } else if (prevGridY === gridY - 1) {\n                            if ((prev.y % LOGICAL_Y_SCALE) === GAP_LANE_INDEX) {\n                                clipTopRem = -1;\n                            }\n                        }\n                    }\n                }\n                if (next) {\n                    if (next.x === p.x && next.y > p.y) {\n                        const nextGridY = Math.floor(next.y / LOGICAL_Y_SCALE);\n                        if (nextGridY === gridY) {\n                            if ((next.y % LOGICAL_Y_SCALE) < GAP_LANE_INDEX) {\n                                clipBotRem = next.y % LOGICAL_Y_SCALE;\n                            } else if ((next.y % LOGICAL_Y_SCALE) === GAP_LANE_INDEX) {\n                                clipBotRem = GAP_LANE_INDEX;\n                            }\n                        }\n                    }\n                }\n\n                // Reverse Checks\n                if (prev) {\n                    if (prev.x === p.x && prev.y > p.y) {\n                        const prevGridY = Math.floor(prev.y / LOGICAL_Y_SCALE);\n                        if (prevGridY === gridY) {\n                            if ((prev.y % LOGICAL_Y_SCALE) < GAP_LANE_INDEX) {\n                                clipBotRem = prev.y % LOGICAL_Y_SCALE;\n                            } else if ((prev.y % LOGICAL_Y_SCALE) === GAP_LANE_INDEX) {\n                                clipBotRem = GAP_LANE_INDEX;\n                            }\n                        }\n                    }\n                }\n                if (next) {\n                    if (next.x === p.x && next.y < p.y) {\n                        const nextGridY = Math.floor(next.y / LOGICAL_Y_SCALE);\n                        if (nextGridY === gridY) {\n                            if ((next.y % LOGICAL_Y_SCALE) < GAP_LANE_INDEX) {\n                                clipTopRem = next.y % LOGICAL_Y_SCALE;\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (prev && prev.x === p.x && prev.y < p.y) {\n                    clipTopRem = -1;\n                }\n            }\n\n            segments.push({\n                id: `${wire.id}-${i}`,\n                wireId: wire.id,\n                x: p.x,\n                y: p.y,\n                type,\n                lane: index + 1,\n                totalLanes: total, // Still useful for visualization/debug\n                length: 1,\n                clipTopRem,\n                clipBotRem\n            });\n        }\n    }\n\n    // 4. Post-Process Coalescing\n    const coalescedSegments: WireSegment[] = [];\n    const slotMap = new Map<string, WireSegment[]>();\n\n    for (const seg of segments) {\n        const logicalSlot = Math.floor(seg.y / LOGICAL_Y_SCALE);\n        const rem = seg.y % LOGICAL_Y_SCALE;\n\n        let gridRowKey = '';\n        if (rem < GAP_LANE_INDEX) {\n            gridRowKey = `${seg.wireId}:${seg.x}:${logicalSlot}:node`;\n        } else {\n            gridRowKey = `${seg.wireId}:${seg.x}:${logicalSlot}:gap`;\n        }\n\n        if (!slotMap.has(gridRowKey)) slotMap.set(gridRowKey, []);\n        slotMap.get(gridRowKey)!.push(seg);\n    }\n\n    // Process buckets\n    for (const [key, bucket] of slotMap.entries()) {\n        const hasCorner = bucket.some(s => s.type !== SegmentType.Horizontal && s.type !== SegmentType.Vertical && s.type !== SegmentType.Start && s.type !== SegmentType.End);\n\n        const extendsHigher = (aRem: number | undefined, bRem: number | undefined) => {\n            if (aRem === undefined && bRem !== undefined) return true;\n            if (aRem !== undefined && bRem !== undefined && aRem < bRem) return true;\n            return false;\n        };\n\n        const extendsLower = (aRem: number | undefined, bRem: number | undefined) => {\n            if (aRem === undefined && bRem !== undefined) return true;\n            if (aRem !== undefined && bRem !== undefined && aRem > bRem) return true;\n            return false;\n        };\n\n        if (hasCorner) {\n            const verticals = bucket.filter(s => s.type === SegmentType.Vertical);\n            const corners = bucket.filter(s => s.type !== SegmentType.Vertical && s.type !== SegmentType.Horizontal && s.type !== SegmentType.Start && s.type !== SegmentType.End);\n\n            for (const c of corners) {\n                if (c.type === SegmentType.CornerBL || c.type === SegmentType.CornerBR) {\n                    for (const v of verticals) {\n                        if (extendsHigher(v.clipTopRem, c.clipTopRem)) {\n                            c.clipTopRem = v.clipTopRem;\n                        }\n                    }\n                } else if (c.type === SegmentType.CornerTL || c.type === SegmentType.CornerTR) {\n                    for (const v of verticals) {\n                        if (extendsLower(v.clipBotRem, c.clipBotRem)) {\n                            c.clipBotRem = v.clipBotRem;\n                        }\n                    }\n                }\n            }\n\n            for (const s of bucket) {\n                if (s.type !== SegmentType.Vertical) {\n                    coalescedSegments.push(s);\n                }\n            }\n        } else {\n            const verticals = bucket.filter(s => s.type === SegmentType.Vertical);\n            const others = bucket.filter(s => s.type !== SegmentType.Vertical);\n\n            if (verticals.length > 0) {\n                let merged = { ...verticals[0] };\n                for (let i = 1; i < verticals.length; i++) {\n                    const v = verticals[i];\n                    if (extendsHigher(v.clipTopRem, merged.clipTopRem)) {\n                        merged.clipTopRem = v.clipTopRem;\n                    }\n                    if (extendsLower(v.clipBotRem, merged.clipBotRem)) {\n                        merged.clipBotRem = v.clipBotRem;\n                    }\n                }\n                coalescedSegments.push(merged);\n            }\n            coalescedSegments.push(...others);\n        }\n    }\n\n    return {\n        segments: coalescedSegments,\n        wires: wirePaths\n    };\n}\n","\nimport { computeWireLayout } from '../layout/wire-layout';\nimport { WiringWorkerMessage, WiringMainMessage } from './types';\n\nconst ctx: Worker = self as any;\n\nctx.onmessage = (event: MessageEvent<WiringWorkerMessage>) => {\n  const { type, wires, options } = event.data;\n\n  if (type === 'LAYOUT_REQUEST') {\n    const layout = computeWireLayout(wires, options);\n\n    const response: WiringMainMessage = {\n      type: 'LAYOUT_RESULT',\n      layout\n    };\n\n    ctx.postMessage(response);\n  }\n};\n"],"names":["MinHeap","key","fScore","root","last","index","parentIndex","length","element","leftChildIndex","rightChildIndex","leftChild","rightChild","swap","i","j","temp","pack","x","y","unpack","pointsEqual","a","b","computeWireLayout","wires","options","segments","wirePaths","obstacles","colHeightMap","LOGICAL_Y_SCALE","obs","lx","basePathY","effectiveH","toLogical","p","gridUsage","wire","startP","endP","path","openSet","cameFrom","gScore","startKey","endKey","h","ax","ay","visited","searchMinY","searchMaxY","safetyCounter","SAFETY_LIMIT","currentItem","currentKey","currKey","cP","neighborsX","neighborsY","nx","ny","nKey","cost","isEnd","prevKey","prevP","tentativeG","f","dedup","prev","curr","k","currentUsage","GAP_LANE_INDEX","startNode","endNode","endStubY","total","next","type","dx1","dy1","dx2","dy2","isRight","clipTopRem","clipBotRem","gridY","prevGridY","coalescedSegments","slotMap","seg","logicalSlot","rem","gridRowKey","bucket","hasCorner","extendsHigher","aRem","bRem","extendsLower","verticals","s","corners","c","v","others","merged","ctx","event","response"],"mappings":"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"}