{"version":3,"file":"wgsl-DoyEEMrN.js","sources":["../../src/customnodes/expr/v2/backend-test-cases.ts","../../src/customnodes/expr/v2/wgsl-utils.ts","../../src/views/wgsl-tester.ts"],"sourcesContent":["import { DataType, DataTypeKind, PrimitiveType } from './ir-types';\n\nexport interface TestCase {\n  name: string;\n  code: string;\n  inputValues?: Record<string, any>;\n  inputTypes?: Record<string, DataType>; // Optional: if not provided, inferred from values\n  outputType?: DataType; // Optional: inferred from expected if simple, else required for C++\n  expected?: any;\n  check?: (res: any, debug?: any) => void;\n  // Metadata to skip specific backends if feature missing\n  skipCPP?: boolean;\n  skipJS?: boolean;\n  skipWGSL?: boolean; // New\n  debug?: boolean;\n}\n\nconst NUMBER_TYPE: PrimitiveType = { kind: DataTypeKind.Primitive, name: 'number' };\nconst BOOL_TYPE: PrimitiveType = { kind: DataTypeKind.Primitive, name: 'boolean' };\n\nexport const testCases: TestCase[] = [\n  // --- Basics ---\n  {\n    name: 'Basic Math (Return 42)',\n    code: 'return 40 + 2;',\n    expected: 42\n  },\n  {\n    name: 'Logic Ops (&& ||)',\n    code: 'return (true && false) || true;',\n\n    check: (res: any) => {\n      if (typeof res === 'boolean' && res === true) return;\n      if (typeof res === 'number' && Math.abs(res - 1) < 0.001) return;\n      throw new Error(`Expected true or 1, got ${res}`);\n    }\n  },\n  {\n    name: 'Unary Ops (- !)',\n    code: 'return -42;',\n    expected: -42\n  },\n  {\n    name: 'Unary Ops (- !)',\n    code: 'return -42;',\n    expected: -42\n  },\n  {\n    name: 'Mixed Logic Ops',\n    code: 'return (true && false) || true || 1.0;',\n    expected: 1,\n    outputType: NUMBER_TYPE // Force numeric return (will cast bool to 1)\n  },\n  {\n    name: 'Variables (Input)',\n\n    code: 'var x: number; return x * 2;',\n    inputValues: { x: 21 },\n    expected: 42\n  },\n  {\n    name: 'Typed Inputs (Var Decl)',\n    code: `\n      var x: number;\n      var y: number;\n      return x + y;\n    `,\n    inputValues: { x: 10, y: 32 },\n    expected: 42\n  },\n  {\n    name: 'If Statement (Branching)',\n    code: `\n      var x: number;\n      if (x > 10) {\n        return 1;\n      } else {\n        return 0;\n      }\n    `,\n    inputValues: { x: 11 },\n    expected: 1\n  },\n  {\n    name: 'Loops (While)',\n    code: `\n       let i = 0;\n       while (i < 5) {\n         i = i + 1;\n       }\n       return i;\n    `,\n    expected: 5\n  },\n\n  // --- Arrays ---\n  {\n    name: 'Array Push & Access',\n    code: `\n        let arr = [1, 2, 3];\n        arr.push(4);\n        return arr[3];\n    `,\n    outputType: NUMBER_TYPE, // Explicit return type needed for C++? Inferred from code? C++ needs explicit output type in generateCPP.\n    // If not provided here, harness must infer \"number\" from expected \"4\".\n    expected: 4,\n    skipWGSL: true // Dynamic array push not supported\n  },\n  {\n    name: 'Array Convolution (Loops + Access)',\n    code: `\n       var signal: number[];\n       const kernel = [0.5, 1];\n       const result: number[] = [];\n       // signal is input array of size 5\n       for (let i = 0; i < 4; i++) {\n          let sum = 0;\n          for (let j = 0; j < 2; j++) {\n             sum = sum + signal[i+j] * kernel[j];\n          }\n          result.push(sum);\n       }\n       return result;\n    `,\n    inputValues: { signal: [1, 2, 3, 4, 5] },\n    outputType: { kind: DataTypeKind.Array, elementType: NUMBER_TYPE },\n    expected: [2.5, 4.0, 5.5, 7.0],\n    skipWGSL: true // Dynamic array push not supported\n  },\n\n  // --- Structs & Reference Semantics ---\n  {\n    name: 'Struct Literal & Access',\n    code: `\n        const s = { x: 10, y: 20 };\n        return s.x + s.y;\n    `,\n    expected: 30\n  },\n  {\n    name: 'Reference Sharing (Mutable Alias)',\n    code: `\n        let p1 = { x: 1, y: 1 };\n        let p2 = p1; // Alias (Ref)\n        p2.x = 10;\n        return p1.x; // Becomes 10\n    `,\n    expected: 10,\n    skipWGSL: false // Reference semantics\n  },\n  {\n    name: 'Nested Struct Mutation',\n    code: `\n         let a = { p: { x: 1 } };\n         let b = a;\n         b.p.x = 10;\n         return a.p.x;\n    `,\n    expected: 10,\n    skipWGSL: false // Reference semantics\n  },\n  {\n    name: 'Array Reference Sharing',\n    code: `\n        let a = [1, 2];\n        let b = a;\n        b[0] = 10;\n        return a[0];\n    `,\n    expected: 10,\n    skipWGSL: false // Reference semantics\n  },\n  {\n    name: 'Struct Reference Assignment (Alias)',\n    code: `\n        // interface S { x: number; }\n        let s = { x: 0 };\n        let r = s; // Alias r -> s\n        r.x = 10;\n        return s.x; // Should be 10 if aliased\n    `,\n    expected: 10,\n    skipWGSL: false // Reference semantics\n  },\n  {\n    name: 'Nested Array Element Alias',\n    code: `\n        // interface Vec2 { x: number; y: number; }\n        // Mutable array of structs\n        let arr = [{x:0, y:0}, {x:10, y:10}];\n\n        for (let i = 0; i < 2; i++) {\n            let v = arr[i]; // Alias v -> arr[i] (Reference)\n            // If v is a copy, this won't affect arr.\n            // If v is reference, it will.\n            v.x = v.x + 100;\n        }\n        return arr[0].x; // Should be 100\n    `,\n    expected: 100,\n    skipWGSL: false // Reference semantics\n  },\n  {\n    name: 'Reference Passing to Function',\n    code: `\n        // interface S { x: number; }\n        function modify(p: { x: number }) {\n            p.x = p.x + 20;\n        }\n\n        let s = { x: 10 };\n        modify(s); // Should pass 's' by reference (inline or ptr)\n        return s.x;\n    `,\n    expected: 30,\n    skipWGSL: false // Reference semantics\n  },\n\n  // --- Math Intrinsics ---\n  {\n    name: 'Math Intrinsics (min/pow)',\n    code: `\n         let val = 2;\n         val = Math.pow(val, 3); // 8\n         return Math.min(val, 5); // 5\n    `,\n    expected: 5\n  },\n\n  // --- Optional / Union Types (Advanced) ---\n  {\n    name: 'Optional Input Field',\n    code: `\n      interface InputStruct {\n        x: number;\n        y?: number;\n      }\n      var input: InputStruct;\n      return input.y;\n    `,\n    inputValues: { input: { x: 1, y: 100 } },\n    // inputTypes inferred from var declaration\n    check: (res: any) => {\n      // expect(res).toBe(100);\n    },\n    skipCPP: true, // Need to fix InputStruct definition in harness to match C++ requirements perfectly?\n    skipJS: false,\n    skipWGSL: true // Union Types not supported\n  }\n];\n\n// Fixups for complex types in test data\n\n\n// Re-define the last case correctly\ntestCases[testCases.length - 1] = {\n  name: 'Optional Input Field (Present)',\n  code: `\n    interface InputStruct {\n      x: number;\n      y?: number;\n    }\n    var input: InputStruct;\n    return input.y;\n  `,\n  inputValues: { input: { x: 1, y: 100 } },\n  // inputTypes inferred\n  outputType: { kind: DataTypeKind.Union, types: [NUMBER_TYPE, { kind: DataTypeKind.Primitive, name: 'undefined' }] }, // Output is optional\n  // Note: C++ returns 0 or value? Or std::optional?\n  // C++ backend test expected 100 or null.\n  expected: 100,\n  skipCPP: false,\n  skipWGSL: true // Union Types not supported\n};\n\ntestCases.push({\n  name: 'Optional Input Field (Missing)',\n  code: `\n    interface InputStruct {\n      x: number;\n      y?: number;\n    }\n    var input: InputStruct;\n    return input.y;\n  `,\n  inputValues: { input: { x: 1 } },\n  // inputTypes inferred\n  outputType: { kind: DataTypeKind.Union, types: [NUMBER_TYPE, { kind: DataTypeKind.Primitive, name: 'undefined' }] },\n  check: (res: any) => {\n    // JS returns undefined, C++ returns null (JSON)\n    if (res !== null && res !== undefined) throw new Error(`Expected null/undefined, got ${res}`);\n  },\n  skipCPP: false,\n  skipWGSL: true // Union Types not supported\n});\n\ntestCases.push({\n  name: 'Dynamic Function Dispatch (Inlining)',\n  code: `\n      const add = (a: number) => a + 10;\n      const mul = (a: number) => a * 10;\n      const mul2 = (a: number) => a * 10;\n      // input.mode is struct field\n      var input: { mode: number; }; // Inline struct type\n      let f = add;\n      if (input.mode > 0) {\n          f = mul;\n      }\n      return f(5);\n    `,\n  inputValues: { input: { mode: 1 } },\n  // inputTypes removed\n  expected: 50,\n  skipWGSL: true // Functional dispatch/inlining issues\n});\n\ntestCases.push({\n  name: 'Debug Logging',\n  code: `\n        var x: number;\n        let y = x * 2;\n        y = y + 1;\n        return y;\n    `,\n  inputValues: { x: 10 },\n  debug: true,\n  expected: 21,\n  check: (res: any, debug: any) => {\n    // expect debug to contain entries\n    if (!debug) throw new Error(\"Debug log missing\");\n    const keys = Object.keys(debug || {});\n    if (keys.length === 0) throw new Error(\"Debug log empty\");\n    // Check for specific lines values if possible?\n    // JS keys are line numbers (string).\n  },\n  skipWGSL: true // record_debug intrinsic not available\n});\n\n// --- Simulations ---\n\nconst BALL_TYPE: DataType = {\n  kind: DataTypeKind.Struct,\n  name: 'Ball',\n  fields: {\n    x: NUMBER_TYPE, y: NUMBER_TYPE,\n    vx: NUMBER_TYPE, vy: NUMBER_TYPE\n  }\n};\n\nconst BALLS_INPUT_TYPE: DataType = { kind: DataTypeKind.Array, elementType: BALL_TYPE, length: 2 };\n\ntestCases.push({\n  name: 'Bouncing Balls Simulation (1 Tick)',\n  code: `\n        var dt: number;\n        interface Ball { x: number; y: number; vx: number; vy: number; }\n        var balls: Ball[];\n\nconst width = 100.0;\nconst result = balls; // Modify in place (reference) or copy?\n// In JS/C++ backend, 'balls' is a reference to the array.\n// But we iterate and modify objects inside it.\n\nfor (let i = 0; i < balls.length; i++) {\n  let b = balls[i];\n\n  // Physics Update\n  b.x = b.x + b.vx * dt;\n  b.y = b.y + b.vy * dt;\n\n  // Bounce X\n  if (b.x > width) {\n    b.x = width;\n    b.vx = -b.vx;\n  } else if (b.x < 0) {\n    b.x = 0;\n    b.vx = -b.vx;\n  }\n\n  // Bounce Y (Floor at 0 for simplicity or ceiling?)\n  if (b.y < 0) {\n    b.y = 0;\n    b.vy = -b.vy;\n  }\n}\nreturn balls;\n`,\n  inputValues: {\n    dt: 0.1,\n    balls: [\n      { x: 10, y: 10, vx: 50, vy: 0 },\n      { x: 99, y: 10, vx: 50, vy: 0 }\n    ]\n  },\n  // Inferred from vars\n  outputType: BALLS_INPUT_TYPE,\n  debug: true,\n  check: (res: any, debug: any) => {\n    // Expect array of 2 balls\n    if (!Array.isArray(res) || res.length !== 2) throw new Error(\"Expected 2 balls\");\n\n    const b0 = res[0];\n    const b1 = res[1];\n\n    // b0: 10 + 50*0.1 = 15\n    if (Math.abs(b0.x - 15) > 0.1) throw new Error(`b0.x expected ~15, got ${b0.x}.Debug: ${JSON.stringify(debug)} `);\n\n    // b1: 99 + 5 = 104 -> Clamped to 100. vx flipped to -50.\n    if (Math.abs(b1.x - 100) > 0.1) throw new Error(`b1.x expected ~100, got ${b1.x} `);\n    if (Math.abs(b1.vx - -50) > 0.1) throw new Error(`b1.vx expected - 50, got ${b1.vx} `);\n  }\n});\n// Need to skipWGSL for balls because of Reference Mutation in loop?\n// Actually 'b.x = ...' where b = balls[i].\n// Ref Safety should catch this?\n// Yes, likely WGSL will copy.\ntestCases[testCases.length - 1].skipWGSL = false;\n\n// --- Stress Tests ---\n\ntestCases.push({\n  name: 'Matrix Multiplication (2x2)',\n  code: `\nconst A = [[1, 2], [3, 4]];\nconst B = [[5, 6], [7, 8]];\n// Result C = A * B\n// C[0][0] = 1*5 + 2*7 = 5 + 14 = 19\n// C[0][1] = 1*6 + 2*8 = 6 + 16 = 22\n// C[1][0] = 3*5 + 4*7 = 15 + 28 = 43\n// C[1][1] = 3*6 + 4*8 = 18 + 32 = 50\n\nlet result = [0, 0, 0, 0];\nlet idx = 0;\nfor (let i = 0; i < 2; i++) {\n  for (let j = 0; j < 2; j++) {\n    let sum = 0;\n    for (let k = 0; k < 2; k++) {\n      sum = sum + A[i][k] * B[k][j];\n    }\n    result[idx] = sum;\n    idx = idx + 1;\n  }\n}\nreturn result;\n`,\n  outputType: { kind: DataTypeKind.Array, elementType: NUMBER_TYPE, length: 4 },\n  expected: [19, 22, 43, 50],\n  skipWGSL: false // Dynamic array push (Wait, code uses push. Needs fix?)\n});\n\ntestCases.push({\n  name: 'Chained Generics (Structural)',\n  code: `\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nfunction box<U>(val: U) {\n  return { contents: identity(val) };\n}\n\nfunction process<X>(item: X) {\n  return box(item);\n}\n\nreturn process([1, 2]);\n`,\n  // Output: { contents: [1, 2] }\n  // Struct definition for output?\n  // Inferring generic return type in C++ test harness is hard without explicit outputType.\n  // The output is Box<Array<number>>.\n  // We need to construct the DataType manually for C++ codegen to know what to wrap the result in?\n  // actually verify_cpp_runner logic handles some inference or we need explicit.\n  // CodeGen needs outputType to generate the 'result' var declaration in C++.\n  // Let's define it.\n  outputType: {\n    kind: DataTypeKind.Struct,\n    fields: {\n      contents: { kind: DataTypeKind.Array, elementType: NUMBER_TYPE }\n    }\n  },\n  expected: { contents: [1, 2] },\n  skipCPP: true,\n  skipWGSL: true\n});\n\n// --- Ray Tracer ---\n\nconst VEC3_TYPE: DataType = {\n  kind: DataTypeKind.Struct,\n  name: 'Vec3',\n  fields: { x: NUMBER_TYPE, y: NUMBER_TYPE, z: NUMBER_TYPE }\n};\n\nconst RT_INPUT_TYPE: DataType = {\n  kind: DataTypeKind.Struct,\n  name: 'RtInput',\n  fields: { u: NUMBER_TYPE, v: NUMBER_TYPE }\n};\n\ntestCases.push({\n  name: 'Ray Tracer (Sphere Diffuse)',\n  code: `\n        // --- Structs ---\n        interface RtInput { u: number; v: number; }\n        var input: RtInput;\n\n        interface Vec3 {\n  x: number;\n  y: number;\n  z: number;\n}\n\ninterface Sphere {\n  center: Vec3;\n  radius: number;\n  color: Vec3; // RGB\n}\n\ninterface Ray {\n  origin: Vec3;\n  dir: Vec3;\n}\n\n// --- Helpers ---\n// Basic Math\nconst dot = (a: Vec3, b: Vec3) => a.x * b.x + a.y * b.y + a.z * b.z;\n\nconst sub = (a: Vec3, b: Vec3): Vec3 => {\n  return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };\n};\n\nconst add = (a: Vec3, b: Vec3): Vec3 => {\n  return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };\n};\n\nconst mul = (a: Vec3, s: number): Vec3 => {\n  return { x: a.x * s, y: a.y * s, z: a.z * s };\n};\n\nconst length = (v: Vec3) => Math.sqrt(dot(v, v));\n\nconst normalize = (v: Vec3): Vec3 => {\n  const l = length(v);\n  return { x: v.x / l, y: v.y / l, z: v.z / l };\n};\n\n// --- Scene ---\nconst sphere = {\n  center: { x: 0, y: 0, z: -5 },\n  radius: 1,\n  color: { x: 1, y: 0, z: 0 } // Red\n};\n\n// Light direction (approx directional light)\nconst lightDir = normalize({ x: 1, y: 1, z: 1 });\n\n// --- Intersection ---\nconst intersectSphere = (ray: { origin: Vec3, dir: Vec3 }, sph: { center: Vec3, radius: number }) => {\n  const oc = sub(ray.origin, sph.center);\n  const a = dot(ray.dir, ray.dir);\n  const b = 2.0 * dot(oc, ray.dir);\n  const c = dot(oc, oc) - sph.radius * sph.radius;\n  const discriminant = b * b - 4 * a * c;\n\n  if (discriminant < 0) return -1.0;\n  return (-b - Math.sqrt(discriminant)) / (2.0 * a);\n};\n\n// --- Rendering ---\n// Input: input.u, input.v\n\n// Camera setup\nconst origin = { x: 0, y: 0, z: 0 };\nconst lowerLeft = { x: -2, y: -1, z: -1 };\nconst horizontal = { x: 4, y: 0, z: 0 };\nconst vertical = { x: 0, y: 2, z: 0 };\n\nconst ray_target = add(lowerLeft, add(mul(horizontal, input.u), mul(vertical, input.v)));\nconst direction = normalize(sub(ray_target, origin));\nconst ray = { origin: origin, dir: direction };\n\n// Trace\nconst t = intersectSphere(ray, sphere);\n\nif (t > 0) {\n  // Hit!\n  // Calculate normal\n  const hitPos = add(ray.origin, mul(ray.dir, t));\n  const normal = normalize(sub(hitPos, sphere.center));\n\n  // Diffuse shading\n  let diff = Math.max(dot(normal, lightDir), 0);\n\n  // Ambient\n  diff = diff + 0.1;\n\n  return mul(sphere.color, diff);\n}\n\n// Sky color (Gradient)\nconst t2 = 0.5 * (direction.y + 1.0);\n// (1-t)*white + t*blue\nconst white: Vec3 = { x: 1, y: 1, z: 1 };\nconst blue: Vec3 = { x: 0.5, y: 0.7, z: 1.0 };\nreturn add(mul(white, 1.0 - t2), mul(blue, t2));\n    `,\n  inputValues: { input: { u: 0.5, v: 0.5 } },\n  // inputTypes removed\n  outputType: VEC3_TYPE,\n  check: (res: any) => {\n    // Center hit -> Reddish\n    if (res.x < 0.1) throw new Error(`Expected red component > 0.1 for center hit, got ${JSON.stringify(res)} `);\n  },\n  skipCPP: true\n});\n\ntestCases.push({\n  name: 'Ray Tracer (Sky Background)',\n  code: testCases[testCases.length - 1].code, // Reuse code\n  inputValues: { input: { u: 0, v: 0 } },\n  // inputTypes removed (inferred from Sphere Diffuse code)\n  outputType: VEC3_TYPE,\n  check: (res: any) => {\n    // Corner -> Blueish Sky\n    if (res.z < 0.5) throw new Error(`Expected blue component > 0.5 for sky hit, got ${JSON.stringify(res)} `);\n  },\n  skipCPP: true\n});\n\n// --- Callbacks & Lambdas ---\n\ntestCases.push({\n  name: 'Mixed Struct Callbacks (Compile & Run)',\n  code: `\n// Helper function expecting a dictionary of callbacks and values\nfunction process(opts: { onStart: () => number, val: number }) {\n  const x = opts.onStart(); // Call lambda\n  return x + opts.val;      // Use dynamic val\n}\n\n// Usage\nconst cb = () => 42;\n// Mixed struct: 'onStart' is Const (Lambda), 'val' is Dynamic (Input)\n// dynamic_input global/input\nvar dynamic_input: number;\nconst result = process({ onStart: cb, val: dynamic_input });\nreturn result;\n`,\n  inputValues: { dynamic_input: 10 },\n  expected: 52,\n  skipWGSL: true // Lambda struct fields\n});\n\ntestCases.push({\n  name: 'Inline Object Literal Arguments',\n  code: `\nfunction run(ops: { f: (x: number) => number }) {\n  return ops.f(10);\n}\nconst res = run({ f: (x) => x * 2 });\nreturn res;\n`,\n  expected: 20,\n  skipCPP: true,\n  skipWGSL: true\n});\n\n// --- Mutation & Inlining ---\n\ntestCases.push({\n  name: 'Array Mutation',\n  code: `\nlet arr = [1, 2, 3];\narr[0] = 10;\nreturn arr[0];\n`,\n  expected: 10,\n  skipWGSL: false // Mutation of array ref\n});\n\ntestCases.push({\n  name: 'Struct Mutation',\n  code: `\nlet p = { x: 1, y: 2 };\np.x = 100;\nreturn p.x + p.y;\n`,\n  expected: 102,\n  skipWGSL: false // Mutation of struct ref\n});\n\ntestCases.push({\n  name: 'Nested Properties Mutation',\n  code: `\nlet arr = [{ x: 1 }, { x: 2 }];\narr[0].x = 50;\nreturn arr[0].x + arr[1].x;\n`,\n  expected: 52,\n  skipWGSL: false // Mutation of nested ref\n});\n\ntestCases.push({\n  name: 'Compound Assignment',\n  code: `\nlet p = { val: 10 };\np.val += 5;\nreturn p.val;\n`,\n  expected: 15,\n  skipWGSL: false // Compound assign to ref\n});\n\ntestCases.push({\n  name: 'Helper Function Inlining',\n  code: `\nfunction add(a, b) { return a + b; }\nreturn add(10, 20);\n`,\n  expected: 30,\n  skipWGSL: true // Helper function emission issues\n});\n\n// --- Stress Tests ---\n\ntestCases.push({\n  name: 'Mandelbrot Iteration (Structs, Loops, Break)',\n  code: `\ninterface Complex { r: number; i: number; }\n\nvar cx: number;\nvar cy: number;\nvar maxIter: number;\n\nlet c = { r: cx, i: cy };\nlet z = { r: 0.0, i: 0.0 };\nlet iter = 0;\n\nwhile (iter < maxIter) {\n  let r2 = z.r * z.r;\n  let i2 = z.i * z.i;\n\n  if (r2 + i2 > 4.0) {\n    break;\n  }\n\n  let next_r = r2 - i2 + c.r;\n  let next_i = 2.0 * z.r * z.i + c.i;\n\n  // Assign new struct\n  z = { r: next_r, i: next_i };\n  iter++;\n}\n\nreturn iter;\n`,\n  inputValues: { cx: 0, cy: 0, maxIter: 100 },\n  expected: 100\n});\n\ntestCases.push({\n  name: 'Mandelbrot Divergence',\n  code: testCases[testCases.length - 1].code,\n  inputValues: { cx: 2, cy: 2, maxIter: 100 },\n  expected: 1\n});\n","import { DataType, DataTypeKind, StructType, PrimitiveType, ArrayType } from './ir-types';\n\n/**\n * Flattens a JavaScript value (Scalar, Object, Array) into a linear array of numbers (floats)\n * based on the provided DataType. Assumes std430 tight packing for f32 scalars.\n */\nexport function packData(val: any, type: DataType): number[] {\n  const res: number[] = [];\n\n  // Handle Primitive\n  if (type.kind === DataTypeKind.Primitive) {\n    if (typeof val === 'number') return [val];\n    if (typeof val === 'boolean') return [val ? 1 : 0]; // WGSL bool is 1 byte but often aligned to 4?\n    // WGSL spec says 'bool' in storage buffer is NOT allowed directly usually, or takes 4 bytes?\n    // Actually codegen-wgsl maps boolean to 'bool'.\n    // Storage buffer bool is tricky. Let's assume codegen maps Primitive 'boolean' to f32 for IO?\n    // Wait, typical pattern is to explicit cast.\n    // If codegen outputs `var input: Input` where Input has `bool`, that's invalid for storage buffers in some specs.\n    // But let's assume f32 for now, or just emit 0/1. Float32Array will store as float.\n    return [0];\n  }\n\n  // Handle Struct\n  if (type.kind === DataTypeKind.Struct) {\n    const s = type as StructType;\n    // Fields keys must match Codegen order!\n    // Codegen uses Object.keys().sort().\n    const keys = Object.keys(s.fields).sort();\n    for (const k of keys) {\n      const fieldVal = val ? val[k] : undefined;\n      // Pad if missing? Or error?\n      // Test cases might pass partial inputs (optional fields).\n      // If missing, push zeros based on size scan.\n      res.push(...packData(fieldVal ?? 0, s.fields[k]));\n    }\n    return res;\n  }\n\n  // Handle Array\n  if (type.kind === DataTypeKind.Array) {\n    const s = type as any; // ArrayType?\n    const inner = s.elementType;\n    // If val is provided, iterate.\n    if (Array.isArray(val)) {\n      for (const item of val) {\n        res.push(...packData(item, inner));\n      }\n    }\n    // NOTE: Layout is tight packed.\n    return res;\n  }\n\n  // Fallback\n  return [0];\n}\n\n/**\n * Reconstructs a JavaScript Object/Array from a flat Float32Array\n * based on the provided DataType.\n */\nexport function unpackData(buffer: Float32Array | number[], type: DataType): any {\n  // If we have an array, wrap in iterator to consume sequentially\n  let stream: number[];\n  if (buffer instanceof Float32Array) stream = Array.from(buffer);\n  else stream = buffer;\n\n  let ptr = 0;\n\n  function read(t: DataType): any {\n    if (t.kind === DataTypeKind.Primitive) {\n      const val = stream[ptr++];\n      if ((t as PrimitiveType).name === 'boolean') return val !== 0;\n      return val;\n    }\n\n    if (t.kind === DataTypeKind.Struct) {\n      const s = t as StructType;\n      const obj: any = {};\n      const keys = Object.keys(s.fields).sort();\n      for (const k of keys) {\n        obj[k] = read(s.fields[k]);\n      }\n      return obj;\n    }\n\n    if (t.kind === DataTypeKind.Array) {\n      const len = (t as any).length;\n      const inner = (t as any).elementType;\n      const res = [];\n\n      if (typeof len === 'number') {\n        // Fixed size array\n        for (let i = 0; i < len; i++) {\n          res.push(read(inner));\n        }\n      } else {\n        // Dynamic array (assume rest of buffer)\n        while (ptr < stream.length) {\n          res.push(read(inner));\n        }\n      }\n      return res;\n    }\n    return 0;\n  }\n\n  return read(type);\n}\n","import { html, css } from 'lit';\nimport { customElement, state } from 'lit/decorators.js';\nimport { MobxLitElement } from './mobx-lit-element';\nimport { compileToIR } from '../customnodes/expr/v2/compiler';\nimport { generateWGSL } from '../customnodes/expr/v2/codegen-wgsl';\nimport { DataTypeKind, PrimitiveType, DataType } from '../customnodes/expr/v2/ir-types';\nimport { testCases, TestCase } from '../customnodes/expr/v2/backend-test-cases';\nimport { packData, unpackData } from '../customnodes/expr/v2/wgsl-utils';\n\ndeclare const GPUBufferUsage: any;\ndeclare const GPUShaderStage: any;\ndeclare const GPUMapMode: any;\n\nconst F32_SIZE = 4;\n\n@customElement('wgsl-tester')\nexport class WGSLTester extends MobxLitElement {\n  static styles = css`\n    :host {\n      display: flex;\n      flex-direction: row;\n      width: 100%;\n      height: 100%;\n      background: #1e1e1e;\n      color: #d4d4d4;\n      font-family: monospace;\n      padding: 20px;\n      box-sizing: border-box;\n      gap: 10px;\n    }\n    textarea {\n      width: 100%;\n      height: 300px;\n      background: #252526;\n      color: #dcdcdc;\n      border: 1px solid #3e3e42;\n      font-family: inherit;\n      padding: 10px;\n    }\n    button {\n      padding: 8px 16px;\n      background: #0e639c;\n      color: white;\n      border: none;\n      cursor: pointer;\n    }\n    button:hover {\n      background: #1177bb;\n    }\n    .toolbar {\n      display: flex;\n      gap: 10px;\n    }\n    pre {\n      background: #2d2d2d;\n      padding: 10px;\n      overflow: auto;\n      flex: 1;\n    }\n  `;\n\n  @state()\n  currentTest: TestCase | null = null;\n\n  @state()\n  code = '';\n\n  @state()\n  output = '';\n\n  @state()\n  wgslCode = '';\n\n  loadTest(tc: TestCase) {\n    this.currentTest = tc;\n    this.code = tc.code;\n    this.output = '';\n    this.wgslCode = '';\n  }\n\n  async run() {\n    try {\n      if (!this.currentTest) {\n        // Default \"Custom\" run?\n        // Assume inputs { x: number }\n        this.currentTest = {\n          name: 'Custom',\n          code: this.code,\n          inputValues: { x: 10 },\n          inputTypes: { x: { kind: DataTypeKind.Primitive, name: 'number' } as PrimitiveType },\n          outputType: { kind: DataTypeKind.Primitive, name: 'number' } as PrimitiveType\n        };\n      }\n\n      this.output = `=== ${this.currentTest.name} ===\\nCompiling...`;\n\n      // Use inputs from test case (or defaults)\n      const inputs = this.currentTest.inputValues || {};\n      let inputTypes = this.currentTest.inputTypes;\n\n      // Infer types if missing\n      if (!inputTypes) {\n        inputTypes = {};\n        for (const k in inputs) {\n          if (typeof inputs[k] === 'number') inputTypes[k] = { kind: DataTypeKind.Primitive, name: 'number' } as any;\n          else if (Array.isArray(inputs[k])) inputTypes[k] = { kind: DataTypeKind.Array, elementType: { kind: DataTypeKind.Primitive, name: 'number' } as any } as any; // Simple inference fallback\n          else if (typeof inputs[k] === 'object') inputTypes[k] = { kind: DataTypeKind.Struct, fields: {} } as any; // Naive\n        }\n      }\n\n      const ir = compileToIR(this.code, inputTypes);\n      // Default output type to number if undefined, unless inferred by codegen?\n      // Codegen needs explicit output type struct wrapper.\n      // We'll trust testCase.outputType or default to number.\n      const outputType = this.currentTest.outputType || { kind: DataTypeKind.Primitive, name: 'number' } as any;\n\n      const wgsl = generateWGSL(ir, {\n        inputs: inputTypes,\n        outputType: outputType\n      });\n      this.wgslCode = wgsl;\n\n      this.output += '\\nWGSL Generated.\\nRunning on GPU...';\n\n      if (!(navigator as any).gpu) {\n        this.output += '\\nWebGPU not supported in this browser.';\n        return 'Error: WebGPU not supported';\n      }\n\n      const adapter = await (navigator as any).gpu.requestAdapter();\n      if (!adapter) {\n        this.output += '\\nNo adapter found.';\n        return 'Error: No adapter found';\n      }\n      const device = await adapter.requestDevice();\n\n      const shaderModule = device.createShaderModule({ code: wgsl });\n\n      // Check for compilation errors\n      const compilationInfo = await shaderModule.getCompilationInfo();\n      if (compilationInfo.messages.length > 0) {\n        let hadError = false;\n        for (const msg of compilationInfo.messages) {\n          this.output += `\\n[${msg.type}] line ${msg.lineNum}:${msg.linePos} - ${msg.message}`;\n          if (msg.type === 'error') hadError = true;\n        }\n        if (hadError) {\n          this.output += '\\n\\nShader Compilation Failed. Aborting.';\n          return `Error: Shader Compilation Failed\\nLogs:\\n${this.output}\\n\\nCode:\\n${this.wgslCode}`;\n        }\n      }\n\n      // --- Pack Inputs ---\n      // Flatten all inputs into single buffer (Input struct)\n      const inputFloats: number[] = [];\n      // Order must match codegen (Object.keys sorted)\n      const sortedKeys = Object.keys(inputTypes).sort();\n      for (const k of sortedKeys) {\n        inputFloats.push(...packData(inputs[k], inputTypes[k]));\n      }\n\n      const inputData = new Float32Array(inputFloats);\n      // If empty input? Make at least 4 bytes to avoid validation error on zero-size binding?\n      // WGSL struct Input {} is valid? empty struct.\n      // If inputData is empty, buffer create might fail if size 0.\n      const inputSize = Math.max(inputData.byteLength, 16); // Minimum size\n      const inputBuffer = device.createBuffer({\n        size: inputSize,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      });\n      if (inputData.byteLength > 0) {\n        device.queue.writeBuffer(inputBuffer, 0, inputData);\n      }\n\n      // --- Output Buffer ---\n      // Allocate generous size (e.g. 64KB) or estimate\n      const outputBufferSize = 65536;\n      const outputBuffer = device.createBuffer({\n        size: outputBufferSize,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      });\n\n      const bindGroupLayout = device.createBindGroupLayout({\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: 'storage' }\n          },\n          {\n            binding: 1,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: 'storage' }\n          }\n        ]\n      });\n\n      const pipelineLayout = device.createPipelineLayout({\n        bindGroupLayouts: [bindGroupLayout]\n      });\n\n      // Pipeline\n      const pipeline = device.createComputePipeline({\n        layout: pipelineLayout,\n        compute: { module: shaderModule, entryPoint: 'main' },\n      });\n\n      const bindGroup = device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [\n          { binding: 0, resource: { buffer: inputBuffer } },\n          { binding: 1, resource: { buffer: outputBuffer } }\n        ]\n      });\n\n      const commandEncoder = device.createCommandEncoder();\n      const passEncoder = commandEncoder.beginComputePass();\n      passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, bindGroup);\n      passEncoder.dispatchWorkgroups(1);\n      passEncoder.end();\n\n      // Readback\n      const readBuffer = device.createBuffer({\n        size: outputBufferSize,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n      });\n      commandEncoder.copyBufferToBuffer(outputBuffer, 0, readBuffer, 0, outputBufferSize);\n      device.queue.submit([commandEncoder.finish()]);\n\n      await readBuffer.mapAsync(GPUMapMode.READ);\n      const arrayBuffer = readBuffer.getMappedRange();\n      const floatView = new Float32Array(arrayBuffer);\n\n      // Unpack Result from Output Struct\n      // Output struct is { result: T }\n      // So simple unpack of T\n      const resValue = unpackData(floatView, outputType);\n\n      this.output += `\\nSuccess!\\nResult: ${JSON.stringify(resValue, null, 2)}`;\n\n      // Verify against expected?\n      if (this.currentTest.expected !== undefined) {\n        this.output += `\\nExpected: ${JSON.stringify(this.currentTest.expected, null, 2)}`;\n      }\n\n      readBuffer.unmap();\n      return `Success: ${JSON.stringify(resValue)}`;\n\n    } catch (e: any) {\n      this.output += `\\nError: ${e.message}\\n${e.stack}`;\n      return `Error: ${e.message}`;\n    }\n  }\n\n  async runTestByName(name: string): Promise<string> {\n    const tc = testCases.find(t => t.name === name);\n    if (!tc) return `Error: Test ${name} not found`;\n    this.loadTest(tc);\n    return await this.run();\n  }\n\n  render() {\n    return html`\n      <div style=\"width: 250px; border-right: 1px solid #333; overflow:auto; display:flex; flex-direction:column;\">\n        <div style=\"padding:10px; font-weight:bold; background:#252526;\">Test Cases</div>\n        ${testCases.map(tc => html`\n            <div\n                style=\"padding:5px 10px; cursor:pointer; background:${this.currentTest === tc ? '#37373d' : 'transparent'}; text-overflow:ellipsis; white-space:nowrap; overflow:hidden;\"\n                @click=${() => this.loadTest(tc)}\n            >\n                ${tc.name}\n                ${tc.skipWGSL ? ' (SKIP)' : ''}\n            </div>\n        `)}\n      </div>\n      <div style=\"flex:1; display:flex; flex-direction:column; padding:10px;\">\n        <div class=\"toolbar\">\n           <button @click=${this.run}>RUN WGSL</button>\n        </div>\n        <div style=\"display:flex; flex:1; gap:10px; min-height:0; margin-top:10px;\">\n            <div style=\"flex:1; display:flex; flex-direction:column;\">\n                <h3>TypeScript</h3>\n                <textarea @input=${(e: any) => this.code = e.target.value} .value=${this.code}></textarea>\n                <h3>WGSL Output</h3>\n                <pre style=\"flex:1\">${this.wgslCode}</pre>\n            </div>\n            <div style=\"flex:1; display:flex; flex-direction:column;\">\n                <h3>Execution Output</h3>\n                <pre>${this.output}</pre>\n            </div>\n        </div>\n      </div>\n    `;\n  }\n}\n"],"names":["NUMBER_TYPE","DataTypeKind","testCases","res","debug","BALL_TYPE","BALLS_INPUT_TYPE","b0","b1","VEC3_TYPE","packData","val","type","s","keys","k","fieldVal","inner","item","unpackData","buffer","stream","ptr","read","t","obj","len","i","WGSLTester","MobxLitElement","tc","inputs","inputTypes","ir","compileToIR","outputType","wgsl","generateWGSL","adapter","device","shaderModule","compilationInfo","hadError","msg","inputFloats","sortedKeys","inputData","inputSize","inputBuffer","outputBufferSize","outputBuffer","bindGroupLayout","pipelineLayout","pipeline","bindGroup","commandEncoder","passEncoder","readBuffer","arrayBuffer","floatView","resValue","name","html","css","__decorateClass","state","customElement"],"mappings":"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"}