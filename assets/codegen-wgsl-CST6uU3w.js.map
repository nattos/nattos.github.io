{"version":3,"file":"codegen-wgsl-CST6uU3w.js","sources":["../../src/customnodes/expr/v2/scope.ts","../../src/customnodes/expr/v2/compiler.ts","../../src/customnodes/expr/v2/codegen-wgsl.ts"],"sourcesContent":["import { IRNode, DataType, OpKind, ConstNode, PhiNode, BlockNode, ReturnNode, Diagnostic, DiagnosticSeverity } from './ir-types';\nimport * as ts from 'typescript';\n\n// Scope Definitions\nexport class Scope {\n  private variables = new Map<string, DataType>();\n  public values = new Map<string, IRNode | undefined>();\n  public aliases = new Map<string, IRNode>(); // Reference Aliases\n  private functions = new Map<string, ts.FunctionDeclaration>();\n\n  constructor(public parent: Scope | null = null, public isBranchScope: boolean = false) { }\n\n  // Create a Branch Scope (Isolation Boundary)\n  fork(): Scope {\n    const child = new Scope(this, true);\n    return child;\n  }\n\n  // Create a Lexical Child Scope (Nested Block)\n  extend(): Scope {\n    const child = new Scope(this, false);\n    return child;\n  }\n\n  // Snapshot for Closures\n  snapshot(): Scope {\n    const copy = new Scope(null, false);\n    copy.values = new Map(this.values);\n    copy.variables = new Map(this.variables);\n    copy.functions = new Map(this.functions);\n    copy.types = new Map(this.types);\n    copy.aliases = new Map(this.aliases);\n\n    if (this.parent) {\n      copy.parent = this.parent.snapshot();\n    }\n    return copy;\n  }\n\n  declare(name: string, type: DataType) {\n    this.variables.set(name, type);\n  }\n\n  set(name: string, value: IRNode) {\n    this.values.set(name, value);\n  }\n\n  declareFunction(name: string, node: ts.FunctionDeclaration) {\n    if (node.body) {\n      this.functions.set(name, node);\n    }\n  }\n\n  // Recursive Assignment Logic\n  assign(name: string, value: IRNode) {\n    // Invalidate alias if being reassigned\n    if (this.aliases.has(name)) {\n      this.aliases.delete(name);\n    }\n\n    if (this.values.has(name)) {\n      this.values.set(name, value);\n      return;\n    }\n    if (this.parent) {\n      if (this.isBranchScope) {\n        this.values.set(name, value);\n      } else {\n        this.parent.assign(name, value);\n      }\n      return;\n    }\n    this.values.set(name, value);\n  }\n\n  resolve(name: string): DataType | undefined {\n    if (this.variables.has(name)) return this.variables.get(name)!;\n    if (this.parent) return this.parent.resolve(name);\n    return undefined;\n  }\n\n  resolveValue(name: string): IRNode | undefined {\n    if (this.values.has(name)) return this.values.get(name);\n    if (this.parent) return this.parent.resolveValue(name);\n    return undefined;\n  }\n\n  resolveAlias(name: string): IRNode | undefined {\n    if (this.aliases.has(name)) return this.aliases.get(name);\n    if (this.parent) return this.parent.resolveAlias(name);\n    return undefined;\n  }\n\n  invalidateAll() {\n    let current: Scope | null = this;\n    while (current) {\n      for (const k of current.variables.keys()) {\n        this.values.set(k, undefined);\n      }\n      current = current.parent;\n    }\n  }\n\n  resolveFunction(name: string): ts.FunctionDeclaration | null {\n    if (this.functions.has(name)) return this.functions.get(name)!;\n    if (this.parent) return this.parent.resolveFunction(name);\n    return null;\n  }\n\n  static merge(parent: Scope, branchA: Scope, branchB: Scope, condition: IRNode): void {\n    // Intentionally empty for now (logic externalized)\n  }\n\n  // Type Registry\n  public types = new Map<string, DataType>();\n\n  declareType(name: string, type: DataType) {\n    this.types.set(name, type);\n  }\n\n  resolveType(name: string): DataType | undefined {\n    if (this.types.has(name)) return this.types.get(name);\n    if (this.parent) return this.parent.resolveType(name);\n    return undefined;\n  }\n}\n\nexport class CompilerContext {\n  public scope: Scope;\n  public diagnostics: Diagnostic[] = [];\n  public depth: number = 0;\n\n  // Configurable limit\n  public maxDepth: number = 500;\n\n  // Accumulated Inputs from Var Decls\n  public declaredInputs: Record<string, DataType> = {};\n\n  constructor(public sourceFile: ts.SourceFile) {\n    this.scope = new Scope();\n  }\n\n  addDiagnostic(message: string, severity: DiagnosticSeverity, node?: ts.Node | IRNode) {\n    let range;\n    if (node && (node as any).getStart) {\n      // TS Node\n      const tsNode = node as ts.Node;\n      const start = this.sourceFile.getLineAndCharacterOfPosition(tsNode.getStart());\n      const end = this.sourceFile.getLineAndCharacterOfPosition(tsNode.getEnd());\n      range = {\n        startLineNumber: start.line + 1,\n        startColumn: start.character + 1,\n        endLineNumber: end.line + 1,\n        endColumn: end.character + 1\n      };\n    } else if (node && (node as any).debugInfo) {\n      // IR Node (limited info)\n      const line = (node as any).debugInfo.line;\n      range = {\n        startLineNumber: line,\n        startColumn: 1,\n        endLineNumber: line,\n        endColumn: 1\n      };\n    }\n\n    this.diagnostics.push({\n      message,\n      severity,\n      source: 'compiler',\n      range\n    });\n  }\n\n  addError(message: string, node?: ts.Node | IRNode) {\n    this.addDiagnostic(message, DiagnosticSeverity.Error, node);\n  }\n\n  addWarning(message: string, node?: ts.Node | IRNode) {\n    this.addDiagnostic(message, DiagnosticSeverity.Warning, node);\n  }\n\n  pushScope() {\n    this.scope = this.scope.extend();\n  }\n  popScope() {\n    if (this.scope.parent) {\n      this.scope = this.scope.parent;\n    }\n  }\n}\n\nexport function extractReturn(node: IRNode | null): IRNode | null {\n  if (!node) return null;\n  if (node.kind === OpKind.Return) return (node as ReturnNode).value;\n  if (node.kind === OpKind.Block) {\n    const block = node as BlockNode;\n    if (block.statements.length > 0) return extractReturn(block.statements[block.statements.length - 1]);\n  }\n  return null;\n}\n","import * as ts from \"typescript\";\nimport {\n  IRGraph, IRNode, OpKind, DataTypeKind, DataType, PrimitiveType,\n  VarDeclNode, VarNode, BlockNode, IfNode, ReturnNode, BinaryNode, ConstNode, AssignNode, ArrayNode, StructNode, PropAccessNode, PhiNode, IntrinsicNode, StructType, WhileNode, SetPropNode, SetIndexNode, DiagnosticSeverity,\n  IndexAccessNode\n} from \"./ir-types\";\nimport { Scope, CompilerContext, extractReturn } from \"./scope\";\nimport { resolveGlobal, tryCompileStaticCall, tryCompileInstanceMethod } from \"./stdlib\";\n\n// Scope and Context moved to scope.ts\n\nfunction compileNode(node: ts.Node, ctx: CompilerContext): IRNode | null {\n  ctx.depth++;\n  if (ctx.depth > ctx.maxDepth) {\n    if (ctx.diagnostics.length === 0 || !ctx.diagnostics[ctx.diagnostics.length - 1].message.includes('Recursion')) {\n      ctx.addError(`Recursion depth exceeded (${ctx.maxDepth})`, node);\n    }\n    ctx.depth--;\n    return null;\n  }\n\n  try {\n    switch (node.kind) {\n      case ts.SyntaxKind.ExpressionStatement:\n        return compileNode((node as ts.ExpressionStatement).expression, ctx);\n\n      case ts.SyntaxKind.SourceFile: {\n        const sf = node as ts.SourceFile;\n        const statements: IRNode[] = [];\n        for (const stmt of sf.statements) {\n          const s = compileNode(stmt, ctx);\n          if (s) statements.push(s);\n        }\n        return { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements } as BlockNode;\n      }\n\n      case ts.SyntaxKind.Block: {\n        const block = node as ts.Block;\n        ctx.pushScope();\n        const statements: IRNode[] = [];\n        for (const stmt of block.statements) {\n          const s = compileNode(stmt, ctx);\n          if (s) statements.push(s);\n        }\n        ctx.popScope();\n        return { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements } as BlockNode;\n      }\n\n      case ts.SyntaxKind.VariableStatement: {\n        const stmt = node as ts.VariableStatement;\n        // Delegate to VariableDeclarationList handler\n        return compileNode(stmt.declarationList, ctx);\n      }\n\n      case ts.SyntaxKind.VariableDeclarationList: {\n        const list = node as ts.VariableDeclarationList;\n        const decls: IRNode[] = [];\n        list.declarations.forEach(decl => {\n          const name = (decl.name as ts.Identifier).text;\n          let init: IRNode | undefined;\n          let type: DataType = { kind: DataTypeKind.Any };\n\n          const flags = ts.getCombinedNodeFlags(decl);\n          const isConst = !!(flags & ts.NodeFlags.Const);\n\n          if (decl.type) {\n            type = resolveType(decl.type, ctx);\n          } else if (decl.initializer) {\n            init = compileNode(decl.initializer, ctx) || undefined;\n            if (init) {\n              type = init.type;\n            }\n          }\n\n          // Initializer compilation if type was from annotation but init exists (and not processed above)\n          if (decl.initializer && !init) {\n            init = compileNode(decl.initializer, ctx) || undefined;\n            // Only infer type from initializer if NOT explicitly annotated\n            if (init && !decl.type) type = init.type;\n          }\n\n          // Aliasing Logic for 'let' (mutable) variables initialized with L-Values\n          if (init && !isConst && (type.kind === DataTypeKind.Array || type.kind === DataTypeKind.Struct)) {\n            // Check if init is an L-Value Expression (Reference)\n            // Var, PropAccess, IndexAccess\n            // Also if init is an Alias (Identifier that resolved to Alias), it is already an IRNode of that kind.\n            const isLValue = init.kind === OpKind.Var ||\n              init.kind === OpKind.PropAccess ||\n              init.kind === OpKind.IndexAccess ||\n              init.kind === OpKind.SetIndex || // Chain assignment? No.\n              init.kind === OpKind.SetProp; // Chain?\n\n            // Also special case: If init is loop variable? VarNode.\n\n            if (isLValue) {\n              // Register Alias\n              ctx.scope.aliases.set(name, init);\n              ctx.scope.declare(name, type); // Declare type but no VarDecl\n              return; // SKIP emitting VarDecl\n            }\n          }\n\n          // Top-level Uninitialized Variable -> Input Definition\n          if (!init && ctx.scope.parent === null && !ctx.scope.isBranchScope) {\n            // Register as Input\n            ctx.declaredInputs[name] = type;\n            // Register as Var in Scope (so it resolves to Input Binding/VarNode)\n            ctx.scope.set(name, { id: nextId(), kind: OpKind.Var, type, name } as VarNode);\n            // Do NOT emit VarDecl\n            return;\n          }\n\n          // Standard Handling\n          if (init) {\n            if (!isConst && (type.kind === DataTypeKind.Array || type.kind === DataTypeKind.Struct)) {\n              ctx.scope.set(name, { id: nextId(), kind: OpKind.Var, type, name } as VarNode);\n            } else {\n              ctx.scope.set(name, init);\n            }\n          }\n\n          ctx.scope.declare(name, type);\n          const { line } = ctx.sourceFile.getLineAndCharacterOfPosition(decl.getStart());\n          decls.push({ id: nextId(), kind: OpKind.VarDecl, type, name, init, debugInfo: { line: line + 1 } } as VarDeclNode);\n        });\n        if (decls.length === 0) return null; // No emissions (aliased or input)\n        if (decls.length === 1) return decls[0];\n        return { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements: decls } as BlockNode;\n      }\n\n      case ts.SyntaxKind.Identifier: {\n        const name = (node as ts.Identifier).text;\n\n        // Check Alias\n        const alias = ctx.scope.resolveAlias(name);\n        if (alias) return { ...alias }; // Shallow copy\n\n        const val = ctx.scope.resolveValue(name);\n        if (val) return val;\n        const func = ctx.scope.resolveFunction(name);\n        if (func) {\n          return { id: nextId(), kind: OpKind.Const, type: ANY_TYPE, value: { node: func, closure: ctx.scope.snapshot() } } as ConstNode;\n        }\n        const type = ctx.scope.resolve(name);\n        if (!type) {\n          // Check Globals (StdLib)\n          const globalVal = resolveGlobal(name);\n          if (globalVal) return globalVal;\n          if (name !== 'Array') {\n            console.log(`Debug: Warn for ${name}`);\n            ctx.addWarning(`Unresolved identifier: ${name}`, node);\n          }\n          return { id: nextId(), kind: OpKind.Var, type: { kind: DataTypeKind.Any }, name } as VarNode;\n        }\n        return { id: nextId(), kind: OpKind.Var, type, name } as VarNode;\n      }\n\n      case ts.SyntaxKind.NumericLiteral:\n        return { id: nextId(), kind: OpKind.Const, type: NUMBER_TYPE, value: parseFloat((node as ts.NumericLiteral).text) } as ConstNode;\n\n      case ts.SyntaxKind.StringLiteral:\n        return { id: nextId(), kind: OpKind.Const, type: { kind: DataTypeKind.Primitive, name: 'string' }, value: (node as ts.StringLiteral).text } as ConstNode;\n\n      case ts.SyntaxKind.TrueKeyword:\n        return { id: nextId(), kind: OpKind.Const, type: { kind: DataTypeKind.Primitive, name: 'boolean' }, value: true } as ConstNode;\n      case ts.SyntaxKind.FalseKeyword:\n        return { id: nextId(), kind: OpKind.Const, type: { kind: DataTypeKind.Primitive, name: 'boolean' }, value: false } as ConstNode;\n\n      case ts.SyntaxKind.CallExpression: {\n        const call = node as ts.CallExpression;\n\n        const staticRes = tryCompileStaticCall(ctx, call, compileNode);\n        if (staticRes) return staticRes;\n\n        if (call.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n          const prop = call.expression as ts.PropertyAccessExpression;\n          const obj = compileNode(prop.expression, ctx);\n          if (obj) {\n            const instanceRes = tryCompileInstanceMethod(ctx, call, obj, compileNode);\n            if (instanceRes) return instanceRes;\n          }\n        }\n\n        // Inline User Funcs\n        let funcVal: IRNode | null = null;\n        let funcDecl: ts.FunctionLikeDeclaration | null = null;\n\n        if (call.expression.kind === ts.SyntaxKind.Identifier) {\n          const funcName = (call.expression as ts.Identifier).text;\n          funcVal = ctx.scope.resolveValue(funcName) || null;\n          if (!funcVal) funcDecl = ctx.scope.resolveFunction(funcName);\n        } else {\n          funcVal = compileNode(call.expression, ctx);\n        }\n\n        /* ... tryInlineFunc Definition ... */\n        const tryInlineFunc = (targetFunc: ts.FunctionLikeDeclaration, callNode: ts.CallExpression, closureScope?: Scope): IRNode | null => {\n          const args: { name: string, value: IRNode }[] = [];\n          const typeParams = targetFunc.typeParameters;\n          const genericMap = new Map<string, DataType>();\n          for (let i = 0; i < targetFunc.parameters.length; i++) {\n            const param = targetFunc.parameters[i];\n            const paramName = (param.name as ts.Identifier).text;\n            const pType = param.type ? resolveType(param.type, ctx) : ANY_TYPE; // Inside tryInlineFunc capture ctx\n\n            let argNode = callNode.arguments[i] ? compileNode(callNode.arguments[i], ctx) : undefined;\n\n            if (!argNode) {\n              if (param.initializer) {\n                // Compile default value in current context?\n                // Defaults are usually evaluated in callee scope but if simple constant ok.\n                // Simplification: We compile in caller context (ctx) because we are inlining?\n                // No, lexical scope of definition?\n                // If it's `b = 1`, 1 is const.\n                // If `b = someVar`, someVar must be resolved.\n                // If closure, we should switch scope?\n                // `tryInlineFunc` switches scope later.\n                // We should compile default in the closure scope if possible.\n                // But we are gathering args before pushing scope.\n                // Let's assume defaults are simple or handle later?\n                // Actually, for now, let's just use undefined for optional if no default.\n                // If default exists, we try to compile it.\n                // But wait, compileNode needs context.\n                // Let's defer default value?\n                // Or just handle `undefined` for now as requested.\n                argNode = compileNode(param.initializer, ctx) || undefined;\n              } else if (param.questionToken) {\n                argNode = { id: nextId(), kind: OpKind.Const, type: { kind: DataTypeKind.Primitive, name: 'undefined' }, value: undefined } as ConstNode;\n              }\n            }\n\n            if (argNode) {\n              if (param.type && param.type.kind === ts.SyntaxKind.TypeReference) {\n                const typeRef = param.type as ts.TypeReferenceNode;\n                const typeName = (typeRef.typeName as ts.Identifier).text;\n                if (typeParams?.some(tp => tp.name.text === typeName)) genericMap.set(typeName, argNode.type);\n              }\n              args.push({ name: paramName, value: argNode });\n            }\n          }\n          const savedScope = ctx.scope;\n          if (closureScope) ctx.scope = closureScope;\n          ctx.pushScope();\n          for (const arg of args) {\n            ctx.scope.set(arg.name, arg.value);\n            ctx.scope.declare(arg.name, arg.value.type);\n          }\n          let result: IRNode | null = null;\n          if (targetFunc.body) {\n            if (targetFunc.kind === ts.SyntaxKind.ArrowFunction && targetFunc.body.kind !== ts.SyntaxKind.Block) {\n              result = compileNode(targetFunc.body, ctx);\n            } else {\n              const bodyBlock = targetFunc.body as ts.Block;\n              const statements: IRNode[] = [];\n              for (const stmt of bodyBlock.statements) {\n                const compiledStmt = compileNode(stmt, ctx);\n                if (compiledStmt) statements.push(compiledStmt);\n                const ret = extractReturn(compiledStmt);\n                if (ret) {\n                  result = ret;\n                  // If we have side effects before return, we need to preserve them.\n                  // But 'result' (Expression) is not a Block.\n                  // Only if we return BlockNode do we preserve statements.\n                  // If result is found, we assume it's the value.\n                  // BUT side effects must run!\n                  // Current compiler assumes pure expressions usually.\n                  // For 'modify(s)', result is null.\n                  break;\n                }\n              }\n              if (!result && statements.length > 0) {\n                // Void function with side effects -> Return Block\n                result = { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements } as BlockNode;\n              } else if (result && statements.length > 1) {\n                // Side effects + Return -> Block?\n                // Return BlockNode but how to represent return value?\n                // C++: ({ stmt; stmt; val; }) ?\n                // Or if usage is Statement context, Block is fine.\n                // If usage is Expression context, we lose side effects unless we handle 'BlockExpression'.\n                // For now, let's assume void functions return Block, value functions return Value.\n                // If value function has side effects (stmt before return), we might lose them here\n                // unless we implement Statement Expression.\n                // But specifically for 'modify(s)' references (void function side effects), Block is correct.\n              }\n            }\n          }\n          ctx.popScope();\n          ctx.scope = savedScope;\n          if (result && targetFunc.type && targetFunc.type.kind === ts.SyntaxKind.TypeReference) {\n            // Generics mapping\n            const returnTypeRef = targetFunc.type as ts.TypeReferenceNode;\n            const returnTypeName = (returnTypeRef.typeName as ts.Identifier).text;\n            if (returnTypeRef.typeArguments && returnTypeRef.typeArguments.length > 0) {\n              const typeArg = returnTypeRef.typeArguments[0];\n              if (typeArg.kind === ts.SyntaxKind.TypeReference && genericMap.has((typeArg as ts.TypeReferenceNode).typeName.getText())) {\n                const resolvedT = genericMap.get((typeArg as ts.TypeReferenceNode).typeName.getText())!;\n                const reflectedType = GENERIC_INST(returnTypeName, [resolvedT]);\n                return { ...result, type: reflectedType };\n              }\n            }\n          }\n          return result;\n        };\n\n        if (funcVal) {\n          if (funcVal.kind === OpKind.Phi) {\n            const phi = funcVal as PhiNode;\n            // Recursively dispatch the call to each branch\n            const dispatchPhi = (node: IRNode): IRNode | null => {\n              if (node.kind === OpKind.Phi) {\n                const p = node as PhiNode;\n                const t = dispatchPhi(p.trueValue);\n                const f = dispatchPhi(p.falseValue);\n                if (!t || !f) return null;\n                // Check type compatibility?\n                return { id: nextId(), kind: OpKind.Phi, type: t.type, condition: p.condition, trueValue: t, falseValue: f } as PhiNode;\n              }\n              if (node.kind === OpKind.Const && (node as ConstNode).value) {\n                const v = (node as ConstNode).value;\n                if (v.node && v.closure) return tryInlineFunc(v.node, call, v.closure);\n                if (v.kind) return tryInlineFunc(v, call);\n              }\n              return null;\n            };\n            return dispatchPhi(phi);\n          }\n          if (funcVal.kind === OpKind.Const && (funcVal as ConstNode).value) {\n            const v = (funcVal as ConstNode).value;\n            if (v.node && v.closure) return tryInlineFunc(v.node, call, v.closure);\n            if (v.kind) return tryInlineFunc(v, call);\n          }\n        }\n        if (funcDecl) return tryInlineFunc(funcDecl, call);\n\n        ctx.addError(`Unsupported dynamic dispatch or unresolved function: ${node.getText()}`, node);\n        return null;\n      }\n\n      case ts.SyntaxKind.BinaryExpression: {\n        const expr = node as ts.BinaryExpression;\n        if (expr.operatorToken.kind === ts.SyntaxKind.EqualsToken || expr.operatorToken.kind === ts.SyntaxKind.PlusEqualsToken) {\n          const isCompound = expr.operatorToken.kind === ts.SyntaxKind.PlusEqualsToken;\n\n          // Compile Value (RHS)\n          let right = compileNode(expr.right, ctx);\n          if (!right) return null;\n\n          // Helper to get read value for compound op\n          const getReadValue = (lhsNode: IRNode): IRNode => {\n            // We need to construct (lhsNode + right)\n            // Note: lhsNode might be re-evaluated. Assuming safe for DSL usage (e.g. loops).\n            return { id: nextId(), kind: OpKind.Binary, type: NUMBER_TYPE, op: '+', left: lhsNode, right } as BinaryNode; // Assuming + for now\n          };\n\n          if (expr.left.kind === ts.SyntaxKind.Identifier) {\n            const targetName = (expr.left as ts.Identifier).text;\n            if (isCompound) {\n              // Resolve current value\n              const currentVal = ctx.scope.resolveValue(targetName);\n              // If not found, look up by name (VarNode)\n              const lhs = currentVal || { id: nextId(), kind: OpKind.Var, type: NUMBER_TYPE, name: targetName } as VarNode;\n              right = getReadValue(lhs);\n            }\n            ctx.scope.assign(targetName, right);\n            const { line } = ctx.sourceFile.getLineAndCharacterOfPosition(expr.getStart());\n            return { id: nextId(), kind: OpKind.Assign, type: VOID_TYPE, target: targetName, value: right, debugInfo: { line: line + 1 } } as AssignNode;\n\n          } else if (expr.left.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const prop = expr.left as ts.PropertyAccessExpression;\n            const obj = compileNode(prop.expression, ctx);\n            if (!obj) return null;\n            const name = prop.name.text;\n\n            if (isCompound) {\n              // Synthesize Read: PropAccess(obj, name)\n              // NOTE: obj re-evaluation risk.\n              const readProp = { id: nextId(), kind: OpKind.PropAccess, type: ANY_TYPE, object: obj, property: name } as PropAccessNode;\n              right = getReadValue(readProp);\n            }\n            if (obj.kind === OpKind.Phi) {\n              ctx.addWarning('Mutation of Phi value: Reference origin is ambiguous due to control flow.', node);\n            }\n            return { id: nextId(), kind: OpKind.SetProp, type: VOID_TYPE, object: obj, property: name, value: right } as SetPropNode;\n\n          } else if (expr.left.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elem = expr.left as ts.ElementAccessExpression;\n            const obj = compileNode(elem.expression, ctx);\n            const index = compileNode(elem.argumentExpression, ctx);\n            if (!obj || !index) return null;\n\n            if (isCompound) {\n              // Synthesize Read: IndexAccess(obj, index)\n              // NOTE: obj/index re-evaluation risk.\n              const readIndex = { id: nextId(), kind: OpKind.IndexAccess, type: ANY_TYPE, object: obj, index } as any; // Cast/Ensure interface exists??\n              // IndexAccess interface exists but OpKind? Yes.\n              right = getReadValue(readIndex);\n            }\n            if (obj.kind === OpKind.Phi) {\n              ctx.addWarning('Mutation of Phi value: Reference origin is ambiguous due to control flow. Mutation will apply to audio-rate copy, not original source.', node);\n            }\n            return { id: nextId(), kind: OpKind.SetIndex, type: VOID_TYPE, object: obj, index, value: right } as SetIndexNode;\n          } else {\n            throw new Error(\"Assignment target must be Identifier, Property, or Element access\");\n          }\n        }\n        const left = compileNode(expr.left, ctx);\n        const right = compileNode(expr.right, ctx);\n        if (!left || !right) return null;\n\n        // Local type defs removed\n\n\n        // Constant Folding\n        if (left.kind === OpKind.Const && right.kind === OpKind.Const) {\n          const lVal = (left as ConstNode).value;\n          const rVal = (right as ConstNode).value;\n          // Check types match roughly (both numbers for arith/compare)\n          if (typeof lVal === 'number' && typeof rVal === 'number') {\n            let resVal: any = null;\n            let isBool = false;\n            switch (expr.operatorToken.kind) {\n              case ts.SyntaxKind.PlusToken: resVal = lVal + rVal; break;\n              case ts.SyntaxKind.MinusToken: resVal = lVal - rVal; break;\n              case ts.SyntaxKind.AsteriskToken: resVal = lVal * rVal; break;\n              case ts.SyntaxKind.SlashToken: resVal = lVal / rVal; break;\n              case ts.SyntaxKind.PercentToken: resVal = lVal % rVal; break;\n              case ts.SyntaxKind.LessThanToken: resVal = lVal < rVal; isBool = true; break;\n              case ts.SyntaxKind.GreaterThanToken: resVal = lVal > rVal; isBool = true; break;\n              case ts.SyntaxKind.LessThanEqualsToken: resVal = lVal <= rVal; isBool = true; break;\n              case ts.SyntaxKind.GreaterThanEqualsToken: resVal = lVal >= rVal; isBool = true; break;\n              case ts.SyntaxKind.EqualsEqualsToken: resVal = lVal == rVal; isBool = true; break;\n              case ts.SyntaxKind.ExclamationEqualsToken: resVal = lVal != rVal; isBool = true; break;\n              case ts.SyntaxKind.EqualsEqualsEqualsToken: resVal = lVal === rVal; isBool = true; break;\n              case ts.SyntaxKind.ExclamationEqualsEqualsToken: resVal = lVal !== rVal; isBool = true; break;\n            }\n            if (resVal !== null) {\n              return {\n                id: nextId(),\n                kind: OpKind.Const,\n                type: isBool ? BOOLEAN_TYPE : NUMBER_TYPE,\n                value: resVal\n              } as ConstNode;\n            }\n          }\n        }\n\n        let op: any = '?';\n        switch (expr.operatorToken.kind) {\n          case ts.SyntaxKind.PlusToken: op = '+'; break;\n          case ts.SyntaxKind.MinusToken: op = '-'; break;\n          case ts.SyntaxKind.AsteriskToken: op = '*'; break;\n          case ts.SyntaxKind.SlashToken: op = '/'; break;\n          case ts.SyntaxKind.LessThanToken: op = '<'; break;\n          case ts.SyntaxKind.GreaterThanToken: op = '>'; break;\n          case ts.SyntaxKind.LessThanEqualsToken: op = '<='; break;\n          case ts.SyntaxKind.GreaterThanEqualsToken: op = '>='; break;\n          case ts.SyntaxKind.EqualsEqualsToken: op = '=='; break;\n          case ts.SyntaxKind.ExclamationEqualsToken: op = '!='; break;\n          case ts.SyntaxKind.AmpersandAmpersandToken: op = '&&'; break;\n          case ts.SyntaxKind.BarBarToken: op = '||'; break;\n        }\n\n        const isBool = ['<', '>', '<=', '>=', '==', '!=', '&&', '||'].includes(op);\n        const retType = isBool ? BOOLEAN_TYPE : NUMBER_TYPE; // Simplified. Add vector support later if needed.\n        return { id: nextId(), kind: OpKind.Binary, type: retType, op, left, right } as BinaryNode;\n      }\n\n      case ts.SyntaxKind.PostfixUnaryExpression:\n      case ts.SyntaxKind.PrefixUnaryExpression: {\n        const expr = node as (ts.PostfixUnaryExpression | ts.PrefixUnaryExpression);\n        const operand = expr.operand;\n        const val = compileNode(operand, ctx);\n        if (!val) return null;\n\n        if (expr.operator === ts.SyntaxKind.PlusPlusToken || expr.operator === ts.SyntaxKind.MinusMinusToken) {\n          if (operand.kind === ts.SyntaxKind.Identifier) {\n            const name = (operand as ts.Identifier).text;\n            // Evaluate new value\n            if (val.kind === OpKind.Const && typeof (val as ConstNode).value === 'number') {\n              const v = (val as ConstNode).value;\n              const nextV = (expr.operator === ts.SyntaxKind.PlusPlusToken) ? v + 1 : v - 1;\n              const nextNode = { id: nextId(), kind: OpKind.Const, type: NUMBER_TYPE, value: nextV } as ConstNode;\n              ctx.scope.assign(name, nextNode);\n\n              return node.kind === ts.SyntaxKind.PrefixUnaryExpression ? nextNode : val;\n            } else {\n              // Runtime Increment Fallback\n              const op = (expr.operator === ts.SyntaxKind.PlusPlusToken) ? '+' : '-';\n              const one = { id: nextId(), kind: OpKind.Const, type: NUMBER_TYPE, value: 1 } as ConstNode;\n              // val is the operand (VarNode)\n              const bin = { id: nextId(), kind: OpKind.Binary, type: NUMBER_TYPE, op, left: val, right: one } as BinaryNode;\n\n              // Assign back\n              const assign = { id: nextId(), kind: OpKind.Assign, type: VOID_TYPE, target: name, value: bin, debugInfo: val.debugInfo } as AssignNode;\n              // Update scope to point to result of assignment (BinaryNode) for subsequent uses\n              // Actually, AssignNode -> void.\n              // We should map name -> bin (the result).\n              // But 'assign' node is the statement.\n              // If used as expression, we need to return 'val' (old) or 'bin' (new).\n              // For now return AssignNode (statement).\n              ctx.scope.assign(name, bin);\n\n              return assign;\n            }\n          }\n        }\n\n        // Check for standard Unary Ops\n        let op = '';\n        if (expr.operator === ts.SyntaxKind.MinusToken) op = '-';\n        else if (expr.operator === ts.SyntaxKind.ExclamationToken) op = '!';\n        else if (expr.operator === ts.SyntaxKind.TildeToken) op = '~';\n\n        if (op) {\n          // Constant Folding\n          if (val.kind === OpKind.Const) {\n            const v = (val as ConstNode).value;\n            if (op === '-' && typeof v === 'number') return { id: nextId(), kind: OpKind.Const, type: NUMBER_TYPE, value: -v } as ConstNode;\n            if (op === '!' && (typeof v === 'boolean' || typeof v === 'number')) return { id: nextId(), kind: OpKind.Const, type: BOOLEAN_TYPE, value: !v } as ConstNode;\n            // Tilde usually number\n            if (op === '~' && typeof v === 'number') return { id: nextId(), kind: OpKind.Const, type: NUMBER_TYPE, value: ~v } as ConstNode;\n          }\n          return { id: nextId(), kind: OpKind.Unary, type: val.type, op, operand: val } as any; // Cast as any if UnaryNode not imported yet locally\n        }\n\n        return val;\n      }\n\n      case ts.SyntaxKind.ParenthesizedExpression: return compileNode((node as ts.ParenthesizedExpression).expression, ctx);\n\n      case ts.SyntaxKind.ObjectLiteralExpression: {\n        const obj = node as ts.ObjectLiteralExpression;\n        const fields: Record<string, IRNode> = {};\n        const fieldTypes: Record<string, DataType> = {};\n        let allConst = true;\n        for (const prop of obj.properties) {\n          if (prop.kind === ts.SyntaxKind.PropertyAssignment) {\n            const name = (prop.name as ts.Identifier).text;\n            const val = compileNode(prop.initializer, ctx);\n            if (val) {\n              fields[name] = val;\n              fieldTypes[name] = val.type;\n              if (val.kind !== OpKind.Const) allConst = false;\n            }\n          }\n        }\n        if (allConst) {\n          const valObj: any = {};\n          for (const k in fields) valObj[k] = (fields[k] as ConstNode).value;\n          return { id: nextId(), kind: OpKind.Const, type: { kind: DataTypeKind.Struct, fields: fieldTypes }, value: valObj } as ConstNode;\n        }\n        return { id: nextId(), kind: OpKind.Struct, type: { kind: DataTypeKind.Struct, fields: fieldTypes }, fields } as StructNode;\n      }\n\n      case ts.SyntaxKind.ArrayLiteralExpression: {\n        const arr = node as ts.ArrayLiteralExpression;\n        const elements: IRNode[] = [];\n        let elementType: DataType = ANY_TYPE;\n        let allConst = true;\n        for (const elem of arr.elements) {\n          const val = compileNode(elem, ctx);\n          if (val) {\n            elements.push(val);\n            if (elements.length === 1) elementType = val.type;\n            if (val.kind !== OpKind.Const) allConst = false;\n          }\n        }\n        if (allConst) {\n          const valArr = elements.map(e => (e as ConstNode).value);\n          if (elementType.kind === DataTypeKind.Any && valArr.length > 0) {\n            const firstT = getPrimitiveType(valArr[0]);\n            if (firstT) elementType = firstT;\n          }\n          return { id: nextId(), kind: OpKind.Const, type: { kind: DataTypeKind.Array, elementType, length: valArr.length }, value: valArr } as ConstNode;\n        }\n        return { id: nextId(), kind: OpKind.Array, type: { kind: DataTypeKind.Array, elementType, length: elements.length }, elements } as ArrayNode;\n      }\n\n      case ts.SyntaxKind.NullKeyword: {\n        return { id: nextId(), kind: OpKind.Const, type: { kind: DataTypeKind.Primitive, name: 'null' }, value: null } as ConstNode;\n      }\n      case ts.SyntaxKind.UndefinedKeyword: {\n        return { id: nextId(), kind: OpKind.Const, type: { kind: DataTypeKind.Primitive, name: 'undefined' }, value: undefined } as ConstNode;\n      }\n\n      case ts.SyntaxKind.PropertyAccessExpression: {\n        const prop = node as ts.PropertyAccessExpression;\n        const obj = compileNode(prop.expression, ctx);\n        const name = prop.name.text;\n        if (!obj) return null;\n\n        // Constant Folding for Structs\n        if (obj.kind === OpKind.Struct) {\n          const struct = obj as StructNode;\n          if (struct.fields[name]) return struct.fields[name];\n        }\n\n        // Constant Folding for Const Objects\n        if (obj.kind === OpKind.Const && typeof (obj as ConstNode).value === 'object' && (obj as ConstNode).value !== null) {\n          const val = (obj as ConstNode).value[name];\n          if (val !== undefined) {\n            const type = getPrimitiveType(val) || ANY_TYPE;\n            return { id: nextId(), kind: OpKind.Const, type, value: val } as ConstNode;\n          }\n        }\n\n        // Resolve Type if Struct\n        let type: DataType = ANY_TYPE;\n        if (obj.type.kind === DataTypeKind.Struct) {\n          const sType = obj.type as StructType;\n          if (sType.fields[name]) type = sType.fields[name];\n        }\n\n        // Handle Array.length\n        if (obj.type.kind === DataTypeKind.Array && name === 'length') {\n          return {\n            id: nextId(),\n            kind: OpKind.Intrinsic,\n            type: NUMBER_TYPE,\n            library: 'Array',\n            method: 'length',\n            args: [obj]\n          } as IntrinsicNode;\n        }\n\n        return { id: nextId(), kind: OpKind.PropAccess, type, object: obj, property: name } as PropAccessNode;\n      }\n\n      case ts.SyntaxKind.ElementAccessExpression: {\n        const access = node as ts.ElementAccessExpression;\n        const obj = compileNode(access.expression, ctx);\n        const index = compileNode(access.argumentExpression, ctx);\n        if (!obj || !index) return null;\n\n        // Constant Folding for Arrays\n        const idxConst = index.kind === OpKind.Const ? (index as ConstNode).value : undefined;\n        if (typeof idxConst === 'number') {\n          if (obj.kind === OpKind.Array) {\n            const arr = obj as ArrayNode;\n            if (arr.elements[idxConst]) return arr.elements[idxConst];\n          }\n          if (obj.kind === OpKind.Const && Array.isArray((obj as ConstNode).value)) {\n            const val = (obj as ConstNode).value[idxConst];\n            if (val !== undefined) {\n              const type = getPrimitiveType(val) || ANY_TYPE;\n              return { id: nextId(), kind: OpKind.Const, type, value: val } as ConstNode;\n            }\n          }\n        }\n\n        // Infer Type\n        let type: DataType = ANY_TYPE;\n        if (obj.type.kind === DataTypeKind.Array) {\n          type = (obj.type as any).elementType || ANY_TYPE;\n        }\n\n        return { id: nextId(), kind: OpKind.IndexAccess, type, object: obj, index } as IndexAccessNode;\n      }\n\n      case ts.SyntaxKind.InterfaceDeclaration: {\n        const decl = node as ts.InterfaceDeclaration;\n        const name = decl.name.text;\n        const fields: Record<string, DataType> = {};\n        decl.members.forEach(m => {\n          if (ts.isPropertySignature(m) && m.name) {\n            const fieldName = (m.name as ts.Identifier).text || \"unknown\"; // Handle non-ident?\n            let fieldType = m.type ? resolveType(m.type, ctx) : ANY_TYPE;\n            if (m.questionToken) {\n              // Optional field -> Union(T, Undefined)\n              const undefinedType: PrimitiveType = { kind: DataTypeKind.Primitive, name: 'undefined' };\n              fieldType = { kind: DataTypeKind.Union, types: [fieldType, undefinedType] };\n            }\n            fields[fieldName] = fieldType;\n          }\n        });\n        const structType: StructType = { kind: DataTypeKind.Struct, name, fields };\n        ctx.scope.declareType(name, structType);\n\n        return null; // Statements processing skips null\n      }\n\n      case ts.SyntaxKind.FunctionDeclaration: {\n        const decl = node as ts.FunctionDeclaration;\n        if (decl.name) ctx.scope.declareFunction(decl.name.text, decl);\n        return { id: nextId(), kind: OpKind.Const, type: VOID_TYPE, value: null } as ConstNode;\n      }\n\n      case ts.SyntaxKind.ArrowFunction:\n      case ts.SyntaxKind.FunctionExpression: {\n        const func = node as ts.FunctionLikeDeclaration;\n        // Capture closure\n        return {\n          id: nextId(),\n          kind: OpKind.Const,\n          type: ANY_TYPE,\n          value: { node: func, closure: ctx.scope.snapshot() }\n        } as ConstNode;\n      }\n\n      case ts.SyntaxKind.BreakStatement:\n        return { id: nextId(), kind: OpKind.Break, type: VOID_TYPE } as any;\n\n      case ts.SyntaxKind.WhileStatement: {\n        const w = node as ts.WhileStatement;\n        // Invalidate scopes BEFORE condition, because loop backedge affects values.\n        ctx.scope.invalidateAll();\n\n        const cond = compileNode(w.expression, ctx);\n        if (!cond) return null;\n\n        const bodyRes = compileNode(w.statement, ctx);\n        let body: BlockNode;\n        if (bodyRes && bodyRes.kind === OpKind.Block) body = bodyRes as BlockNode;\n        else body = { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements: bodyRes ? [bodyRes] : [] } as BlockNode;\n\n        // Invalidate again after loop\n        ctx.scope.invalidateAll();\n\n        return { id: nextId(), kind: OpKind.While, type: VOID_TYPE, condition: cond, body } as WhileNode;\n      }\n\n      case ts.SyntaxKind.ReturnStatement: {\n        const ret = node as ts.ReturnStatement;\n        let value: IRNode | null = null;\n        if (ret.expression) value = compileNode(ret.expression, ctx);\n        return { id: nextId(), kind: OpKind.Return, type: value?.type || VOID_TYPE, value: value || { id: 'void', kind: OpKind.Const, type: VOID_TYPE, value: null } } as ReturnNode;\n      }\n\n      case ts.SyntaxKind.IfStatement: {\n        // (Simplified If Logic - assuming no recursion for brevity in restore if possible, but actually needed for Ex 12?)\n        // I'll restore standard If logic.\n        const ifStmt = node as ts.IfStatement;\n        const condition = compileNode(ifStmt.expression, ctx);\n        if (!condition) return null;\n        if (condition.kind === OpKind.Const) {\n          if ((condition as ConstNode).value) return compileNode(ifStmt.thenStatement, ctx);\n          else return ifStmt.elseStatement ? compileNode(ifStmt.elseStatement, ctx) : { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements: [] } as BlockNode;\n        }\n        // Branching\n        const parentScope = ctx.scope;\n        const thenScope = parentScope.fork();\n        ctx.scope = thenScope;\n        let thenRes = compileNode(ifStmt.thenStatement, ctx);\n        let thenBlock: BlockNode;\n        if (thenRes && thenRes.kind === OpKind.Block) thenBlock = thenRes as BlockNode;\n        else thenBlock = { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements: thenRes ? [thenRes] : [] } as BlockNode;\n\n        let elseBlock: BlockNode | undefined = undefined;\n        if (ifStmt.elseStatement) {\n          const elseScope = parentScope.fork();\n          ctx.scope = elseScope;\n          const e = compileNode(ifStmt.elseStatement, ctx);\n          if (e && e.kind === OpKind.Block) elseBlock = e as BlockNode;\n          else elseBlock = { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements: e ? [e] : [] } as BlockNode;\n\n          ctx.scope = parentScope;\n          mergeScopes(parentScope, thenScope, elseScope, condition);\n        } else {\n          ctx.scope = parentScope;\n          mergeOneWay(parentScope, thenScope, condition);\n        }\n        ctx.scope = parentScope;\n        return { id: nextId(), kind: OpKind.If, type: VOID_TYPE, condition, thenBlock, elseBlock } as IfNode;\n      }\n\n      case ts.SyntaxKind.ForStatement: {\n        const loop = node as ts.ForStatement;\n\n        // Prepare Scope for Loop Variables (e.g. let i = 0)\n        const parentScope = ctx.scope;\n        const loopScope = parentScope.extend(); // Use extend (nested) instead of fork (branch) to allow side-effects\n        ctx.scope = loopScope;\n\n        // 1. Compile Init\n        const init = loop.initializer ? compileNode(loop.initializer, ctx) : null;\n\n        // 2. Check Condition for Constness (First Pass)\n        let cond = loop.condition ? compileNode(loop.condition, ctx) : null;\n        const isConst = cond && cond.kind === OpKind.Const;\n\n        if (!isConst) {\n          // --- Runtime Loop Fallback ---\n\n          // Invalidate constants to force VarNode usage\n          ctx.scope.invalidateAll();\n\n          // Re-compile condition with invalidated scope\n          const rtCond = loop.condition ? compileNode(loop.condition, ctx) : { id: nextId(), kind: OpKind.Const, type: BOOLEAN_TYPE, value: true } as ConstNode;\n          const body = compileNode(loop.statement, ctx);\n          const incr = loop.incrementor ? compileNode(loop.incrementor, ctx) : null;\n\n          const whileStmts: IRNode[] = [];\n          if (body) {\n            if (body.kind === OpKind.Block) whileStmts.push(...(body as BlockNode).statements);\n            else whileStmts.push(body);\n          }\n          if (incr) whileStmts.push(incr);\n\n          const whileNode: WhileNode = {\n            id: nextId(),\n            kind: OpKind.While,\n            type: VOID_TYPE,\n            condition: rtCond!,\n            body: { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements: whileStmts } as BlockNode\n          };\n\n          const resultStmts: IRNode[] = [];\n          if (init) resultStmts.push(init);\n          resultStmts.push(whileNode);\n\n          ctx.scope = parentScope;\n          return { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements: resultStmts } as BlockNode;\n\n        } else {\n          // --- Unrolling Logic (Original) ---\n          // Note: init already compiled inside loopScope, but unrolling logic might ignore the IR node if relying on scope state.\n          // However, unrolling expects 'loops=0' start.\n          // Usually initializer 'let i = 0' sets 'i' in scope to '0'.\n\n          const statements: IRNode[] = [];\n\n          let loops = 0;\n          while (loops < 100) {\n            // Re-eval condition\n            const c = loop.condition ? compileNode(loop.condition, ctx) : null;\n            if (c && c.kind === OpKind.Const && !(c as ConstNode).value) break;\n\n            const body = compileNode(loop.statement, ctx);\n            if (body) {\n              statements.push(body);\n            }\n            if (loop.incrementor) {\n              compileNode(loop.incrementor, ctx);\n            }\n            loops++;\n          }\n          ctx.scope = parentScope;\n          return { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements } as BlockNode;\n        }\n      }\n      default:\n        // Capture unsupported syntax\n        ctx.addWarning(`Unsupported syntax kind: ${ts.SyntaxKind[node.kind]}`, node);\n        return null;\n    }\n  } finally {\n    ctx.depth--;\n  }\n}\n\n// Helpers\nlet nodeIdCounter = 0;\nfunction nextId() { return `ir${nodeIdCounter++}`; }\n// Helper to resolve TS TypeNode to DataType\nfunction resolveType(typeNode: ts.TypeNode, ctx: CompilerContext): DataType {\n  if (typeNode.kind === ts.SyntaxKind.NumberKeyword) return NUMBER_TYPE;\n  if (typeNode.kind === ts.SyntaxKind.BooleanKeyword) return BOOLEAN_TYPE;\n  if (typeNode.kind === ts.SyntaxKind.StringKeyword) return STR_TYPE;\n  if (typeNode.kind === ts.SyntaxKind.VoidKeyword) return VOID_TYPE;\n  if (typeNode.kind === ts.SyntaxKind.UndefinedKeyword) return { kind: DataTypeKind.Primitive, name: 'undefined' } as PrimitiveType;\n  if (typeNode.kind === ts.SyntaxKind.NullKeyword) return { kind: DataTypeKind.Primitive, name: 'null' } as PrimitiveType;\n\n  if (ts.isArrayTypeNode(typeNode)) {\n    const elType = resolveType(typeNode.elementType, ctx);\n    return { kind: DataTypeKind.Array, elementType: elType };\n  }\n  if (ts.isLiteralTypeNode(typeNode)) {\n    if (typeNode.literal.kind === ts.SyntaxKind.NullKeyword) return { kind: DataTypeKind.Primitive, name: 'null' } as PrimitiveType;\n    // Other literals (true/false/numbers)\n    // LiteralType in IR?\n  }\n\n  if (ts.isUnionTypeNode(typeNode)) {\n    const types = typeNode.types.map(t => resolveType(t, ctx));\n    // check if just null/undefined logic?\n    // flattening unions?\n    return { kind: DataTypeKind.Union, types };\n  }\n\n  if (ts.isTypeLiteralNode(typeNode)) {\n    const fields: Record<string, DataType> = {};\n    typeNode.members.forEach(m => {\n      if (ts.isPropertySignature(m) && m.name) {\n        const fieldName = (m.name as ts.Identifier).text;\n        let fieldType = m.type ? resolveType(m.type, ctx) : ANY_TYPE;\n        if (m.questionToken) {\n          const undefinedType: PrimitiveType = { kind: DataTypeKind.Primitive, name: 'undefined' };\n          fieldType = { kind: DataTypeKind.Union, types: [fieldType, undefinedType] };\n        }\n        fields[fieldName] = fieldType;\n      }\n    });\n    return { kind: DataTypeKind.Struct, fields };\n  }\n\n  // Handle TypeReference (structs, generics)\n  if (ts.isTypeReferenceNode(typeNode)) {\n    const name = (typeNode.typeName as ts.Identifier).text;\n    if (name === 'Array') {\n      if (typeNode.typeArguments && typeNode.typeArguments.length > 0) {\n        return { kind: DataTypeKind.Array, elementType: resolveType(typeNode.typeArguments[0], ctx) };\n      }\n    }\n    // Lookup in scope\n    const type = ctx.scope.resolveType(name);\n    if (type) return type;\n    // Fallback/Warning?\n    // console.warn(`Unresolved type: ${name}`);\n\n  }\n  return ANY_TYPE;\n}\n\nconst STR_TYPE: PrimitiveType = { kind: DataTypeKind.Primitive, name: 'string' }; // Need to define if not exists?\nconst VOID_TYPE: PrimitiveType = { kind: DataTypeKind.Primitive, name: 'void' };\nconst NUMBER_TYPE: PrimitiveType = { kind: DataTypeKind.Primitive, name: 'number' };\nconst BOOLEAN_TYPE: PrimitiveType = { kind: DataTypeKind.Primitive, name: 'boolean' };\nconst ANY_TYPE: DataType = { kind: DataTypeKind.Any };\nconst GENERIC_INST = (base: string, args: DataType[]) => ({ kind: DataTypeKind.GenericInstantiation, base, args } as any);\n\nfunction getPrimitiveType(val: any): PrimitiveType | null {\n  if (typeof val === 'number') return NUMBER_TYPE;\n  if (typeof val === 'boolean') return BOOLEAN_TYPE;\n  if (typeof val === 'string') return STR_TYPE;\n  return null;\n}\n\nfunction mergeScopes(parent: Scope, branchA: Scope, branchB: Scope, condition: IRNode): void {\n  // implementation\n  const distinctKeys = new Set([...branchA.values.keys(), ...branchB.values.keys()]);\n  for (const key of distinctKeys) {\n    const valA = branchA.values.get(key) || parent.resolveValue(key) || parent.resolveAlias(key);\n    const valB = branchB.values.get(key) || parent.resolveValue(key) || parent.resolveAlias(key);\n    if (valA && valB && valA !== valB) {\n      if (valA.kind === OpKind.Const && valB.kind === OpKind.Const && (valA as ConstNode).value === (valB as ConstNode).value) {\n        parent.assign(key, valA);\n        continue;\n      }\n      const parentVal = parent.resolveValue(key) || parent.resolveAlias(key);\n      if (valA === parentVal && valB === parentVal) continue;\n      const phi: PhiNode = { id: nextId(), kind: OpKind.Phi, type: valA.type, condition, trueValue: valA, falseValue: valB };\n      parent.assign(key, phi);\n    }\n  }\n}\nfunction mergeOneWay(parent: Scope, branchA: Scope, condition: IRNode): void {\n  const keys = new Set([...branchA.values.keys()]);\n  for (const key of keys) {\n    const valA = branchA.values.get(key)!;\n    const parentVal = parent.resolveValue(key) || parent.resolveAlias(key);\n    if (valA !== parentVal && parentVal) {\n      const phi: PhiNode = { id: nextId(), kind: OpKind.Phi, type: valA.type, condition, trueValue: valA, falseValue: parentVal };\n      parent.assign(key, phi);\n    }\n  }\n}\n\nexport function compileToIR(src: string | ts.SourceFile, globalInputs: Record<string, DataType> = {}): IRGraph {\n  let sourceFile: ts.SourceFile;\n  if (typeof src === 'string') {\n    sourceFile = ts.createSourceFile(\"expr.ts\", src, ts.ScriptTarget.ES2015, true);\n  } else {\n    sourceFile = src;\n  }\n  const ctx = new CompilerContext(sourceFile);\n\n  // 1. Capture TS Parser Diagnostics\n  const tsDiagnostics = (sourceFile as any).parseDiagnostics || [];\n  // We can try getting some info. createSourceFile is limited.\n  // But syntactic errors (parsing) are available.\n\n  for (const diag of tsDiagnostics) {\n    const message = typeof diag.messageText === 'string' ? diag.messageText : diag.messageText.messageText; // Simplify\n    // Calculate range\n    let range;\n    if (diag.start !== undefined && diag.length !== undefined) {\n      const start = sourceFile.getLineAndCharacterOfPosition(diag.start);\n      const end = sourceFile.getLineAndCharacterOfPosition(diag.start + diag.length);\n      range = {\n        startLineNumber: start.line + 1,\n        startColumn: start.character + 1,\n        endLineNumber: end.line + 1,\n        endColumn: end.character + 1\n      };\n    }\n    ctx.diagnostics.push({\n      message: `TS Error: ${message}`,\n      severity: DiagnosticSeverity.Error,\n      source: 'ts-parser',\n      range\n    });\n  }\n\n  // Pre-declare Globals\n  for (const [key, type] of Object.entries(globalInputs)) {\n    ctx.scope.declare(key, type);\n    ctx.scope.set(key, { id: nextId(), kind: OpKind.Var, type, name: key } as VarNode);\n  }\n\n\n\n  let rootBlock: BlockNode;\n  try {\n    const result = compileNode(sourceFile, ctx);\n    if (result && result.kind === OpKind.Block) {\n      rootBlock = result as BlockNode;\n    } else if (result) {\n      rootBlock = { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements: [result] } as BlockNode;\n    } else {\n      rootBlock = { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements: [] } as BlockNode;\n    }\n  } catch (e: any) {\n    // Catch-all for compiler crashes -> Error Diagnostic\n    ctx.addError(`Internal Compiler Error: ${e.message}`);\n    // Return partial or empty graph\n    rootBlock = { id: nextId(), kind: OpKind.Block, type: VOID_TYPE, statements: [] } as BlockNode;\n  }\n\n  // Merge Global Inputs (passed in) with Declared Inputs (from source)\n  const combinedInputs = { ...globalInputs, ...ctx.declaredInputs };\n\n  return { root: rootBlock, diagnostics: ctx.diagnostics, inputs: combinedInputs };\n}\n","import { IRGraph, IRNode, OpKind, DataType, DataTypeKind, BlockNode, IfNode, BinaryNode, ConstNode, VarNode, VarDeclNode, AssignNode, ReturnNode, IntrinsicNode, ArrayNode, StructNode, PropAccessNode, PrimitiveType, IndexAccessNode, StructType, PhiNode, UnaryNode, WhileNode, BreakNode, SetPropNode, SetIndexNode } from './ir-types';\n\nexport interface WGSLGenOptions {\n  inputs: Record<string, DataType>;\n  outputType?: DataType;\n}\n\nconst F32 = 'f32';\nconst I32 = 'i32';\nconst BOOL = 'bool';\n\n// Helper to sanitize names\nfunction safeName(name: string) {\n  return name.replace(/[^a-zA-Z0-9_]/g, '_');\n}\n\n// Struct Collection\nfunction collectStructs(ir: IRGraph, inputs: Record<string, DataType>): Map<string, StructType> {\n  const structs = new Map<string, StructType>();\n\n  function visitType(t: DataType) {\n    if (!t) return;\n    if (t.kind === DataTypeKind.Struct) {\n      const s = t as StructType;\n      const name = getStructName(s);\n      if (!structs.has(name)) {\n        structs.set(name, s);\n        Object.values(s.fields).forEach(visitType);\n      }\n    } else if (t.kind === DataTypeKind.Array) {\n      visitType((t as any).elementType);\n    }\n  }\n\n  Object.values(inputs).forEach(visitType);\n  visitType(ANY_OUTPUT_TYPE(ir));\n\n  const stack = [ir.root];\n  while (stack.length) {\n    const n = stack.pop()!;\n    if (!n || typeof n !== 'object') continue;\n    if ((n as any).type) visitType((n as any).type);\n\n    if (n.kind === OpKind.Block) stack.push(...(n as BlockNode).statements);\n    else if (n.kind === OpKind.If) {\n      stack.push((n as IfNode).condition, (n as IfNode).thenBlock);\n      if ((n as IfNode).elseBlock) stack.push((n as IfNode).elseBlock!);\n    }\n    else if (n.kind === OpKind.While) stack.push((n as WhileNode).condition, (n as WhileNode).body);\n  }\n  return structs;\n}\n\nfunction getStructName(s: StructType): string {\n  if (s.name) return s.name;\n  const keys = Object.keys(s.fields).sort();\n  return `Struct_${keys.join('_')}`;\n}\n\nfunction typeToWGSL(type: DataType): string {\n  switch (type.kind) {\n    case DataTypeKind.Primitive: {\n      const p = type as PrimitiveType;\n      if (p.name === 'number') return F32;\n      if (p.name === 'boolean') return BOOL;\n      if (p.name === 'void') return 'void';\n      return F32;\n    }\n    case DataTypeKind.Array: {\n      const inner = (type as any).elementType;\n      const len = (type as any).length;\n      if (typeof len === 'number') {\n        const innerType = typeToWGSL(inner);\n        // Vector Specialization: array<f32, N> -> vecN<f32> where N in [2, 3, 4]\n        if (innerType === F32 && (len === 2 || len === 3 || len === 4)) {\n          return `vec${len}<f32>`;\n        }\n        return `array<${innerType}, ${len}>`;\n      }\n      return `array<${typeToWGSL(inner)}>`; // Runtime-sized\n    }\n    case DataTypeKind.Struct: return getStructName(type as StructType);\n    default: return F32;\n  }\n}\n\nfunction ANY_OUTPUT_TYPE(ir: IRGraph): DataType {\n  return { kind: DataTypeKind.Primitive, name: 'void' } as any;\n}\n\nexport function generateWGSL(ir: IRGraph, options: WGSLGenOptions): string {\n  const lines: string[] = [];\n  lines.push('diagnostic(off, derivative_uniformity);');\n  lines.push('');\n  const structs = collectStructs(ir, options.inputs);\n\n  structs.forEach((s, name) => {\n    lines.push(`struct ${name} {`);\n    const keys = Object.keys(s.fields).sort();\n    if (keys.length === 0) {\n      lines.push('    _dummy: f32,');\n    } else {\n      keys.forEach(k => {\n        lines.push(`    ${k}: ${typeToWGSL(s.fields[k])},`);\n      });\n    }\n    lines.push('};');\n    lines.push('');\n  });\n\n  lines.push('struct Input {');\n  const inputEntries = Object.entries(options.inputs);\n  // Sort inputs: Primitives first, Arrays last (Runtime array restriction)\n  // Also validate max 1 array\n  const arrays = inputEntries.filter(([k, v]) => v.kind === DataTypeKind.Array);\n  if (arrays.length > 1) {\n    // TODO: Multiple bindings?\n    // For now, warn or error. simple-expr-v2 uses single buffer.\n    // We'll proceed but it will fail compilation if multiple arrays.\n  }\n  const sortedInputs = inputEntries.sort((a, b) => {\n    const aIsArray = a[1].kind === DataTypeKind.Array;\n    const bIsArray = b[1].kind === DataTypeKind.Array;\n    if (aIsArray && !bIsArray) return 1;\n    if (!aIsArray && bIsArray) return -1;\n    return 0;\n  });\n\n  if (sortedInputs.length === 0) {\n    lines.push('    _dummy: f32,');\n  } else {\n    for (const [k, v] of sortedInputs) {\n      lines.push(`    ${k}: ${typeToWGSL(v)},`);\n    }\n  }\n  lines.push('};');\n  lines.push('');\n\n  lines.push('struct Output {');\n  if (options.outputType) {\n    lines.push(`    result: ${typeToWGSL(options.outputType)},`);\n  } else {\n    lines.push(`    result: f32,`);\n  }\n  lines.push('};');\n  lines.push('');\n\n  lines.push('@group(0) @binding(0) var<storage, read_write> input: Input;');\n  lines.push('@group(0) @binding(1) var<storage, read_write> output: Output;');\n  lines.push('');\n\n  lines.push('@compute @workgroup_size(1)');\n  lines.push('fn main() {');\n  // Force bindings to be active to prevent dead-code stripping\n  lines.push('    _ = &input;');\n  lines.push('    _ = &output;');\n  lines.push(emitBlock(ir.root as BlockNode, 1, options));\n  lines.push('}');\n\n  return lines.join('\\n');\n}\n\nfunction emitBlock(block: BlockNode, indent: number, options: WGSLGenOptions): string {\n  const lines: string[] = [];\n  const spaces = '    '.repeat(indent);\n\n  for (const stmt of block.statements) {\n    if (stmt.kind === OpKind.Return) {\n      const r = stmt as ReturnNode;\n      let valCode = emitNode(r.value, options, options.outputType);\n\n      // Heuristic: If we are returning a Boolean to an f32 output, cast it.\n      // This is needed because 'select(0,1,bool)' is how we output booleans to storage buffers.\n      // And we often default outputType to 'number' (f32) in tests.\n      if (options.outputType &&\n        options.outputType.kind === DataTypeKind.Primitive &&\n        (options.outputType as PrimitiveType).name === 'number') {\n\n        if (isBooleanExpr(r.value, options)) {\n          valCode = `select(0.0, 1.0, ${valCode})`;\n        }\n      }\n\n      lines.push(`${spaces}output.result = ${valCode};`);\n      lines.push(`${spaces}return;`);\n      continue;\n    }\n\n    const code = emitNode(stmt, options);\n    if (code) {\n      if (stmt.kind === OpKind.If || stmt.kind === OpKind.While || stmt.kind === OpKind.Block) {\n        lines.push(code.includes('\\n') ? code.split('\\n').map((l, i) => (i === 0 ? spaces : spaces) + l).join('\\n') : `${spaces}${code}`);\n      } else if (stmt.kind !== OpKind.Const) {\n        // Skip Const statements (e.g. hoisted function decls resulting in 0.0;)\n        lines.push(`${spaces}${code};`);\n      }\n    }\n  }\n  return lines.join('\\n');\n}\n\nfunction emitVal(value: any, type: DataType, options: WGSLGenOptions, expectedType?: DataType): string {\n  if (expectedType && expectedType.kind === type.kind) {\n    // Prefer expectedType if it has a name and current type doesn't\n    if (type.kind === DataTypeKind.Struct) {\n      const sType = type as StructType;\n      const eType = expectedType as StructType;\n      if (!sType.name && eType.name) {\n        type = eType;\n      }\n    }\n    // Arrays?\n  }\n\n  if (typeof value === 'number') {\n    const s = String(value);\n    return s.includes('.') ? s : s + '.0';\n  }\n  if (typeof value === 'boolean') return String(value);\n  if (Array.isArray(value)) {\n    const inner = (type as any).elementType;\n    const args = value.map((v: any) => emitVal(v, inner, options, inner)).join(', ');\n    return `${typeToWGSL(type)}(${args})`;\n  }\n  if (typeof value === 'object' && value !== null && type.kind === DataTypeKind.Struct) {\n    const name = getStructName(type as StructType);\n    const keys = Object.keys((type as StructType).fields).sort();\n    const args = keys.map(k => emitVal(value[k], (type as StructType).fields[k], options, (type as StructType).fields[k])).join(', ');\n    return `${name}(${args})`;\n  }\n  return '0.0';\n}\n\n\nfunction isBooleanExpr(node: IRNode, options: WGSLGenOptions): boolean {\n  if (node.kind === OpKind.Const) {\n    return typeof (node as ConstNode).value === 'boolean';\n  }\n  if (node.kind === OpKind.Binary) {\n    const b = node as BinaryNode;\n    if (['==', '!=', '<', '>', '<=', '>='].includes(b.op)) return true; // Comparison always returns bool\n    if (['&&', '||'].includes(b.op)) {\n      // Logic ops are bool ONLY if both operands are bool (WGSL Strictness)\n      // If mixed, we treat as coalescing float ops.\n      return isBooleanExpr(b.left, options) && isBooleanExpr(b.right, options);\n    }\n    return false; // +, -, *, /\n  }\n  if (node.kind === OpKind.Unary) {\n    return (node as UnaryNode).op === '!';\n  }\n  if (node.kind === OpKind.Var) {\n    const v = node as VarNode;\n    // Check input definition\n    if (options.inputs[v.name]) {\n      const t = options.inputs[v.name];\n      if (t.kind === DataTypeKind.Primitive && (t as PrimitiveType).name === 'boolean') return true;\n    }\n    // Fallback to node type if available\n  }\n  if (node.type && node.type.kind === DataTypeKind.Primitive && (node.type as PrimitiveType).name === 'boolean') {\n    return true;\n  }\n  return false;\n}\n\n// Helper to ensure expression results in f32\nfunction emitValueAsFloat(node: IRNode, options: WGSLGenOptions): string {\n  if (isBooleanExpr(node, options)) {\n    return `select(0.0, 1.0, ${emitNode(node, options)})`;\n  }\n  // Attempt standard emit\n  const code = emitNode(node, options);\n  // If it looks like a bool constant \"true\"/\"false\" or comparison, we might have missed it in isBooleanExpr?\n  // But assumes implicit is float if not bool.\n  return code;\n}\n\n// Helper to ensure expression results in bool\nfunction emitValueAsBool(node: IRNode, options: WGSLGenOptions): string {\n  if (isBooleanExpr(node, options)) {\n    return emitNode(node, options);\n  }\n  // Assume float, check != 0.0\n  return `(${emitNode(node, options)} != 0.0)`;\n}\n\nfunction emitNode(node: IRNode, options: WGSLGenOptions, expectedType?: DataType): string {\n  switch (node.kind) {\n    case OpKind.Const: {\n      const c = node as ConstNode;\n      if (typeof c.value === 'number') {\n        const s = String(c.value);\n        return s.includes('.') ? s : s + '.0';\n      }\n      if (typeof c.value === 'boolean') return String(c.value);\n      // Objects/Arrays\n      if (typeof c.value === 'object' || Array.isArray(c.value)) {\n        return emitVal(c.value, c.type, options, expectedType);\n      }\n      return '0.0';\n    }\n    case OpKind.Var: {\n      const v = node as VarNode;\n      if (options.inputs[v.name]) return `input.${v.name}`;\n      return safeName(v.name);\n    }\n    case OpKind.Binary: {\n      const b = node as BinaryNode;\n      // Handle Logic Ops with JS Semantics (Coalescing)\n      if (b.op === '&&' || b.op === '||') {\n        // If either operand is non-boolean (number), treat as float selection\n        const leftBool = isBooleanExpr(b.left, options);\n        const rightBool = isBooleanExpr(b.right, options);\n\n        if (!leftBool || !rightBool) {\n          // Mixed or both numbers. Convert all to float and use select.\n          const l = emitValueAsFloat(b.left, options);\n          const r = emitValueAsFloat(b.right, options);\n\n          // JS Semantics:\n          // OR: a || b -> if a truthy return a, else b.\n          // WGSL select(falseVal, trueVal, cond).\n          // cond = a != 0.0\n          // select(b, a, a!=0)\n          if (b.op === '||') return `select(${r}, ${l}, ${l} != 0.0)`;\n\n          // AND: a && b -> if a truthy return b, else a.\n          // cond = a != 0.0\n          // select(a, b, a!=0)\n          if (b.op === '&&') return `select(${l}, ${r}, ${l} != 0.0)`;\n        }\n        // Fallthrough for purely boolean logic\n      }\n      return `(${emitNode(b.left, options)} ${b.op} ${emitNode(b.right, options)})`;\n    }\n    case OpKind.Unary: {\n      const u = node as UnaryNode;\n      if (u.op === '!') return `!${emitValueAsBool(u.operand, options)}`;\n      return `${u.op}${emitNode(u.operand, options)}`;\n    }\n    case OpKind.Assign: {\n      const a = node as AssignNode;\n      // Assign needs type match. We assume target is inferred correctly.\n      return `${safeName(a.target)} = ${emitNode(a.value, options)}`;\n    }\n    case OpKind.VarDecl: {\n      const d = node as VarDeclNode;\n      // OPTIMIZATION/FIX: If we are declaring a variable for a Reference Type (Struct/Array)\n      // and the initializer is an L-Value (Var, Prop, Index), use a POINTER ('let x = &init')\n      // instead of a COPY ('var x = init').\n      const isRefType = d.type && (d.type.kind === DataTypeKind.Struct || d.type.kind === DataTypeKind.Array);\n      const isLVal = d.init && (d.init.kind === OpKind.Var || d.init.kind === OpKind.PropAccess || d.init.kind === OpKind.IndexAccess);\n\n      if (isRefType && isLVal) {\n        return `let ${safeName(d.name)} = &${emitNode(d.init!, options, d.type)}`;\n      }\n\n      // Infer Array Length from Init if available\n      if (d.type && d.type.kind === DataTypeKind.Array && typeof (d.type as any).length === 'undefined' && d.init && d.init.kind === OpKind.Array) {\n        (d.type as any).length = (d.init as ArrayNode).elements.length;\n      }\n      // Also if init is Const Array\n      if (d.type && d.type.kind === DataTypeKind.Array && typeof (d.type as any).length === 'undefined' && d.init && d.init.kind === OpKind.Const && Array.isArray((d.init as ConstNode).value)) {\n        (d.type as any).length = (d.init as ConstNode).value.length;\n      }\n\n      let typeStr = typeToWGSL(d.type || { kind: DataTypeKind.Primitive, name: 'number' } as any);\n      let init = d.init ? ` = ${emitNode(d.init, options, d.type)}` : '';\n      // If init is boolean and target is f32 (e.g. inferred from 'number'), we should cast?\n      // But VarDecl type comes from TS inference which might say 'boolean | number'.\n      // For now, trust emitNode or rely on WGSL error if types mismatch,\n      // OR upgrade VarDecl to auto-cast init if type is f32.\n      if (d.type && (d.type as PrimitiveType).name === 'number' && d.init && isBooleanExpr(d.init, options)) {\n        init = ` = select(0.0, 1.0, ${emitNode(d.init, options, d.type)})`;\n      }\n      return `var ${safeName(d.name)} : ${typeStr}${init}`;\n    }\n    case OpKind.While: {\n      const w = node as WhileNode;\n      // Condition must be boolean\n      return `while (${emitValueAsBool(w.condition, options)}) {\\n${emitBlock(w.body, 1, options)}\\n}`;\n    }\n    case OpKind.If: {\n      const i = node as IfNode;\n      let res = `if (${emitValueAsBool(i.condition, options)}) {\\n${emitBlock(i.thenBlock, 1, options)}\\n}`;\n      if (i.elseBlock) res += ` else {\\n${emitBlock(i.elseBlock, 1, options)}\\n}`;\n      return res;\n    }\n    // ... rest strict logical ops ...\n    case OpKind.Block: {\n      const b = node as BlockNode;\n      return `{\\n${emitBlock(b, 1, options)}\\n}`;\n    }\n    case OpKind.Intrinsic: {\n      const i = node as IntrinsicNode;\n      if (i.library === 'Array' && i.method === 'length') {\n        // Check if array is fixed size\n        const arg = i.args[0];\n        if (arg.type && arg.type.kind === DataTypeKind.Array && typeof (arg.type as any).length === 'number') {\n          return `${(arg.type as any).length}.0`; // Return constant f32\n        }\n        // Otherwise assume runtime array (storage buffer)\n        return `f32(arrayLength(&${emitNode(arg, options)}))`;\n      }\n      return `${i.method}(${i.args.map(a => emitNode(a, options)).join(', ')})`;\n    }\n    case OpKind.PropAccess: {\n      const p = node as PropAccessNode;\n      return `${emitNode(p.object, options)}.${p.property}`;\n    }\n    case OpKind.SetProp: {\n      const s = node as SetPropNode;\n      // Synthesize \"obj.prop = value\"\n      return `${emitNode(s.object, options)}.${s.property} = ${emitNode(s.value, options)}`;\n    }\n    case OpKind.SetIndex: {\n      const s = node as SetIndexNode;\n      // Synthesize \"obj[i32(idx)] = value\"\n      return `${emitNode(s.object, options)}[i32(${emitNode(s.index, options)})] = ${emitNode(s.value, options)}`;\n    }\n    case OpKind.IndexAccess: {\n      const i = node as IndexAccessNode;\n      // Synthesize \"obj[i32(idx)]\"\n      return `${emitNode(i.object, options)}[i32(${emitNode(i.index, options)})]`;\n    }\n    case OpKind.Struct: {\n      const s = node as StructNode;\n      let type = s.type;\n      if (expectedType && expectedType.kind === DataTypeKind.Struct) {\n        const eType = expectedType as StructType;\n        if (!(type as StructType).name && eType.name) type = eType;\n      }\n\n      const typeName = getStructName(type as StructType);\n      if (!typeName) return '/* Anonymous Struct */'; // Should not happen with getStructName\n\n      const fieldValues = Object.keys((type as StructType).fields).sort().map(k => {\n        // We need to match fields?\n        // Assuming s.fields has matching content.\n        // Ideally we sort by key to match Struct Definition order (alphabetical in codegen).\n        if (s.fields[k]) return emitNode(s.fields[k], options, (type as StructType).fields[k]);\n        return '0'; // Missing field?\n      });\n      return `${typeName}(${fieldValues.join(', ')})`;\n    }\n    case OpKind.Array: {\n      const a = node as ArrayNode;\n      const typeStr = typeToWGSL(a.type);\n      // If it's a vector, we use vecN(elements)\n      // typeToWGSL already helps with type name, but constructor syntax is same as array or fn call: Type(args)\n      // vec2<f32>(...) or vec2(...) ? WGSL prefers vec2(...) or vec2f(...)\n      // typeToWGSL returns 'vec2<f32>'. 'vec2<f32>(1.0, 2.0)' is valid.\n      return `${typeStr}(${a.elements.map(e => emitNode(e, options, (a.type as any).elementType)).join(', ')})`;\n    }\n    case OpKind.Break: return 'break;';\n    default: return `/* Unknown ${node.kind} */`;\n  }\n}\n"],"names":["Scope","parent","isBranchScope","copy","name","type","value","node","current","k","branchA","branchB","condition","CompilerContext","sourceFile","message","severity","range","tsNode","start","end","line","DiagnosticSeverity","extractReturn","OpKind","block","compileNode","ctx","ts.SyntaxKind","sf","statements","stmt","s","nextId","VOID_TYPE","list","decls","decl","init","DataTypeKind","isConst","ts.getCombinedNodeFlags","ts.NodeFlags","resolveType","alias","val","func","ANY_TYPE","globalVal","resolveGlobal","NUMBER_TYPE","call","staticRes","tryCompileStaticCall","prop","obj","instanceRes","tryCompileInstanceMethod","funcVal","funcDecl","funcName","tryInlineFunc","targetFunc","callNode","closureScope","args","typeParams","genericMap","i","param","paramName","pType","argNode","typeName","tp","savedScope","arg","result","bodyBlock","compiledStmt","ret","returnTypeRef","returnTypeName","typeArg","resolvedT","reflectedType","GENERIC_INST","phi","dispatchPhi","p","t","f","v","expr","isCompound","right","getReadValue","lhsNode","targetName","lhs","readProp","elem","index","readIndex","left","lVal","rVal","resVal","isBool","BOOLEAN_TYPE","op","retType","operand","nextV","nextNode","one","bin","assign","fields","fieldTypes","allConst","valObj","arr","elements","elementType","valArr","e","firstT","getPrimitiveType","struct","sType","access","idxConst","m","ts.isPropertySignature","fieldName","fieldType","undefinedType","structType","w","cond","bodyRes","body","ifStmt","parentScope","thenScope","thenRes","thenBlock","elseBlock","elseScope","mergeScopes","mergeOneWay","loop","loopScope","loops","c","rtCond","incr","whileStmts","whileNode","resultStmts","nodeIdCounter","typeNode","STR_TYPE","ts.isArrayTypeNode","elType","ts.isLiteralTypeNode","ts.isUnionTypeNode","types","ts.isTypeLiteralNode","ts.isTypeReferenceNode","base","distinctKeys","key","valA","valB","parentVal","keys","compileToIR","src","globalInputs","ts.createSourceFile","ts.ScriptTarget","tsDiagnostics","diag","rootBlock","combinedInputs","F32","BOOL","safeName","collectStructs","ir","inputs","structs","visitType","getStructName","ANY_OUTPUT_TYPE","stack","n","typeToWGSL","inner","len","innerType","generateWGSL","options","lines","inputEntries","sortedInputs","b","aIsArray","bIsArray","emitBlock","indent","spaces","r","valCode","emitNode","isBooleanExpr","code","l","emitVal","expectedType","eType","emitValueAsFloat","emitValueAsBool","leftBool","rightBool","u","a","d","isRefType","isLVal","typeStr","res","fieldValues"],"mappings":"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"}