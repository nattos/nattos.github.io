import{p as h,O as n,q as _,D as I}from"./stdlib-aBcQoNak.js";import{c as x,g as O}from"./codegen-wgsl-CST6uU3w.js";function B(u,s){const t=[];if(t.push("function compute(input, debug_out) {"),s.debug&&t.push("    function record_debug(line, val) { if(debug_out) debug_out[line] = val; }"),s.checkInputs&&s.inputs){for(const[o,e]of Object.entries(s.inputs))if(e.kind===h.Primitive){const r=e;r.name==="number"?t.push(`    if (typeof input.${o} !== 'number') throw new Error("Input '${o}' must be a number");`):r.name==="boolean"&&t.push(`    if (typeof input.${o} !== 'boolean') throw new Error("Input '${o}' must be a boolean");`)}}return t.push(k(u.root,1,s)),t.push("}"),t.push(""),t.push("module.exports = { compute };"),t.join(`
`)}function k(u,s,t){const o=[],e="    ".repeat(s);for(const r of u.statements){const c=p(r,s,t);if(c){if(r.kind===n.If||r.kind===n.Block||r.kind===n.While)o.push(c.includes(`
`)?c.split(`
`).map((i,a)=>e+i).join(`
`):`${e}${c}`);else if(o.push(`${e}${c};`),t.debug){if(r.kind===n.VarDecl){const i=r;i.debugInfo&&o.push(`${e}record_debug(${i.debugInfo.line}, ${i.name});`)}if(r.kind===n.Assign){const i=r;i.debugInfo&&o.push(`${e}record_debug(${i.debugInfo.line}, ${i.target});`)}}}}return o.join(`
`)}function p(u,s,t){const o=t.inputs;switch(u.kind){case n.Const:{const e=u;return e.value===null||e.value===void 0?"null":typeof e.value=="string"?`"${e.value}"`:typeof e.value=="boolean"?String(e.value):Array.isArray(e.value)?`[${e.value.map(c=>typeof c=="object"?JSON.stringify(c):String(c)).join(", ")}]`:typeof e.value=="object"?e.value.node&&e.value.closure?"null /* Inlined Function */":JSON.stringify(e.value):String(e.value)}case n.Array:return`[${u.elements.map(c=>p(c,s,t)).join(", ")}]`;case n.Var:{const e=u;return o[e.name]?`input.${e.name}`:e.name}case n.Binary:{const e=u;return`(${p(e.left,s,t)} ${e.op} ${p(e.right,s,t)})`}case n.Unary:{const e=u;return`(${e.op}${p(e.operand,s,t)})`}case n.Assign:{const e=u;return`${e.target} = ${p(e.value,s,t)}`}case n.VarDecl:{const e=u;return e.init?`let ${e.name} = ${p(e.init,s,t)}`:`let ${e.name}`}case n.If:{const e=u,r=p(e.condition,s,t),c=k(e.thenBlock,s+1,t);let i=`if (${r}) {
${c}
${"    ".repeat(s)}}`;if(e.elseBlock){const a=k(e.elseBlock,s+1,t);i+=` else {
${a}
${"    ".repeat(s)}}`}return i}case n.While:{const e=u,r=p(e.condition,s,t),c=k(e.body,s+1,t);return`while (${r}) {
${c}
${"    ".repeat(s)}}`}case n.Break:return"break";case n.Return:{const r=p(u.value,s,t);return t.outputType&&t.outputType.kind===h.Primitive&&t.outputType.name==="number"?`return Number(${r})`:`return ${r}`}case n.Phi:{const e=u;return`(${p(e.condition,s,t)} ? ${p(e.trueValue,s,t)} : ${p(e.falseValue,s,t)})`}case n.Intrinsic:{const e=u;if(e.library==="Array"){if(e.method==="length")return`${p(e.args[0],s,t)}.length`;if(e.method==="get")return`${p(e.args[0],s,t)}[${p(e.args[1],s,t)}]`;const[r,...c]=e.args,i=c.map(a=>p(a,s,t)).join(", ");return`${p(r,s,t)}.${e.method}(${i})`}return`Math.${e.method}(${e.args.map(r=>p(r,s,t)).join(", ")})`}case n.Struct:{const e=u,r=e.type;return`{ ${Object.keys(r.fields).map(i=>`${i}: ${p(e.fields[i],s,t)}`).join(", ")} }`}case n.PropAccess:{const e=u;return`${p(e.object,s,t)}.${e.property}`}case n.IndexAccess:{const e=u;return`${p(e.object,s,t)}[${p(e.index,s,t)}]`}case n.SetProp:{const e=u;return`${p(e.object,s,t)}.${e.property} = ${p(e.value,s,t)}`}case n.SetIndex:{const e=u;return`${p(e.object,s,t)}[${p(e.index,s,t)}] = ${p(e.value,s,t)}`}case n.Block:return`{
${k(u,s+1,t)}
${"    ".repeat(s)}}`;default:return`/* Unknown Op ${u.kind} */`}}const V={kind:h.Primitive,name:"number"};function S(u){return u.name?u.name:`Struct_${Object.keys(u.fields).join("_")}`}function R(u,s){const t=new Map;function o(r){if(r)if(r.kind===h.Struct){const c=r,i=S(c);t.has(i)||(t.set(i,c),Object.values(c.fields).forEach(o))}else r.kind===h.Array&&o(r.elementType)}Object.values(s).forEach(o);const e=[u.root];for(;e.length;){const r=e.pop();!r||typeof r!="object"||(r.type&&o(r.type),r.kind===n.Block?e.push(...r.statements):r.kind===n.If?(e.push(r.condition),e.push(r.thenBlock),r.elseBlock&&e.push(r.elseBlock)):r.kind===n.Binary?e.push(r.left,r.right):r.kind===n.Assign||r.kind===n.Return?e.push(r.value):r.kind===n.Struct?Object.values(r.fields).forEach(i=>e.push(i)):r.kind===n.Array?e.push(...r.elements):r.kind===n.PropAccess?e.push(r.object):r.kind===n.IndexAccess?e.push(r.object,r.index):r.kind===n.Intrinsic?e.push(...r.args):r.kind===n.VarDecl&&r.init&&e.push(r.init))}return t}function g(u){switch(u.kind){case h.Primitive:{const s=u;return s.name==="number"?"double":s.name==="boolean"?"bool":s.name==="void"?"void":"auto"}case h.Array:{const s=u.elementType;return`std::vector<${g(s)}>`}case h.Struct:return S(u);case h.Union:{const t=u.types.filter(o=>!(o.kind===h.Primitive&&(o.name==="null"||o.name==="undefined")));if(t.length===1)return`std::optional<${g(t[0])}>`;if(t.length===0)return"std::optional<double>";throw new Error(`Complex unions not supported in C++ backend: ${JSON.stringify(u)}`)}default:return"auto"}}function A(u,s){const t=[],o=R(u,s.inputs);t.push("#include <iostream>"),t.push("#include <vector>"),t.push("#include <string>"),t.push("#include <cmath>"),t.push("#include <algorithm>"),t.push("#include <optional>"),t.push('#include "json.hpp"'),t.push(""),t.push("using json = nlohmann::json;"),t.push(""),o.forEach((r,c)=>{t.push(`struct ${c} {`);for(const[a,d]of Object.entries(r.fields))t.push(`    ${g(d)} ${a}{};`);t.push("};"),t.push(`void to_json(json& j, const ${c}& p) {`),t.push("    j = json{");const i=Object.keys(r.fields);t.push(i.map(a=>`        {"${a}", p.${a}}`).join(`,
`)),t.push("    };"),t.push("}"),t.push(`void from_json(const json& j, ${c}& p) {`);for(const[a,d]of Object.entries(r.fields))g(d).startsWith("std::optional")?t.push(`    if (j.contains("${a}")) j.at("${a}").get_to(p.${a});`):t.push(`    j.at("${a}").get_to(p.${a});`);t.push("}"),t.push("")}),t.push("struct Input {");for(const[r,c]of Object.entries(s.inputs))t.push(`    ${g(c)} ${r}{};`);t.push("};"),t.push("void from_json(const json& j, Input& p) {");for(const[r,c]of Object.entries(s.inputs))g(c).startsWith("std::optional")?t.push(`    if (j.contains("${r}")) j.at("${r}").get_to(p.${r});`):t.push(`    if (j.contains("${r}")) j.at("${r}").get_to(p.${r});`);t.push("}"),t.push("");let e="auto";return s.outputType&&(e=g(s.outputType)),s.debug&&(t.push("json debug_log = json::object();"),t.push("template <typename T> auto to_debug_json(const T& v) { return v; }"),t.push("template <typename T> auto to_debug_json(const std::vector<T>& v) {"),t.push("    if (v.size() > 4) return std::vector<T>(v.begin(), v.begin() + 4);"),t.push("    return v;"),t.push("}"),t.push("template <typename T> void record_debug(int line, const T& val) {"),t.push("    debug_log[std::to_string(line)] = to_debug_json(val);"),t.push("}")),t.push(`${e} compute(Input& input) {`),t.push(j(u.root,1,s)),t.push("}"),t.push(""),t.push(`
int main() {
    try {
        json j_in;
        std::cin >> j_in;

        Input in;
        if (j_in.contains("inputs")) {
            j_in["inputs"].get_to(in);
        } else {
             // Try root
             j_in.get_to(in);
        }

        auto res = compute(in);

        json j_out;
        j_out["outputs"] = { {"res", res} };
`),s.debug&&t.push('        j_out["debug"] = debug_log;'),t.push("        std::cout << j_out.dump(4) << std::endl;"),t.push(`
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}
`),t.join(`
`)}function j(u,s,t){const o=[],e="    ".repeat(s);for(const r of u.statements){const c=l(r,s,t);if(c){if(r.kind===n.If||r.kind===n.Block||r.kind===n.VarDecl||r.kind===n.While)if(t.debug&&r.kind===n.VarDecl){o.push(`${e}${c}; `);const i=r;i.debugInfo&&o.push(`${e} record_debug(${i.debugInfo.line}, ${i.name}); `)}else o.push(c.includes(`
`)?c.split(`
`).map((i,a)=>e+i).join(`
`):`${e}${c}${r.kind===n.VarDecl?";":""} `);else if(c.includes(`
`)?o.push(c.split(`
`).map((i,a)=>e+i).join(`
`)+";"):o.push(`${e}${c}; `),t.debug&&r.kind===n.Assign){const i=r;i.debugInfo&&o.push(`${e} record_debug(${i.debugInfo.line}, ${i.target}); `)}}}return o.join(`
`)}function l(u,s,t){const o=t.inputs;switch(u.kind){case n.Const:{const e=u;if(e.value===null||e.value===void 0)return"std::nullopt";if(typeof e.value=="string")return`"${e.value}"`;if(typeof e.value=="boolean")return e.value?"true":"false";if(Array.isArray(e.value)){let r;return e.type&&e.type.kind===h.Array&&(r=e.type.elementType),`{ ${e.value.map(i=>{if(typeof i=="number"){const a=String(i);return a.includes(".")?a:a+".0"}return l({kind:n.Const,type:r,value:i},s,t)}).join(", ")} } `}if(typeof e.value=="object"&&e.value&&!Array.isArray(e.value)){if(e.type.kind===h.Struct){const r=e.type,c=S(r),i=Object.keys(r.fields),a=e.value,d=i.map(b=>l({kind:n.Const,type:r.fields[b],value:a[b]},s,t)).join(", ");return`${c}{${d}}`}return"/* unused_function */ 0"}if(typeof e.value=="number"){const r=String(e.value);return r.includes(".")?r:r+".0"}return String(e.value)}case n.Array:return`{ ${u.elements.map(c=>l(c,s,t)).join(", ")} } `;case n.Var:{const e=u;return o[e.name]?`input.${e.name} `:e.name}case n.Binary:{const e=u,r=l(e.left,s,t),c=l(e.right,s,t);return`(${r} ${e.op} ${c})`}case n.Return:return`return ${l(u.value,s,t)} `;case n.Assign:{const e=u;return`${e.target} = ${l(e.value,s,t)} `}case n.VarDecl:{const e=u;let r="";e.init&&(r=` = ${l(e.init,s,t)}`);let c=g(e.type||V);if(e.type&&(e.type.kind===h.Struct||e.type.kind===h.Array)&&e.init){const i=e.init.kind;(i===n.Var||i===n.IndexAccess||i===n.PropAccess)&&(c+="&")}return`${c} ${e.name}${r}`}case n.If:{const e=u,r=l(e.condition,s,t),c=j(e.thenBlock,s+1,t);let i=`if (${r}) { 
${c} 
${"    ".repeat(s)} } `;if(e.elseBlock){const a=j(e.elseBlock,s+1,t);i+=` else { 
${a} 
${"    ".repeat(s)} } `}return i}case n.Unary:{const e=u,r=l(e.operand,s,t);return`(${e.op}${r})`}case n.Phi:{const e=u,r=l(e.condition,s,t),c=l(e.trueValue,s,t),i=l(e.falseValue,s,t);return`((${r}) ? (${c}) : (${i}))`}case n.While:{const e=u,r=l(e.condition,s,t),c=j(e.body,s+1,t);return`while (${r}) {
${c}
${"    ".repeat(s)}}`}case n.Break:return"break";case n.Intrinsic:{const e=u,r={sin:"std::sin",cos:"std::cos",tan:"std::tan",abs:"std::abs",sqrt:"std::sqrt",log:"std::log",exp:"std::exp",floor:"std::floor",ceil:"std::ceil",round:"std::round"};return e.library==="Array"&&e.method==="length"?`${l(e.args[0],s,t)}.size()`:e.library==="Array"&&e.method==="push"?`${l(e.args[0],s,t)}.push_back(${l(e.args[1],s,t)})`:r[e.method]?`${r[e.method]} (${l(e.args[0],s,t)})`:e.method==="pow"?`std:: pow(${l(e.args[0],s,t)}, ${l(e.args[1],s,t)})`:e.method==="min"?`std:: min(${l(e.args[0],s,t)}, ${l(e.args[1],s,t)})`:e.method==="max"?`std:: max(${l(e.args[0],s,t)}, ${l(e.args[1],s,t)})`:"/* Unknown Intrinsic */"}case n.Struct:{const e=u,r=S(e.type),c=e.type,a=Object.keys(c.fields).map(d=>l(e.fields[d],s,t)).join(", ");return`${r} {${a} } `}case n.PropAccess:{const e=u;return`${l(e.object,s,t)}.${e.property} `}case n.SetProp:{const e=u;return`${l(e.object,s,t)}.${e.property} = ${l(e.value,s,t)} `}case n.SetIndex:{const e=u;return`${l(e.object,s,t)}[${l(e.index,s,t)}] = ${l(e.value,s,t)} `}case n.IndexAccess:{const e=u;return`${l(e.object,s,t)} [${l(e.index,s,t)}]`}case n.Block:return`{
${j(u,s+1,t)}
${"    ".repeat(s)}}`;default:return`/* Unknown Op: ${u.kind} */`}}function N(u){let s=[],t=u.code,o=[],e;if(u.containerMode==="expression-like"){const f=_.createSourceFile("temp.ts",t,_.ScriptTarget.Latest,!0);let m=!1;if(f.statements.length>0){const $=f.statements[f.statements.length-1];if(_.isExpressionStatement($)){const y=$.expression,T=y.getStart(f),w=y.getEnd(),P=t.slice(0,T),C=t.slice(T,w),E=t.slice($.getEnd());t=P+"return ("+C+");"+E,m=!0}}m||(e=f)}let r=x(e||t,{});if(u.autoInputs&&r.diagnostics){const f=new Set;for(const m of r.diagnostics){const $=m.message.match(/Unresolved identifier: (\w+)/);$&&f.add($[1])}if(f.size>0){const m=[];for(const $ of f)m.push(`var ${$}: number;`),o.push($);m.length>0&&(t=m.join(`
`)+`
`+t,r=x(t,{}))}}r.diagnostics&&s.push(...r.diagnostics);const c={diagnostics:s};o.length>0&&(c.injectedInputs=o),u.emitIR&&(c.outIR={graph:r});const i={...r.inputs||{}};for(const f of o)i[f]||(i[f]={kind:h.Primitive,name:"number"});c.inputs=i,c.output=r.root&&v(r.root)||{kind:"primitive",name:"void"};const a=u.debug||"none",d=a==="none"||a==="both",b=a==="only"||a==="both";if(u.emitJS||u.emitJSRunner)try{const f={},m={};if(d){const $=B(r,{inputs:i,checkInputs:!0,outputType:u.outputType,debug:!1});if(u.emitJS&&(f.code=$),u.emitJSRunner){const y=$.replace("module.exports = { compute };","return compute;");m.runner=new Function(y)()}}if(b){const $=B(r,{inputs:i,checkInputs:!0,outputType:u.outputType,debug:!0});if(u.emitJS&&(f.debugCode=$),u.emitJSRunner){const y=$.replace("module.exports = { compute };","return compute;");m.debugRunner=new Function(y)()}}u.emitJS&&(c.outJS=f),u.emitJSRunner&&(c.outJSRunner=m)}catch(f){s.push({message:`JS Codegen Error: ${f.message}`,severity:I.Error,source:"codegen-js"})}if(u.emitWGSL)try{const f=O(r,{inputs:i,outputType:u.outputType}),m={};d&&(m.code=f),b&&(m.debugCode=f),c.outWGSL=m}catch(f){s.push({message:`WGSL Codegen Error: ${f.message}`,severity:I.Error,source:"codegen-wgsl"})}if(u.emitCPP)try{const f={};d&&(f.code=A(r,{inputs:i,outputType:u.outputType,debug:!1})),b&&(f.debugCode=A(r,{inputs:i,outputType:u.outputType,debug:!0})),c.outCPP=f}catch(f){s.push({message:`CPP Codegen Error: ${f.message}`,severity:I.Error,source:"codegen-cpp"})}return c}function v(u){if(u.kind===n.Return)return u.value.type;if(u.kind===n.Block){const s=u;for(const t of s.statements){const o=v(t);if(o)return o}}if(u.kind===n.If){const s=u,t=v(s.thenBlock);if(t)return t;if(s.elseBlock)return v(s.elseBlock)}return u.kind===n.While?v(u.body):null}export{N as buildCode};
//# sourceMappingURL=builder-C0dqNj5S.js.map
