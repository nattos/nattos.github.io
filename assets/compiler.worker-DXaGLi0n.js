const G={kind:"atomic",type:"number",defaultValue:0},qe={kind:"atomic",type:"string",defaultValue:""},Q={kind:"atomic",type:"any"};function re(e,i){if(e==null)return e;if(i.kind==="atomic")return e&&typeof e=="object"&&"kind"in e&&e.kind==="atomic"?e.value:e;if(i.kind==="array")return Array.isArray(e)?e.map(o=>re(o,i.element)):[];if(i.kind==="record"){if(typeof e=="object"){if("fields"in e){const t=e,n={};for(const[s,r]of Object.entries(i.fields))s in t.fields&&(n[s]=re(t.fields[s],r));return n}const o={};for(const[t,n]of Object.entries(i.fields))t in e&&(o[t]=re(e[t],n));return o}return e}return e}function he(e,i){if(e==null||i.kind==="atomic")return e;if(i.kind==="array")return Array.isArray(e)?e.map(t=>he(t,i.element)):(console.error("toStructor array fail: not array",e),[]);if(i.kind==="record"){const o={};for(const[t,n]of Object.entries(i.fields))e[t]!==void 0&&(o[t]=he(e[t],n));return{fields:o}}return e}function ie(e){const i={kind:"record",fields:e.config||{}},o={kind:"record",fields:e.outputs};return{id:e.id,kind:"primitive",metadata:e.metadata,inputs:e.inputs,outputs:e.outputs,configType:i,isRealtime:e.isRealtime,onMessage:e.onMessage,getDisplayLabel:e.getDisplayLabel,subgraphExpansionTag:e.subgraphExpansionTag,getChildren:e.getChildren,getRegion:e.getRegion,cycleBreakingPorts:e.cycleBreakingPorts,consolidate:e.consolidate?(t,n,s,r)=>{const l=re(n,i),c={},u=t.fields||{};for(const[d,h]of Object.entries(e.inputs||{}))u[d]!==void 0&&(c[d]=re(u[d],h));e.consolidate(c,l,s,r)}:void 0,computeBackwardPorts:e.computeBackwardPorts,computeForwardPorts:(t,n,s,r)=>e.computeForwardPorts?e.computeForwardPorts(t,n,s,r):{inputs:{kind:"record",fields:e.inputs||{}},outputs:o},shouldRecompileOnConfigChange:(t,n)=>e.shouldRecompileOnConfigChange?e.shouldRecompileOnConfigChange(t,n):!1,compileConfig:e.compileConfig,ui:e.ui,createState:e.createState,execute:(t,n,s)=>{const r=re(n,i);let l;if(e.createState){const v=s.nodeId||`${e.id}-${JSON.stringify(n)}`;s.nodeState.has(v)||s.nodeState.set(v,e.createState(r,s)),l=s.nodeState.get(v)}let c=t;if(e.autoBroadcast&&e.inputs){const v={outputs:{},reshape:e.reshape??"none"},b=typeof e.autoBroadcast=="object"?e.autoBroadcast:{};if(r&&typeof r=="object"&&"autoBroadcast"in r){const M=r.autoBroadcast;M&&typeof M=="object"&&Object.assign(b,M)}for(const[M,q]of Object.entries(e.inputs)){const K=q.kind==="array",D=b[M],C=K?"collect":{reduce:"first"},W=D&&"combine"in D?D.combine:C;v.outputs[M]={fromFields:[M],combine:W??void 0}}const _=s.broadcast(v,t).apply(M=>{const q={};for(const[D,C]of Object.entries(e.inputs))if(v.outputs[D]?.combine==="collect"&&Array.isArray(M[D])){const j=M[D].map(g=>{if(Array.isArray(g)&&g.length>0&&Array.isArray(g[0])&&C.kind==="array"&&C.element.kind==="record")return g.map(T=>re(T,C.element));const N=C.element?.kind==="array",w=Array.isArray(g)&&g.length>0&&Array.isArray(g[0]);return N&&!w?re(g,C.element):re(g,C)}),se=C.element?.kind==="array";j.length===1&&Array.isArray(j[0])&&!se?q[D]=j[0]:q[D]=j}else{const j=M[D],se=C.element?.kind==="array",g=Array.isArray(j)&&j.length>0&&Array.isArray(j[0]);let N;C.kind==="array"&&se&&!g?N=re(j,C.element):N=re(j,C),q[D]=N!==void 0?N:C.defaultValue}return e.execute(q,r,s,l)});if(Array.isArray(_))if(_.length>0){const M={},q=_[0];for(const D of Object.keys(q))M[D]=[];for(const D of _)for(const[C,W]of Object.entries(D))M[C]&&M[C].push(W);const K={};for(const[D,C]of Object.entries(M)){const W=e.outputs[D]||e.dynamicOutputType;W&&(K[D]=he(C,{kind:"array",element:W,size:_.length}))}return{fields:K}}else return{fields:{}};else{let M=_,q;M&&typeof M=="object"&&"outputs"in M&&("ui"in M||Object.keys(M).length===2)&&("outputs"in e.outputs||(q=M.ui,M=M.outputs));const K=new Set([...Object.keys(e.outputs),...Object.keys(M)]),D={};for(const W of K){const j=e.outputs[W]||e.dynamicOutputType;j&&M[W]!==void 0&&(D[W]=he(M[W],j))}const C={fields:D};return q!==void 0?{outputs:C,ui:q}:C}}else if(e.inputs&&Object.keys(e.inputs).length>0){const v={};for(const[b,I]of Object.entries(e.inputs))t.fields&&t.fields[b]!==void 0?v[b]=re(t.fields[b],I):I.defaultValue!==void 0&&(v[b]=I.defaultValue);c=v}let d=e.execute(c,r,s,l),h;d&&typeof d=="object"&&"outputs"in d&&("ui"in d||Object.keys(d).length===2)&&("outputs"in e.outputs||(h=d.ui,d=d.outputs));const p={},f=d;if(f){const v=new Set([...Object.keys(e.outputs),...Object.keys(f)]);for(const b of v){const I=e.outputs[b]||e.dynamicOutputType;I&&f[b]!==void 0&&(p[b]=he(f[b],I))}}const y={fields:p};return h!==void 0?{outputs:y,ui:h}:y}}}function Ut(e,i,o){const t={outputs:{},reshape:"none"};for(const[l,c]of Object.entries(i))t.outputs[l]={fromFields:c.source?Array.isArray(c.source)?c.source:[c.source]:[l],combine:c.combine??{reduce:"first"}};const s=e.broadcast(t,o).apply(l=>l),r={};if(Array.isArray(s)){for(const l of Object.keys(i))r[l]=[];for(const l of s)for(const c of Object.keys(i))r[c].push(l[c])}else for(const l of Object.keys(i))r[l]=s[l];for(const[l,c]of Object.entries(i))if(c.type)if(c.combine==="collect"){const u=r[l];Array.isArray(u)?r[l]=u.map(d=>re(d,c.type)):r[l]=re(u,c.type)}else{const u=r[l];Array.isArray(u)?r[l]=u.map(d=>re(d,c.type)):r[l]=re(u,c.type)}return r}function J(e,i,o,t="binary"){return ie({id:e,metadata:i,inputs:t==="binary"?{a:G,b:G}:{a:G},outputs:{result:G},autoBroadcast:!0,reshape:"vector",execute:(s,r,l)=>{if(t==="binary"){const{a:c,b:u}=s;return{result:o(c,u)}}else{const{a:c}=s;return{result:o(c,0)}}}})}function Ee(e){if(e.length===0)return Q;const i=e[0];if(e.every(s=>s.kind===i.kind&&(s.kind==="atomic"?s.type===i.type:!0)))return i;if(e.some(s=>s.kind==="atomic"&&s.type==="string"))return Q;const t=e.some(s=>s.kind==="atomic"&&s.type==="number"),n=e.some(s=>s.kind==="atomic"&&s.type==="boolean");return t||n?G:Q}var $e=(e=>(e.Auto="auto",e.Show="show",e.Hide="hide",e))($e||{});class Yt{constructor(){this.nodes=new Map}register(i){this.nodes.set(i.id,i)}get(i){return this.nodes.get(i)?.definition}getNodeType(i){return this.nodes.get(i)}getAllNodeTypes(){return this.nodes.values()}}const ke=new Yt;function V(e){const i={};for(const[n,s]of Object.entries(e.inputs||{}))if("kind"in s)i[n]=s;else if("type"in s){const r=s,l=r.type,c=r.allowMultiConnection?{kind:"array",size:"dynamic",element:l}:l;i[n]={...c,redirect:r.redirect,defaultValue:"defaultValue"in r?r.defaultValue:l.defaultValue}}const o={};for(const[n,s]of Object.entries(e.outputs||{}))"kind"in s?o[n]=s:"type"in s&&(o[n]=s.type);return{...ie({...e,autoBroadcast:e.autoBroadcast,inputs:i,outputs:o,compileConfig:(n,s)=>e.compileConfig?e.compileConfig(n,s):n,computeForwardPorts:(n,s,r,l)=>e.computeForwardPorts?e.computeForwardPorts(n,s,r,l):{inputs:{kind:"record",fields:i},outputs:{kind:"record",fields:o}},computeBackwardPorts:(n,s,r)=>e.computeBackwardPorts?e.computeBackwardPorts(n,s,r):{inputRequirements:{kind:"record",fields:{}}},onMessage:e.onMessage,config:e.config}),ui:e.ui,version:e.version||"1.0.0",displayName:e.displayName||e.id,aliases:e.aliases,compileConfig:e.compileConfig,loadCompileDeps:e.loadCompileDeps,getDisplayLabel:e.getDisplayLabel,subgraphExpansionTag:e.subgraphExpansionTag,extendedInputs:e.inputs,extendedOutputs:e.outputs,inspectInputs:e.inspectInputs,shouldRecompileOnConfigChange:e.shouldRecompileOnConfigChange,getChildren:e.getChildren,getRegion:e.getRegion,usesMidiDeviceIO:e.usesMidiDeviceIO,syncUIFromCompiledConfig:e.syncUIFromCompiledConfig}}function m(e){const i=e.extendedInputs||e.inputs||{},o=Object.entries(i).map(([r,l])=>{const c="type"in l&&typeof l.type=="object"&&"kind"in l.type,u=c?l.type:l;return{name:r,type:u,description:c?l.description:void 0,defaultValue:c?l.defaultValue:void 0,range:c?l.range:void 0,step:c?l.step:void 0,suppressInputEditor:c?l.suppressInputEditor:u.kind==="atomic"&&u.type==="any"?!0:void 0,alwaysShowInputEditor:c?l.alwaysShowInputEditor:void 0,suppressLabel:c?l.suppressLabel:void 0,redirect:c?l.redirect:void 0,allowMultiConnection:c?l.allowMultiConnection:void 0}}),t=e.extendedOutputs||e.outputs||{},n=Object.entries(t).map(([r,l])=>{const c="type"in l&&typeof l.type=="object"&&"kind"in l.type,u=c?l.type:l;return{name:r,type:u,description:c?l.description:void 0,suppressLabel:c?l.suppressLabel:void 0}}),s={id:e.id,version:e.version||"1.0.0",displayName:e.displayName||e.id,aliases:e.aliases,definition:e,inputs:o,outputs:n,compileConfig:e.compileConfig,getDisplayLabel:e.getDisplayLabel,inspectInputs:e.inspectInputs,shouldRecompileOnConfigChange:e.shouldRecompileOnConfigChange,getChildren:e.getChildren,getRegion:e.getRegion,syncUIFromCompiledConfig:e.syncUIFromCompiledConfig};s.ui=e.ui,ke.register(s)}var x=(e=>(e.IO="IO",e.Math="Math",e.Logic="Logic",e.Data="Data",e.Functional="Functional",e.Core="Core",e.Custom="Custom",e.Utility="Utility",e.Debug="Debug",e))(x||{});const Ge={kind:"record",fields:{domain:{kind:"array",element:G,size:2},range:{kind:"array",element:G,size:2},segments:{kind:"array",element:{kind:"record",fields:{id:{kind:"atomic",type:"string"},weight:G,curve:{kind:"record",fields:{type:{kind:"atomic",type:"string"},value:{...G,optional:!0},points:{kind:"array",element:{kind:"record",fields:{x:G,y:G}},optional:!0,size:"dynamic"}}}}},size:"dynamic"},envelopeNodes:{kind:"array",element:{kind:"record",fields:{id:{kind:"atomic",type:"string"},x:G,y:G}},optional:!0,size:"dynamic"}},hint:"curve"},He=(e,i)=>{const o=e.value,t=e.easing;if(!t||!t.segments||t.segments.length===0)return{result:o};const{domain:n,range:s,segments:r}=t,[l,c]=n,[u,d]=s;let h=(o-l)/(c-l);h=Math.max(0,Math.min(1,h));const p=r.reduce((D,C)=>D+C.weight,0)||1;let f=0,y=r[r.length-1],v=0,b=0;for(const D of r){const C=D.weight/p;if(h>=f&&h<=f+C){y=D,v=f,b=C;break}f+=C}const I=(h-v)/b;let _=0;const M=y.curve,q=M.type==="step"?M.value??2:1;switch(M.type){case"exponential":const D=Math.pow(10,-(M.value??0));_=Math.pow(I,D);break;case"linear":_=I;break;case"step":q<=1?_=0:_=Math.floor(I*q)/(q-1),I>=.999&&(_=1);break;case"sin":_=-(Math.cos(Math.PI*I)-1)/2;break;case"quad":_=I*I;break;case"points":if(M.points&&M.points.length>0){const C=M.points;if(I<=C[0].x)_=C[0].y;else if(I>=C[C.length-1].x)_=C[C.length-1].y;else for(let W=0;W<C.length-1;W++){const j=C[W],se=C[W+1];if(I>=j.x&&I<=se.x){const g=(I-j.x)/(se.x-j.x);_=j.y+g*(se.y-j.y);break}}}else _=I;break;default:_=I}return{result:u+_*(d-u)}},Wt=V({id:"curve.ease",version:"1.0.0",displayName:"Curve Ease",metadata:{category:x.Math,keywords:["curve","ease","envelope","shape"],description:"Applies a custom curve easing to the input value."},inputs:{value:{type:G,description:"Input value (0-1)",defaultValue:0},easing:{type:{...Ge,optional:!0},description:"Easing Curve Configuration",suppressInputEditor:!0}},outputs:{result:G},autoBroadcast:!0,inspectInputs:!0,compileConfig:e=>({fields:{easing:e?.easing??{domain:[0,1],range:[0,1],segments:[{id:"s1",weight:1,curve:{type:"exponential",value:0}}]}},untagged:[]}),execute:He}),Zt=V({id:"curve.ease4",version:"1.0.0",displayName:"Curve Ease 4",metadata:{category:x.Math,keywords:["curve","ease","envelope","shape","multi"],description:"Applies a custom 4-segment curve easing to the input value."},inputs:{value:{type:G,description:"Input value (0-1)",defaultValue:0},easing:{type:{...Ge,optional:!0},description:"Easing Curve Configuration",suppressInputEditor:!0,defaultValue:{domain:[0,1],range:[0,1],segments:[{id:"s1",weight:1,curve:{type:"exponential",value:.5}},{id:"s2",weight:1,curve:{type:"exponential",value:0}},{id:"s3",weight:1,curve:{type:"exponential",value:-.5}},{id:"s4",weight:1,curve:{type:"exponential",value:-1}}]}}},outputs:{result:G},autoBroadcast:!0,inspectInputs:!0,compileConfig:e=>({fields:{easing:e?.easing??{domain:[0,1],range:[0,1],segments:[{id:"s1",weight:1,curve:{type:"exponential",value:.5}},{id:"s2",weight:1,curve:{type:"exponential",value:0}},{id:"s3",weight:1,curve:{type:"exponential",value:-.5}},{id:"s4",weight:1,curve:{type:"exponential",value:-1}}]}},untagged:[]}),execute:He});m(Wt);m(Zt);const Xt=(e,i,o,t)=>{const n=e.value??0,s=i?.config;if(!s||!s.envelopeNodes||s.envelopeNodes.length<2||!s.segments)return{result:n};const r=s.envelopeNodes,l=s.segments||[],c=r[0],u=r[r.length-1];if(n<=c.x)return{result:c.y};if(n>=u.x)return{result:u.y};let d=t.lastSegmentIndex||0;if(d>=r.length-1||n<r[d].x||n>=r[d+1].x){for(let I=0;I<r.length-1;I++)if(n>=r[I].x&&n<r[I+1].x){d=I;break}}t.lastSegmentIndex=d;const h=r[d],p=r[d+1],f=l[d],y=(n-h.x)/(p.x-h.x);let v=y;if(f&&f.curve){const I=f.curve.type||"linear",_=f.curve.value||0;if(I==="linear")v=y;else if(I==="exponential"){const M=Math.pow(10,-(_??0)),q=Math.max(0,y);v=Math.pow(q,M)}}return{result:h.y+(p.y-h.y)*v}},Qt=V({id:"curve.env",version:"1.0.0",displayName:"Curve Envelope",metadata:{category:"Curve",keywords:["envelope","automation","ramp"],description:"User-editable curve envelope"},inputs:{value:{type:G,description:"Input value (0-1)",defaultValue:0}},outputs:{result:{type:G,description:"Output value"}},config:{config:{kind:"atomic",type:"any",defaultValue:{}}},inspectInputs:!0,createState:()=>({lastSegmentIndex:0}),autoBroadcast:!0,compileConfig:e=>({config:e.config??e.curveData??e.values?.config??{domain:[0,1],range:[0,1],envelopeNodes:[{id:"n1",x:0,y:0},{id:"n2",x:1,y:1}],segments:[{id:"s1",weight:1,curve:{type:"linear"}}]}}),execute:Xt});m(Qt);const Jt={value:{type:G,defaultValue:0},start:{type:G,defaultValue:0},end:{type:G,defaultValue:1,optional:!0},length:{type:G,defaultValue:1,optional:!0}},Kt=V({id:"curve.crop",version:"1.0.0",displayName:"Curve Crop",metadata:{category:"Curve",keywords:["crop","slice","remap","linear"],description:"Linear mapping from 0-1 to start-end range."},config:{mode:{kind:"atomic",type:"string",defaultValue:"start-end"}},computeForwardPorts:(e,i,o)=>{const t=i.mode||"start-end",n={value:{...G,description:"Input value (0-1)",defaultValue:0},start:{...G,description:"Output at 0",defaultValue:0}};return t==="start-length"?n.length={...G,description:"Length of crop",defaultValue:1}:n.end={...G,description:"Output at 1",defaultValue:1},{inputs:{kind:"record",fields:n},outputs:{kind:"record",fields:{result:G}}}},inputs:Jt,outputs:{result:{type:G}},ui:{inspector:{fields:[{type:"tab-bar",label:"Mode",path:"mode",options:[{label:"Start / End",value:"start-end"},{label:"Start / Length",value:"start-length"}]}]}},compileConfig:e=>({mode:e.mode||"start-end"}),autoBroadcast:!0,inspectInputs:!0,execute:(e,i,o)=>{const t=i.mode||"start-end",n=e.start??0,s=e.value??0;let r;if(t==="start-length"){const u=e.length??1;r=n+u}else r=e.end??1;r<n&&(r=n);let l=0;const c=r-n;if(c<1e-6)l=s>=n?1:0;else{const u=(s-n)/c;l=Math.max(0,Math.min(1,u))}return{outputs:{result:l},ui:{start:n,end:r}}},shouldRecompileOnConfigChange:e=>!0});m(Kt);const a={kind:"atomic",type:"number",defaultValue:0},Le={kind:"atomic",type:"string"},Ue={kind:"atomic",type:"boolean"},Y={kind:"atomic",type:"any"},Ye={kind:"atomic",type:"string",options:["time","beats"],defaultValue:"time"},ei={kind:"record",fields:{type:Le,channel:a,deviceId:{...Le,optional:!0},time:{...a,optional:!0},note:{...a,optional:!0},velocity:{...a,optional:!0},cc:{...a,optional:!0},value:{...a,optional:!0}},hint:"midi"},A={kind:"array",size:"dynamic",element:ei,hint:"midi-stream"},De={kind:"array",element:a,size:4,hint:"float4"},Fe={kind:"record",fields:{note:a,velocity:a},untagged:[]};({...Fe},{...Fe});const ti={kind:"record",fields:{noteIndex:Y,velocity:a,hold:Ue},untagged:[]},ae={kind:"array",size:"dynamic",element:ti,hint:"step-sequence"},We=V({id:"debug.scope",version:"1.0.0",displayName:"Scope",metadata:{category:x.Debug,keywords:["debug","scope","chart","visualize"],description:"Visualizes input values over time."},inputs:{value:{type:a,suppressLabel:!0,alwaysShowInputEditor:!0}},outputs:{value:a},config:{},inspectInputs:!0,execute:e=>({value:e.value}),compileConfig:e=>({})});m(We);m(We);var ii=(e=>(e.Primitive="primitive",e.Struct="struct",e.Array="array",e.Union="union",e.Literal="literal",e.Tuple="tuple",e.Function="function",e.Generic="generic",e.GenericInstantiation="generic_instantiation",e.Any="any",e))(ii||{}),ni=(e=>(e.Const="const",e.Binary="binary",e.Unary="unary",e.Var="var",e.Assign="assign",e.Block="block",e.If="if",e.Return="return",e.VarDecl="var_decl",e.Array="array",e.Struct="struct",e.PropAccess="prop_access",e.IndexAccess="index_access",e.Phi="phi",e.Intrinsic="intrinsic",e.While="while",e.Break="break",e.SetProp="set_prop",e.SetIndex="set_index",e))(ni||{}),Re=(e=>(e.Error="error",e.Warning="warning",e.Information="info",e.Hint="hint",e))(Re||{});let _e=null;const oi=[{type:"string",label:"Expression",path:"code",placeholder:"e.g. sin(time) * 0.5"}],si=V({id:"logic.expression",version:"2.0.0",displayName:"Expression",metadata:{category:x.Logic,keywords:["expression","math","script","code"],description:"Evaluates a mathematical expression (V2)."},inputs:{},config:{jsCode:{...qe,optional:!0},inputs:{kind:"record",fields:{},optional:!0},outputs:{kind:"record",fields:{},optional:!0},diagnostics:{kind:"atomic",type:"any",optional:!0}},outputs:{result:Q},autoBroadcast:!1,ui:{inspector:{fields:oi}},loadCompileDeps:async()=>{_e||(_e={buildCode:(await import("./builder-DwEr2LBz.js")).buildCode})},shouldRecompileOnConfigChange:e=>!0,compileConfig:(e,i)=>{const o=e.code||"",t=`expr_v2_1:${o}`;if(i&&i.compileCache&&i.compileCache.has(t))return i.compileCache.get(t);if(!_e)return{jsCode:void 0,diagnostics:[{message:"Compiler not loaded. Please wait...",severity:Re.Warning,source:"system"}],inputs:{},outputs:{}};try{const n=_e.buildCode({code:o,emitJS:!0,autoInputs:!0,containerMode:"expression-like"}),s=n.diagnostics.some(u=>u.severity==="error"),r={};for(const[u,d]of Object.entries(n.inputs)){let h=Y;d.kind==="primitive"&&d.name==="number"&&(h=a),r[u]={...h,description:`Variable ${u}`}}const l={result:{...Y,description:"Result"}},c={jsCode:s?void 0:n.outJS?.code,diagnostics:n.diagnostics,inputs:r,outputs:l};return i&&i.compileCache&&i.compileCache.set(t,c),c}catch(n){return{jsCode:void 0,diagnostics:[{message:`Internal Compiler Error: ${n}`,severity:Re.Error,source:"compiler"}],inputs:{},outputs:{}}}},computeForwardPorts:(e,i)=>{const o=i&&i.inputs?i.inputs:{},t=i&&i.outputs?i.outputs:{result:Y};return{inputs:{kind:"record",fields:o},outputs:{kind:"record",fields:t}}},createState:()=>({}),syncUIFromCompiledConfig:(e,i)=>{i.diagnostics=e.diagnostics||[],i.jsCode=e.jsCode},execute:(e,i,o,t)=>{if(!i.jsCode)return{result:0};if(!t)return{result:0};if(t.lastCode!==i.jsCode||!t.runner)try{const n=i.jsCode.replace(/module\.exports\s*=\s*{\s*compute\s*};?;?/,"return compute;"),s=new Function(n);t.runner=s(),t.lastCode=i.jsCode}catch(n){return console.error("Failed to compile runner:",n),{result:null}}try{const n=e.fields?e.fields:e;return{result:t.runner(n)}}catch(n){return console.error("Runtime error:",n),{result:null}}}});m(si);const ri=V({id:"gen.sawtooth",version:"1.0.0",displayName:"Sawtooth",metadata:{category:"Oscillator",keywords:["oscillator","sawtooth","ramp","lfo","generator"],description:"Generates a linear sawtooth wave (0.0 to 1.0) at the given frequency."},inputs:{freq:{type:a,defaultValue:1,range:[0,60],description:"Frequency in Hz"}},outputs:{out:a},autoBroadcast:!0,isRealtime:()=>!0,createState:()=>({phase:0}),execute:(e,i,o,t)=>{const n=e.freq,s=o.clock.dt;return n>=60-1e-6?{out:Math.random()}:(t.phase+=s*n,t.phase-=Math.floor(t.phase),{out:t.phase})}});m(ri);const ne={IDLE:0,ATTACK:1,DECAY:2,SUSTAIN:3,RELEASE:4},ai=V({id:"gen.adsr",version:"1.0.0",displayName:"ADSR",metadata:{category:"Envelope",keywords:["envelope","adsr","modulation"],description:"Attack-Decay-Sustain-Release envelope generator triggered by MIDI."},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},inputs:{stream:{type:A,description:"MIDI Stream",allowMultiConnection:!0},attack:{type:a,defaultValue:.1,range:[0,5],description:"Attack Time (s)"},decay:{type:a,defaultValue:1,range:[0,5],description:"Decay Time (s)"},sustain:{type:a,defaultValue:.7,range:[0,1],description:"Sustain Level (0-1)"},release:{type:a,defaultValue:1,range:[0,5],description:"Release Time (s)"}},config:{mode:{kind:"atomic",type:"string",defaultValue:"D"}},ui:{inspector:{fields:[{label:"Mode",path:"mode",type:"tab-bar",options:[{label:"ADSR",value:"ADSR"},{label:"ADS",value:"ADS"},{label:"D",value:"D"}]}]}},compileConfig:e=>({mode:e.mode||e.values?.mode||"D"}),computeForwardPorts:(e,i)=>{const o=i.mode||"D",t={stream:A};return o==="ADSR"?(t.attack=a,t.decay=a,t.sustain=a,t.release=a):o==="ADS"?(t.attack=a,t.decay=a,t.sustain=a):o==="D"&&(t.decay=a),{inputs:{kind:"record",fields:t},outputs:{kind:"record",fields:{value:a}}}},outputs:{value:{type:a,description:"Envelope Value (0-1)"}},isRealtime:()=>!0,shouldRecompileOnConfigChange:e=>!0,createState:()=>({phase:ne.IDLE,value:0,time:0,activeNotes:0}),execute:(e,i,o,t)=>{const n=o.clock.dt,s=i.mode||"D",r=e.stream;let l=0,c=0,u=0,d=0;if(s==="D"?(l=0,c=Math.max(0,e.decay??.1),u=0,d=c):s==="ADS"?(l=Math.max(0,e.attack??.1),c=Math.max(0,e.decay??.1),u=Math.max(0,Math.min(1,e.sustain??.7)),d=c):(l=Math.max(0,e.attack??.1),c=Math.max(0,e.decay??.1),u=Math.max(0,Math.min(1,e.sustain??.7)),d=Math.max(0,e.release??.5)),Array.isArray(r))for(const h of r)h.type==="note_on"&&(h.velocity??0)>0?(t.activeNotes++,t.activeNotes===1&&(t.phase=ne.ATTACK,t.value=0,t.time=0,l<=0&&(t.value=1,t.phase=ne.DECAY,t.time=0,c<=0&&(t.value=u,t.phase=ne.SUSTAIN)))):(h.type==="note_off"||h.type==="note_on"&&(h.velocity??0)===0)&&(t.activeNotes=Math.max(0,t.activeNotes-1));switch(t.activeNotes===0&&t.phase!==ne.IDLE&&t.phase!==ne.RELEASE&&(t.phase=ne.RELEASE,t.time=0),t.phase){case ne.IDLE:t.value=0,t.time=0;break;case ne.ATTACK:t.time+=n,t.value+=1/Math.max(.001,l)*n,t.value>=1&&(t.value=1,t.phase=ne.DECAY,t.time=0,c<=0&&(t.value=u,t.phase=ne.SUSTAIN));break;case ne.DECAY:t.time+=n,t.value-=(1-u)/Math.max(.001,c)*n,t.value<=u&&(t.value=u,t.phase=ne.SUSTAIN,t.time=0);break;case ne.SUSTAIN:t.time+=n,t.value=u;break;case ne.RELEASE:t.time+=n,d<=0?(t.value=0,t.phase=ne.IDLE,t.time=0):(t.value-=1/d*n,t.value<=0&&(t.value=0,t.phase=ne.IDLE,t.time=0));break}return{outputs:{value:Math.max(0,Math.min(1,t.value))},ui:{value:t.value,phase:t.phase,time:t.time}}},inspectInputs:!0});m(ai);function li(e){let n=e;return{next:()=>(n=(1103515245*n+12345)%2147483648,n/2147483647)}}const ci=V({id:"math.random",version:"1.1.0",displayName:"Random",metadata:{category:"Math",keywords:["random","stochastic","noise","seed","white"],description:"Generates a random number (0-1). Supports on-trigger or free-run modes."},inputs:{trigger:{type:A,description:"Trigger Signal",allowMultiConnection:!0}},config:{seed:{kind:"atomic",type:"number",defaultValue:12345},mode:{kind:"atomic",type:"string",defaultValue:"on-trigger"}},outputs:{value:{type:a,description:"Random Value"}},autoBroadcast:{trigger:{combine:{reduce:"flatten"}}},ui:{inspector:{fields:[{type:"tab-bar",label:"Mode",path:"mode",options:[{label:"On Trigger",value:"on-trigger"},{label:"Free Run",value:"free-run"}],default:"on-trigger"},{type:"number",label:"Seed",path:"seed",default:12345}]}},compileConfig:e=>({mode:e.mode||e.values?.mode||"on-trigger",seed:e.seed||e.values?.seed||12345}),computeForwardPorts:(e,i)=>{const o=i.mode||"on-trigger",t={};return o==="on-trigger"&&(t.trigger={type:A,description:"Trigger Signal",allowMultiConnection:!0}),{inputs:{kind:"record",fields:t},outputs:{kind:"record",fields:{value:a}}}},isRealtime:e=>e.mode==="free-run",shouldRecompileOnConfigChange:e=>!0,createState:e=>{const o=e?.seed||12345,t=li(o);return{generator:t,currentValue:t.next()}},execute:(e,i,o,t)=>{const n=i.mode||"on-trigger",s=e.trigger;if(n==="free-run")t.currentValue=t.generator.next();else if(Array.isArray(s))for(const r of s)r.type==="note_on"&&(r.velocity??0)>0&&(t.currentValue=t.generator.next());return{value:t.currentValue}}});m(ci);const ui=[{type:"string",label:"Device ID",path:"deviceId",placeholder:"Optional Device ID"}],di=[{type:"number",label:"Channel",path:"channel",min:1,max:16,step:1},{type:"number",label:"CC",path:"cc",min:0,max:127,step:1},{type:"string",label:"Device ID",path:"deviceId",placeholder:"Optional Device ID"}],pi=V({id:"midi.input",version:"1.0.0",displayName:"MIDI Input",metadata:{category:x.IO,keywords:["midi","input","source"],description:"Reads raw MIDI messages from a specific device."},inputs:{},config:{deviceId:{kind:"atomic",type:"string",optional:!0}},outputs:{stream:A},ui:{inspector:{fields:ui}},isRealtime:()=>!0,usesMidiDeviceIO:()=>!0,execute:(e,i,o)=>{const t=o.midi?.events,n=i.deviceId;return t&&n?{stream:t.filter(r=>r.deviceId===n)}:{stream:t||[]}},compileConfig:e=>({deviceId:e.deviceId})}),fi=V({id:"midi.cc.input",version:"1.0.0",displayName:"MIDI CC Input",metadata:{category:x.IO,keywords:["midi","cc","input"],description:"Reads a MIDI CC value directly from the environment."},inputs:{},config:{channel:a,cc:a,deviceId:{kind:"atomic",type:"string",optional:!0}},outputs:{value:a},ui:{inspector:{fields:di}},isRealtime:()=>!0,usesMidiDeviceIO:()=>!0,execute:(e,i,o)=>{const t=i.channel||1,n=i.cc||0;i.deviceId;const s=`${t}:${n}`;return{value:o.midi?.values.get(s)??0}},compileConfig:e=>({channel:e.channel??1,cc:e.cc??0,deviceId:e.deviceId})});m(pi);m(fi);const mi=[{type:"number",label:"Channel",path:"channel",min:1,max:16,step:1},{type:"number",label:"CC",path:"cc",min:0,max:127,step:1}],yi=V({id:"midi.cc",version:"1.0.0",displayName:"MIDI CC",metadata:{category:x.IO,keywords:["midi","cc","control change"],description:"Reads MIDI Control Change messages from a stream."},inputs:{stream:{type:A,allowMultiConnection:!0}},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},config:{channel:a,cc:a},outputs:{value:a},ui:{inspector:{fields:mi}},createState:()=>({value:0}),execute:(e,i,o,t)=>{const n=i.channel||1,s=i.cc||0,r=e.stream||[];if(r&&Array.isArray(r))for(const l of r)l.type==="cc"&&l.channel===n&&l.cc===s&&(t.value=l.value??0);return{value:t.value}},compileConfig:e=>({channel:e.channel??1,cc:e.cc??0})});m(yi);const hi=[{type:"number",label:"Channel",path:"channel",min:1,max:16,step:1},{type:"number",label:"Note",path:"note",min:0,max:127,step:1}],gi=V({id:"midi.note",version:"1.0.0",displayName:"MIDI Note",metadata:{category:x.IO,keywords:["midi","note","keyboard"],description:"Reads MIDI Note messages from a stream."},inputs:{stream:{type:A,allowMultiConnection:!0}},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},config:{channel:a,note:a},outputs:{note:{kind:"atomic",type:"number",optional:!0},velocity:a,gate:a},ui:{inspector:{fields:hi}},createState:()=>({velocity:0,gate:0}),execute:(e,i,o,t)=>{const n=i.channel||1,s=i.note||60,r=e.stream||[];if(r&&Array.isArray(r))for(const l of r)l.channel===n&&(l.type==="note_on"&&l.note===s?(t.velocity=l.velocity??0,t.gate=1):l.type==="note_off"&&l.note===s&&(t.gate=0));return{note:t.gate?s:null,velocity:t.velocity,gate:t.gate}},compileConfig:e=>({channel:e.channel??1,note:e.note??60})});m(gi);const vi=[{type:"number",label:"Channel",path:"channel",min:1,max:16,step:1},{type:"number",label:"Root Note",path:"rootNote",min:0,max:127,step:1},{type:"select",label:"Priority",path:"priority",options:[{label:"Last Note",value:"last"},{label:"Low Note",value:"low"},{label:"High Note",value:"high"}]}],bi=V({id:"midi.to_mono",version:"1.0.0",displayName:"MIDI to Mono",metadata:{category:x.IO,keywords:["midi","mono","converter"],description:"Converts a polyphonic MIDI stream to a monophonic note signal."},inputs:{stream:{type:A,allowMultiConnection:!0}},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},config:{channel:a,rootNote:a,priority:{kind:"atomic",type:"string",optional:!0}},outputs:{note:{kind:"atomic",type:"number",optional:!0},velocity:a,gate:a,frequency:a},ui:{inspector:{fields:vi}},createState:()=>({activeNotes:[],gate:0}),execute:(e,i,o,t)=>{const n=i.channel||1,s=i.rootNote??60,r=e.stream||[];if(t.activeNotes||(t.activeNotes=[]),r&&Array.isArray(r))for(const c of r)c.channel===n&&(c.type==="note_on"?(t.activeNotes=t.activeNotes.filter(u=>u.note!==c.note),t.activeNotes.push({note:c.note,velocity:c.velocity??0})):c.type==="note_off"&&(t.activeNotes=t.activeNotes.filter(u=>u.note!==c.note)));const l=t.activeNotes.length>0?t.activeNotes[t.activeNotes.length-1]:null;if(l){t.gate=1;const c=l.note-s,u=440*Math.pow(2,(l.note-69)/12);return{note:c,velocity:l.velocity,gate:1,frequency:u}}else return t.gate=0,{note:null,velocity:0,gate:0,frequency:0}},compileConfig:e=>({channel:e.channel??1,rootNote:e.rootNote??60,priority:e.priority??"last"})});m(bi);const xi=[{type:"number",label:"Channel",path:"channel",min:1,max:16,step:1},{type:"number",label:"Note",path:"note",min:0,max:127,step:1}],Ii=V({id:"midi.filter",version:"1.0.0",displayName:"MIDI Filter",metadata:{category:x.IO,keywords:["midi","filter","note"],description:"Filters MIDI events, allowing only specific Note On/Off messages through."},inputs:{stream:{type:A,allowMultiConnection:!0},channel:{type:a,description:"MIDI Channel (1-16)",defaultValue:1},note:{type:a,description:"Note Number (0-127)",defaultValue:60}},config:{},outputs:{stream:A},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},ui:{inspector:{fields:xi}},execute:(e,i)=>{const o=e.channel??1,t=e.note??60,n=e.stream||[],s=[];if(n&&Array.isArray(n))for(const r of n)r.channel===o&&(r.type==="note_on"||r.type==="note_off")&&r.note===t&&s.push(r);return{stream:s}},compileConfig:e=>({channel:e.channel??1,note:e.note??60})});m(Ii);const ki=V({id:"midi.pitch",version:"1.0.0",displayName:"MIDI Pitch",metadata:{category:x.IO,keywords:["midi","pitch","transpose","shift"],description:"Transposes MIDI Note events by a specified amount."},inputs:{stream:{type:A,allowMultiConnection:!0},pitch:{type:a,description:"Pitch shift amount (semitones)",defaultValue:0,range:[-24,24]}},config:{},outputs:{stream:A},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},execute:(e,i)=>{const o=e.pitch??0,t=e.stream||[];return!t||!Array.isArray(t)?{stream:[]}:{stream:t.map(s=>{if(s.type==="note_on"||s.type==="note_off"){const r=Math.max(0,Math.min(127,Math.floor(s.note+o)));return{...s,note:r}}return s})}},compileConfig:e=>({pitch:e.pitch??0})});m(ki);const Ni=V({id:"midi.trigger",version:"1.0.0",displayName:"MIDI Trigger",metadata:{category:x.IO,keywords:["midi","trigger","bang","button"],description:"Manually sends a Middle C Note On/Off pair when triggered."},inputs:{trigger:{type:a,description:"Trigger Signal",suppressInputEditor:!0}},config:{pitch:{...a,defaultValue:60},velocity:{...a,defaultValue:1,range:[0,1]},trigger:a},outputs:{stream:A},createState:()=>({lastTrigger:0,initialized:!1}),execute:(e,i,o,t)=>{const n=i.pitch||60,s=i.velocity||1,r=e.trigger||0;o.clock.dt;const l=[];return t.initialized?(r>t.lastTrigger&&(l.push({type:"note_on",channel:1,note:n,velocity:s,deviceId:"virtual",time:0}),l.push({type:"note_off",channel:1,note:n,velocity:0,deviceId:"virtual",time:0}),o.markSelfDirty&&o.markSelfDirty()),t.lastTrigger=r,{stream:l}):(t.lastTrigger=r,t.initialized=!0,{stream:l})},compileConfig:e=>({pitch:e.pitch??60,velocity:e.velocity??1,trigger:e.trigger}),ui:{inspector:{fields:[{type:"button",label:"Trigger",path:"trigger",text:"Bang"},{type:"number",label:"Pitch",path:"pitch",min:0,max:127,step:1,default:60},{type:"number",label:"Velocity",path:"velocity",min:0,max:1,step:.01,default:1}]}}});m(Ni);const _i=V({id:"midi.merge",version:"1.0.0",displayName:"MIDI Merge",metadata:{category:x.IO,keywords:["midi","merge","combine","mix"],description:"Merges multiple MIDI streams into one using auto-broadcast."},inputs:{stream:{type:A,description:"Input Streams",allowMultiConnection:!0}},outputs:{stream:A},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},config:{},execute:(e,i,o)=>({stream:e.stream||[]}),compileConfig:()=>({})});m(_i);const Mi=V({id:"midi.select",version:"1.0.0",displayName:"MIDI Select",metadata:{category:x.IO,keywords:["midi","select","router","switch","demux"],description:"Routes MIDI events to different ports based on note pitch."},inputs:{stream:{type:A,allowMultiConnection:!0}},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},config:{count:{...a,defaultValue:4},root:{...a,defaultValue:60},skip:{...a,defaultValue:1}},outputs:{},dynamicOutputType:A,isRealtime:()=>!0,computeForwardPorts:(e,i,o)=>{const t=i.count||4,n={};for(let s=0;s<t;s++)n[s.toString()]={...A,hint:"midi-stream",description:`Offset ${s}`};return n.rem={...A,hint:"midi-stream",description:"Remainder"},{inputs:{kind:"record",fields:{stream:A}},outputs:{kind:"record",fields:n}}},shouldRecompileOnConfigChange:e=>!0,execute:(e,i,o)=>{const t=e.stream||[],n=i.count||4,s=i.root||60,r=i.skip||1,l={};for(let c=0;c<n;c++)l[c.toString()]=[];if(l.rem=[],t&&Array.isArray(t)){for(const c of t)if(c.type==="note_on"||c.type==="note_off"){const u=c.note-s;if(u>=0&&u%r===0){const d=u/r;if(d>=0&&d<n){l[d.toString()].push(c);continue}}l.rem.push(c)}}return{...l}},compileConfig:e=>({count:e.count??4,root:e.root??60,skip:e.skip??1}),ui:{inspector:{fields:[{type:"number",label:"Output Count",path:"count",min:1,max:128,step:1,default:4},{type:"number",label:"Root Note",path:"root",min:0,max:127,step:1,default:60},{type:"number",label:"Skip (Semitones)",path:"skip",min:1,max:24,step:1,default:1}]}}});m(Mi);const wi=V({id:"midi.onchange",version:"1.0.0",displayName:"MIDI On Change",metadata:{category:x.IO,keywords:["midi","trigger","change","delta"],description:"Triggers a note when input value changes."},inputs:{value:{type:Q,description:"Input Value"}},config:{rootNote:{...a,defaultValue:60}},outputs:{stream:A},ui:{inspector:{fields:[{type:"number",label:"Root Note",path:"rootNote",min:0,max:127,step:1,default:60}]}},isRealtime:()=>!0,createState:()=>({lastValue:void 0}),execute:(e,i,o,t)=>{const n=e.value,s=i.rootNote??60,r=[];let l=!1;return typeof n=="number"&&typeof t.lastValue=="number"?Math.abs(n-t.lastValue)>1e-5&&(l=!0):n!==t.lastValue&&(l=!0),l?(r.push({type:"note_on",note:s,velocity:1,channel:1,time:0,deviceId:"onchange"}),r.push({type:"note_off",note:s,velocity:0,channel:1,time:0,deviceId:"onchange"}),t.lastValue=n):t.lastValue===void 0&&n!==void 0&&(t.lastValue=n),{stream:r}},compileConfig:e=>({rootNote:e.rootNote??60})});m(wi);const Ze={};for(let e=1;e<=16;e++)Ze[`w${e}`]={type:a,defaultValue:1,optional:!0,description:`Weight ${e}`};const Ci=V({id:"midi.onrange",version:"1.0.0",displayName:"MIDI On Range",metadata:{category:x.IO,keywords:["midi","trigger","range","zone"],description:"Triggers notes based on value position in weighted zones."},inputs:{value:{type:a,description:"Input Value"},start:{type:a,defaultValue:0},end:{type:a,defaultValue:1},...Ze},config:{rootNote:{...a,defaultValue:60,description:"Root Note"},zoneCount:{...a,defaultValue:1,description:"Number of Zones"},noteSkip:{...a,defaultValue:1}},outputs:{stream:A},ui:{inspector:{fields:[{type:"number",label:"Root Note",path:"rootNote",min:0,max:127,step:1,default:60},{type:"number",label:"Zone Count",path:"zoneCount",min:1,max:16,step:1,default:1},{type:"number",label:"Note Skip",path:"noteSkip",min:1,max:12,step:1,default:1}]}},isRealtime:()=>!0,createState:()=>({activeZoneIndex:null}),computeForwardPorts:(e,i)=>{const o=i.zoneCount??1,t={value:{...a},start:{...a,defaultValue:0},end:{...a,defaultValue:1}};if(o>1)for(let n=1;n<=o;n++)t[`w${n}`]={...a,defaultValue:1,description:`Weight ${n}`};return{inputs:{kind:"record",fields:t},outputs:{kind:"record",fields:{stream:A}}}},shouldRecompileOnConfigChange:()=>!0,execute:(e,i,o,t)=>{const n=e.value??0,s=e.start??0,r=e.end??1,l=i.rootNote??60,c=i.zoneCount??1,u=i.noteSkip??1;let d=s,h=r;h<d&&(h=s,d=r);const p=[];if(n>=d&&n<=h){let f=0;if(c>1){const y=[];let v=0;for(let b=1;b<=c;b++){let _=e[`w${b}`];_&&typeof _=="object"&&"value"in _&&(_=_.value),_=_??1,typeof _!="number"&&(_=1),y.push(_),v+=_}if(v<=0)f=0;else{const b=h-d,_=(b===0?0:(n-d)/b)*v;let M=0;for(let q=0;q<c;q++)if(M+=y[q],_<=M){f=q;break}f>=c&&(f=c-1)}}else f=0;if(t.activeZoneIndex===null){const y=l+f*u;p.push({type:"note_on",note:y,velocity:1,channel:1,time:0,deviceId:"onrange"}),t.activeZoneIndex=f}else if(t.activeZoneIndex!==f){const y=l+t.activeZoneIndex*u;p.push({type:"note_off",note:y,velocity:0,channel:1,time:0,deviceId:"onrange"});const v=l+f*u;p.push({type:"note_on",note:v,velocity:1,channel:1,time:0,deviceId:"onrange"}),t.activeZoneIndex=f}}else if(t.activeZoneIndex!==null){const f=l+t.activeZoneIndex*u;p.push({type:"note_off",note:f,velocity:0,channel:1,time:0,deviceId:"onrange"}),t.activeZoneIndex=null}return{stream:p}},compileConfig:e=>({rootNote:e.rootNote??60,zoneCount:e.zoneCount??1,noteSkip:e.noteSkip??1})});m(Ci);const Xe={type:"tab-bar",label:"Mode",path:"mode",options:[{label:"Time",value:"time"},{label:"Beats",value:"beats"}],default:"time"},Si={type:"tab-bar",label:"Beat Denom",path:"beatDenom",options:[{label:"1/64",value:.015625},{label:"1/32",value:.03125},{label:"1/16",value:.0625},{label:"1/8",value:.125},{label:"1/4",value:.25},{label:"1/2",value:.5},{label:"1/1",value:1}],default:.25},Ti=[Xe],Vi=V({id:"midi.delay",version:"1.0.0",displayName:"MIDI Delay",metadata:{category:x.Utility,keywords:["midi","delay","time","beats"],description:"Delays MIDI events by a specified duration."},inputs:{stream:{type:A,allowMultiConnection:!0},duration:{...a,defaultValue:.25}},config:{mode:{...Ye,defaultValue:"time"}},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},outputs:{stream:A},ui:{inspector:{fields:Ti}},isRealtime:()=>!0,createState:()=>({queue:[]}),execute:(e,i,o,t)=>{const n=e.stream||[],s=e.duration||0,r=i.mode||"time";let l=0;if(r==="beats"?l=o.clock.beat:l=o.time||0,t.queue||(t.queue=[]),n&&Array.isArray(n))for(const d of n)t.queue.push({event:d,releaseTime:l+s});const c=[],u=[];for(const d of t.queue)d.releaseTime<=l?c.push(d.event):u.push(d);return t.queue=u,{stream:c}},compileConfig:e=>({mode:e.mode??"time"})});m(Vi);const Ai=V({id:"midi.istrigger",version:"1.0.0",displayName:"MIDI Is Trigger",metadata:{category:x.Logic,keywords:["midi","check","trigger","gate"],description:"Outputs 1 if the stream contains any Note On event, 0 otherwise."},inputs:{stream:{type:A,allowMultiConnection:!0}},autoBroadcast:{stream:{combine:{reduce:"flatten"}}},outputs:{result:a},createState:()=>({}),execute:(e,i,o,t)=>{const n=e.stream||[];let s=0;if(n&&Array.isArray(n)){for(const r of n)if(r.type==="note_on"){s=1;break}}return{result:s}}});m(Ai);const Oi=[Xe,Si,{type:"number",label:"Note",path:"note",min:0,max:127,default:60}],Ri=V({id:"midi.metronome",version:"1.0.0",displayName:"Metronome",metadata:{category:x.Utility,keywords:["midi","metronome","clock","beat","trigger"],description:"Generates MIDI note events at regular intervals."},inputs:{duration:{...a,defaultValue:1,description:"Interval duration (seconds or beats)",min:0,max:4}},config:{mode:{...Ye,defaultValue:"time"},beatDenom:{...a,defaultValue:.25},note:{...a,defaultValue:60}},outputs:{stream:A},ui:{inspector:{fields:Oi}},isRealtime:()=>!0,createState:()=>({lastTriggerTime:-99999,noteActive:!1}),execute:(e,i,o,t)=>{const n=e.duration||1,s=i.mode||"time",r=i.beatDenom||.25,l=i.note||60;let c=0,u=n;s==="beats"?(c=o.clock.beat,u=Math.round(n)*r*4,u<=0&&(u=r)):c=o.time||0;const d=[];if(t.lastTriggerTime===-99999)return t.lastTriggerTime=c,{stream:[]};const h=t.lastTriggerTime,p=Math.floor(h/u),y=Math.floor(c/u)-p;for(let v=1;v<=y;v++)d.push({type:"note_on",deviceId:"metronome",channel:1,note:l,velocity:1,time:0}),d.push({type:"note_off",deviceId:"metronome",channel:1,note:l,velocity:0,time:0});return t.lastTriggerTime=c,{stream:d}},compileConfig:e=>({mode:e.mode??"time",beatDenom:e.beatDenom??.25,note:e.note??60})});m(Ri);const qi=V({id:"time.time",version:"1.0.0",displayName:"Time",metadata:{category:x.Utility,keywords:["time","seconds","clock"],description:"Outputs the current execution time in seconds."},inputs:{},outputs:{time:a,delta:a},isRealtime:()=>!0,execute:(e,i,o)=>({time:o.time||0,delta:o.clock.dt||0})}),Ei=V({id:"time.beat",version:"1.0.0",displayName:"Beat",metadata:{category:x.Utility,keywords:["beat","bar","clock","tempo"],description:"Outputs the current beat number."},inputs:{},outputs:{beat:a,delta:a},isRealtime:()=>!0,createState:()=>({lastBeat:-1}),execute:(e,i,o,t)=>{const n=o.clock.beat||0;let s=0;return t.lastBeat>=0&&(s=n-t.lastBeat),t.lastBeat=n,{beat:n,delta:s}}});m(qi);m(Ei);const Me={kind:"atomic",type:"number"},Ve=16,Di=[{type:"number",label:"Target Note",path:"targetNote"}],Pi=V({id:"nicepattern.rhythmic_generator",version:"1.0.0",displayName:"Rhythmic Generator",metadata:{category:"NicePattern",keywords:["rhythm","generator","sequence","euclidean"],description:"Generates a rhythmic sequence based on density."},config:{targetNote:a},inputs:{density:{...a,defaultValue:.5}},outputs:{seq_out:ae},ui:{inspector:{fields:Di}},execute:(e,i,o)=>{const t=i.targetNote||60,n=e.density??.5,s=[],r=Math.round(n*Ve);for(let l=0;l<Ve;l++)l*r%Ve<r?s.push({noteIndex:t,velocity:1,hold:!1}):s.push({noteIndex:null,velocity:0,hold:!1});return{seq_out:s}},compileConfig:e=>({targetNote:e.targetNote??60})});m(Pi);class we{constructor(i){this.state=i}next(){let i=this.state+=1831565813;return i=Math.imul(i^i>>>15,i|1),i^=i+Math.imul(i^i>>>7,i|61),((i^i>>>14)>>>0)/4294967296}nextRange(i,o){return Math.floor(this.next()*(o-i+1))+i}}const Li=16,Fi=[{type:"number",label:"Min Note",path:"minNote"},{type:"number",label:"Max Note",path:"maxNote"},{type:"number",label:"Seed",path:"seed"}],ji=V({id:"nicepattern.chaos_generator",version:"1.0.0",displayName:"Chaos Generator",metadata:{category:"NicePattern",keywords:["chaos","random","generator","sequence","stochastic"],description:"Generates a random sequence of notes."},config:{minNote:a,maxNote:a,seed:a},inputs:{density:{...a,defaultValue:.5}},outputs:{seq_out:ae},ui:{inspector:{fields:Fi}},execute:(e,i,o)=>{const{minNote:t,maxNote:n,seed:s}=i,r=e.density??.5,l=new we(s??12345),c=[];for(let u=0;u<Li;u++)if(l.next()<r){const d=l.nextRange(t||60,n||60);c.push({noteIndex:d,velocity:l.next()*.5+.5,hold:!1})}else c.push({noteIndex:null,velocity:0,hold:!1});return{seq_out:c}},compileConfig:e=>({minNote:e.minNote??60,maxNote:e.maxNote??60,seed:e.seed??12345})});m(ji);class Ne{constructor(i){this.config=i,this.output=0,this.lastActive=!1}update(i,o,t){let s=i.noteIndex!==null&&i.noteIndex!==void 0;if(s){let r=!1;this.lastActive?t&&!i.hold&&(this.onRelease(),r=!0):r=!0,r&&this.onTrigger(i.velocity,i.noteIndex)}else this.lastActive&&this.onRelease();this.process(s,i,o),this.lastActive=s}forceRelease(){this.onRelease(),this.lastActive=!1,this.output=0}getValue(){return this.output}}class zi extends Ne{onTrigger(i,o){this.output=i}onRelease(){this.output=0}process(i){i&&this.output===0&&(this.output=1)}previewSequence(i,o){return i.map(t=>t.noteIndex!==null&&t.noteIndex!==void 0?t.velocity:0)}}class Bi extends Ne{constructor(i,o=.96){super(i),this.decayRate=.96,this.decayRate=o}onTrigger(i,o){this.output=i}onRelease(){this.output=0}process(i,o){i&&(this.output*=this.decayRate)}previewSequence(i,o){const t=[];let n=0,s=!1;for(const r of i){const l=r.noteIndex!==null&&r.noteIndex!==void 0;l&&!s?n=r.velocity:!l&&s&&(n=0),l&&(n*=this.decayRate),t.push(n),s=l}return t}}class $i extends Ne{constructor(){super(...arguments),this.phase=0,this.duty=.5,this.freq=.2}onTrigger(i,o){this.duty=.5}onRelease(){}process(i,o,t){if(!i){this.output*=.85;return}this.duty*=.98,this.phase+=this.freq,this.phase>1&&(this.phase-=1),this.output=this.phase<this.duty?1:0}previewSequence(i,o){const t=[];let n=0,s=0,r=.5,l=!1;for(const c of i){const u=c.noteIndex!==null&&c.noteIndex!==void 0;u&&!l&&(r=.5),u?(r*=.98,s+=this.freq,s>1&&(s-=1),n=s<r?1:0):n*=.85,t.push(n),l=u}return t}}class Gi extends Ne{onTrigger(i,o){}onRelease(){this.output*=.85}process(i){i?this.output=Math.random():this.output*=.85}previewSequence(i,o){const t=[];let n=0,s=!1;const l=(c=>()=>{c|=0,c=c+1831565813|0;var u=Math.imul(c^c>>>15,1|c);return u=u+Math.imul(u^u>>>7,61|u)^u,((u^u>>>14)>>>0)/4294967296})(12345);for(const c of i){const u=c.noteIndex!==null&&c.noteIndex!==void 0;!u&&s&&(n*=.85),u?n=l():n*=.85,t.push(n),s=u}return t}}class Ae extends Ne{constructor(i,o,t){super(i),this.osc=null,this.gain=null,this.filter=null,this.ctx=o,this.frequency=t??440}get audioContext(){return this.ctx}set audioContext(i){this.ctx=i}safeParam(i,o,t){if(Number.isFinite(o)&&Number.isFinite(t))try{i.setValueAtTime(o,t)}catch{}}initVoice(i,o){if(!this.ctx||this.ctx.state==="suspended")return;this.cleanup(),this.osc=this.ctx.createOscillator(),this.gain=this.ctx.createGain(),this.filter=this.ctx.createBiquadFilter();const t=Number.isFinite(this.frequency)&&this.frequency>0?this.frequency:440;this.safeParam(this.osc.frequency,t,i),this.filter.type="lowpass";const n=800+o*2e3;this.safeParam(this.filter.frequency,n,i),this.safeParam(this.gain.gain,0,i);try{this.gain.gain.linearRampToValueAtTime(o,i+.005),this.gain.gain.setTargetAtTime(0,i+.005,.1)}catch{}this.osc.connect(this.filter),this.filter.connect(this.gain),this.gain.connect(this.ctx.destination),this.osc.start(i)}retirePreviousVoice(i){if(!this.osc||!this.gain||!this.filter)return;const o=this.osc,t=this.gain,n=this.filter;this.osc=null,this.gain=null,this.filter=null;try{try{t.gain.cancelAndHoldAtTime(i)}catch{t.gain.cancelScheduledValues(i),this.safeParam(t.gain,t.gain.value,i)}t.gain.linearRampToValueAtTime(0,i+.005);const r=i+.005+.01;o.stop(r),o.onended=()=>{o.disconnect(),n.disconnect(),t.disconnect(),o.dispose?.(),n.dispose?.(),t.dispose?.()}}catch{o.disconnect(),n.disconnect(),t.disconnect()}}cleanup(){this.retirePreviousVoice(this.ctx?.currentTime??0)}onTrigger(i,o){if(this.ctx?.state!=="suspended"){if(o!=null){const t=440*Math.pow(2,(o-69)/12);Number.isFinite(t)&&(this.frequency=t)}this.initVoice(this.ctx?.currentTime??0,i)}}onRelease(){if(this.ctx?.state!=="suspended"&&this.gain){const i=this.ctx?.currentTime??0;try{this.gain.gain.cancelAndHoldAtTime(i)}catch{this.gain.gain.cancelScheduledValues(i),this.safeParam(this.gain.gain,this.gain.gain.value,i)}try{this.gain.gain.linearRampToValueAtTime(0,i+.005)}catch{}if(this.osc)try{this.osc.stop(i+.01)}catch{}}}process(i,o){i&&o.hold&&this.osc}previewSequence(i,o){const t=[];let n=!1;for(const s of i){const r=s.noteIndex!==null&&s.noteIndex!==void 0;r&&!n?t.push(s.velocity):t.push(0),n=r}return t}}function Ce(e,i,o){return V({id:e,version:"1.0.0",displayName:i,metadata:{category:"NicePattern",keywords:["layer","effect","modifier"],description:`Layer node: ${i}`},config:{},inputs:{midi_in:{type:A,description:"Input MIDI stream",allowMultiConnection:!0},prev_layer:{type:Me,description:"Previous layer output"}},outputs:{out:Me},autoBroadcast:{midi_in:{combine:{reduce:"flatten"}}},ui:{inspector:{fields:[]}},isRealtime:()=>!0,createState:(t,n)=>({layer:new o({}),lastActive:!1,activeVelocity:0,activeNote:null}),execute:(t,n,s,r)=>{const l=r.layer,c=t.midi_in||[];for(const p of c)p.type==="note_on"?(r.lastActive=!0,r.activeVelocity=p.velocity,r.activeNote=p.note):p.type==="note_off"&&r.activeNote===p.note&&(r.lastActive=!1,r.activeNote=null);const u={noteIndex:r.lastActive?r.activeNote??60:null,velocity:r.activeVelocity,hold:!1},d=c.some(p=>p.type==="note_on");return l.update(u,s.clock.dt,d),{out:l.getValue()}},compileConfig:t=>({})})}const Hi=Ce("nicepattern.gate_layer","Gate Layer",zi),Ui=Ce("nicepattern.exp_layer","Exponential Layer",Bi),Yi=Ce("nicepattern.pwm_layer","PWM Layer",$i),Wi=Ce("nicepattern.noise_layer","Noise Layer",Gi);m(Hi);m(Ui);m(Yi);m(Wi);const Zi=V({id:"nicepattern.tone_synth_layer",version:"1.0.0",displayName:"Tone Synth Layer",metadata:{category:"NicePattern",keywords:["synth","audio","sound","tone"],description:"Simple synthesizer layer using Tone.js."},config:{},inputs:{midi_in:{type:A,description:"Input MIDI stream",allowMultiConnection:!0},prev_layer:{type:Me,description:"Previous layer output"}},outputs:{out:Me},autoBroadcast:{midi_in:{combine:{reduce:"flatten"}}},ui:{inspector:{fields:[]}},isRealtime:()=>!0,createState:(e,i)=>({layer:new Ae({}),lastActive:!1,lastActiveNote:null,activeVelocity:0,contextId:""}),execute:(e,i,o,t)=>{const n=o.audio?.context;t.layer||(t.layer=new Ae({})),n&&t.contextId!==n.contextId&&(t.layer=new Ae({}),t.contextId=n.contextId);const s=t.layer,r=e.midi_in||[];let l=!1;for(const d of r)d.type==="note_on"?(t.lastActive=!0,t.lastActiveNote=d.note,t.activeVelocity=d.velocity,l=!0):d.type==="note_off"&&t.lastActiveNote===d.note&&(t.lastActive=!1,t.lastActiveNote=null);const c={noteIndex:t.lastActive?t.lastActiveNote:null,velocity:t.activeVelocity,hold:!1};return s.audioContext||(o.audio?.context?s.audioContext=o.audio.context:typeof window<"u"&&(s.audioContext=new(window.AudioContext||window.webkitAudioContext))),s.update(c,o.clock.dt,l),{out:s.getValue()}},compileConfig:e=>({})});m(Zi);function Qe(e){if(e===1)return[[0]];const i=Qe(e/2),o=[];for(let t=0;t<i.length;t++)o.push([...i[t],...i[t]]);for(let t=0;t<i.length;t++)o.push([...i[t],...i[t].map(n=>1-n)]);return o}function je(e){let i=0;for(let o=0;o<e.length-1;o++)e[o]!==e[o+1]&&i++;return i}function Xi(e,i){const o=Qe(8).sort((l,c)=>je(l)-je(c));o[0]=[1,1,1,1,1,1,1,1];const t=[0,1,2,3,4,5,6,7],n=new we(i);for(let l=t.length-1;l>0;l--){const c=n.nextRange(0,l);[t[l],t[c]]=[t[c],t[l]]}const s=Math.max(2,Math.min(8,e));return o.slice(0,s).map(l=>{const c=new Array(8);for(let u=0;u<8;u++)c[u]=l[t[u]];return c})}const Qi=[{type:"number",label:"Seed",path:"seed",step:1}],Ji=V({id:"nicepattern.orthomod",version:"1.0.0",displayName:"Orthomod",metadata:{category:"NicePattern",keywords:["envelope","modulation","orthogonal","hadamard"],description:"Orthogonal code-based envelope generator."},config:{seed:a},inputs:{midi_in:{type:A,description:"Trigger Input",allowMultiConnection:!0},decay:{type:a,defaultValue:1.2,description:"Decay Time (s)",range:[0,4],step:.01},curve:{type:a,defaultValue:1.5,description:"Response Curve",range:[.1,4],step:.1},relcurve:{type:a,defaultValue:12,description:"Release Curve",range:[.1,20],step:.1},resolution:{type:a,defaultValue:8,range:[2,8],step:1,description:"Codebook Size"},manual_phase:{type:a,defaultValue:-1,description:"Manual Phase Override (0-1)",suppressInputEditor:!0}},outputs:{env:{type:a,description:"Envelope Output (0-1)"},vec:{type:De,description:"Channel Values [c1, c2, c3, c4]"},ch1:{type:a,description:"Channel 1"},ch2:{type:a,description:"Channel 2"},ch3:{type:a,description:"Channel 3"},ch4:{type:a,description:"Channel 4"}},autoBroadcast:{midi_in:{combine:{reduce:"flatten"}}},ui:{inspector:{fields:Qi}},isRealtime:()=>!0,createState:()=>({linearEnv:0,gateOpen:!1,active:!1,codes:[],lastSeed:-1,lastResolution:-1,currentEffectiveCurve:1.5,phase:0}),execute:(e,i,o,t)=>{const n=o.clock.dt;t.phase+=n;const s=t.phase,r=e.decay,l=typeof r=="number"&&Number.isFinite(r)?Math.max(.001,r):1.2,c=e.curve,u=typeof c=="number"&&Number.isFinite(c)?Math.max(.001,c):1.5,d=e.relcurve,h=typeof d=="number"&&Number.isFinite(d)?Math.max(.1,d):12,p=e.resolution,f=typeof p=="number"&&Number.isFinite(p)?Math.floor(Math.max(2,Math.min(8,p))):8,y=i.seed??12345,v=e.manual_phase,b=typeof v=="number"&&Number.isFinite(v)?v:-1;(y!==t.lastSeed||f!==t.lastResolution)&&(t.codes=Xi(f,y),t.lastSeed=y,t.lastResolution=f);const I=(e.midi_in||[]).flat();for(const R of I)R.type==="note_on"?(t.linearEnv=1,t.gateOpen=!0,t.active=!0):R.type==="note_off"&&(t.gateOpen=!1);let _=0;b>=0?(t.linearEnv=Math.max(0,Math.min(1,b)),t.active=!0,t.currentEffectiveCurve=1):(t.active&&(t.linearEnv-=n/Math.max(.01,l),t.linearEnv<=0&&(t.linearEnv=0,t.active=!1)),!t.gateOpen&&t.active?t.currentEffectiveCurve=h:t.currentEffectiveCurve=u);const M=Math.max(0,t.linearEnv),q=t.currentEffectiveCurve;_=Math.pow(M,q),Number.isNaN(_)&&(_=0);let K=1-_;K=Math.max(0,Math.min(.999,K));const D=t.codes.length,C=Math.floor(K*D),W=t.codes[C]||t.codes[0],j=15,se=s*j%1>.5?1:0,g=Math.abs(Math.sin(s*j*Math.PI*2)),N=[0,0,0,0],w=[0,0,0,0];if(t.active)for(let R=0;R<4;R++){const H=W[R*2]||0,U=W[R*2+1]||0;let $=0;H===0&&U===0?$=0:H===1&&U===1?$=1:H===1&&U===0?$=se:H===0&&U===1&&($=g),w[R]=$,N[R]=$*_,Number.isNaN(N[R])&&(N[R]=0)}const T=R=>Number.isFinite(R)?R:0;return{outputs:{env:T(_),vec:N.map(T),ch1:T(N[0]),ch2:T(N[1]),ch3:T(N[2]),ch4:T(N[3])},ui:{codes:t.codes,env:T(_),vec:N.map(T),rawVec:t.active?w.map(T):[0,0,0,0],activeCodeIndex:C,gate:t.gateOpen?1:0}}},compileConfig:e=>({seed:e?.seed??12345})});m(Ji);const Ki=()=>({initialized:!1,contextId:"",masterGain:null,voices:[],lastRoot:-1}),en=V({id:"nicepattern.tone4",version:"1.0.0",displayName:"Tone 4",metadata:{category:"NicePattern",keywords:["synth","additive","oscillator","audio"],description:"4-voice additive synth driven by vector input."},inputs:{vec:{type:De,description:"Modulation Vector [c1, c2, c3, c4]"},root:{type:a,defaultValue:60,description:"Root Note (MIDI)",range:[0,127]},gain:{type:a,defaultValue:.5,description:"Master Volume"}},outputs:{},isRealtime:()=>!0,createState:Ki,execute:(e,i,o,t)=>{const n=o.audio?.context;if(!n||n.state==="suspended")return{};const s=n.currentTime;if(!t.initialized||t.contextId!==n.contextId){t.masterGain=n.createGain(),t?.masterGain?.connect(n.destination);const p=[1,1.5,2,3],f=["square","sawtooth","triangle","sine"];t.voices=p.map((y,v)=>{const b=n.createOscillator(),I=n.createGain();return b.type=f[v],b.connect(I),I.connect(t.masterGain),b.start(s),I.gain.setValueAtTime(0,s),{osc:b,gain:I,freqRatio:y,wave:f[v]}}),t.initialized=!0,t.contextId=n.contextId,t.lastRoot=-1}const r=Math.max(0,Math.min(1,e.gain??.5));t.masterGain&&t.masterGain.gain.setTargetAtTime(r,s,.05);const l=e.root,c=typeof l=="number"&&Number.isFinite(l)?Math.floor(Math.max(0,Math.min(127,l))):69,u=440*Math.pow(2,(c-69)/12);Math.abs(u-t.lastRoot)>.01&&(t.voices.forEach(p=>{t.lastRoot===-1?p.osc.frequency.setValueAtTime(u*p.freqRatio,s):p.osc.frequency.setTargetAtTime(u*p.freqRatio,s,.05)}),t.lastRoot=u);const d=e.vec,h=Array.isArray(d)&&d.length===4?d:[0,0,0,0];return t.voices.forEach((p,f)=>{const y=Math.max(0,Math.min(1,h[f]??0));p.gain.gain.setTargetAtTime(y,s,.02)}),{}}});m(en);const oe={gravity:800,magnetEpsilon:50,physicsRate:120,solverSteps:16,sphereCount:16,magnetRange:800,height:600};class ze{constructor(i,o,t,n,s,r){this.id=i,this.radius=6+r.next()*8,this.mass=this.radius,this.restLength=20+Math.pow(r.next(),2)*150;const l=o*.1,c=o-l*2;this.x=l+c/(s-1)*n,this.y=t-this.restLength,this.vx=0,this.vy=0,this.isLatched=!1,this.tensionRatio=0,this.currentSpringForce=0,this.currentMagForce=0}update(i,o,t,n,s){this.currentMagForce=0,this.currentSpringForce=0,this.tensionRatio=0;const l=(o-this.restLength-this.y)*s.springK,u=s.gravity*this.mass+l;this.currentSpringForce=Math.max(0,u);const d=f=>{if(f>=oe.magnetRange)return 0;const y=oe.magnetEpsilon/(f*f+oe.magnetEpsilon);return s.magnetStrength*y},h=d(0);if(n){const f=this.y-this.radius-t;if(this.isLatched||f<=2)if(h>u){this.isLatched=!0,this.y=t+this.radius,this.vy=0,this.currentMagForce=h,this.tensionRatio=Math.max(0,Math.min(1,u/h));return}else this.isLatched=!1}else this.isLatched=!1;let p=u;if(n&&!this.isLatched){const f=Math.max(0,this.y-this.radius-t),y=-d(f);this.currentMagForce=Math.abs(y),p+=y}this.vy+=p/this.mass*i,this.vy*=s.damping,this.y+=this.vy*i,this.y+this.radius>o&&(this.y=o-this.radius,this.vy*=-.5),this.y-this.radius<t&&(this.y=t+this.radius,n?this.vy<0&&(this.vy=0):this.vy*=-.6)}}const tn=[{type:"number",label:"Seed",path:"seed",step:1,min:0,max:999999}],nn=V({id:"nicepattern.magneto",version:"1.0.0",displayName:"Magneto",metadata:{category:"NicePattern",keywords:["envelope","physics","magnet","modulator"],description:"Physics-based magnetic envelope generator."},config:{seed:{...a,defaultValue:1337}},inputs:{midi_in:{type:A,description:"Trigger Input",allowMultiConnection:!0},attack:{type:a,defaultValue:.2,range:[.01,2],step:.01,description:"Attack Time (s)"},decay:{type:a,defaultValue:.25,range:[.01,2],step:.01,description:"Decay Time (s)"},sustain:{type:a,defaultValue:.6,range:[0,1],step:.01,description:"Sustain Level (0-1)"},release:{type:a,defaultValue:.3,range:[.01,5],step:.01,description:"Release Time (s)"},peak:{type:a,defaultValue:.9,range:[.1,1],step:.01,description:"Peak Level (0-1, inverted)"},mag_flux:{type:a,defaultValue:2e6,range:[1e5,4e6],step:1e4,description:"Magnet Strength"},spring_k:{type:a,defaultValue:25e3,range:[1e3,5e4],step:100,description:"Spring Stiffness"},damping:{type:a,defaultValue:.999,range:[.9,1],step:.001,description:"Damping Factor"}},outputs:{env:{type:a,description:"Envelope Output (Tension)"},vec:De,ch1:{type:a,description:"Channel 1 (Tension)"},ch2:{type:a,description:"Channel 2 (Extension)"},ch3:{type:a,description:"Channel 3 (Spring Force)"},ch4:{type:a,description:"Channel 4 (Mag Force)"}},autoBroadcast:{midi_in:{combine:{reduce:"flatten"}}},ui:{inspector:{fields:tn}},isRealtime:()=>!0,createState:()=>{const e=[],o=oe.height,t=new we(1337);for(let n=0;n<oe.sphereCount;n++)e.push(new ze(n,600,o,n,oe.sphereCount,t));return{spheres:e,plateY:40,phase:"IDLE",sustainProgress:0,accumulator:0,lastGate:!1,isTouchingSim:!1,touchY:0}},onMessage:(e,i)=>{i.type==="manual_interaction"&&(e.isTouchingSim=i.active,typeof i.y=="number"&&(e.touchY=i.y))},execute:(e,i,o,t)=>{const n=o.clock.dt,s=e.midi_in||[];let r=t.lastGate;for(const P of s)P.type==="note_on"?r=!0:P.type==="note_off"&&(r=!1);const l=Math.max(.005,e.attack??.2),c=Math.max(.005,e.decay??.25),u=e.sustain??.6,d=Math.max(.005,e.release??.3),h=e.peak??.9,p=i.seed??1337,f=e.mag_flux??2e6,y=e.spring_k??25e3,v=e.damping??.999;if(t.currentSeed!==p||t.spheres.length===0){t.currentSeed=p;const P=new we(p);t.spheres=[];const O=600,ee=oe.height;for(let Z=0;Z<oe.sphereCount;Z++)t.spheres.push(new ze(Z,O,ee,Z,oe.sphereCount,P))}const b=oe.height,I=b*.95,_=b*.1,M=40,q=_+h*(I-_),K=_+u*(I-_),D=Math.min(1,.05/Math.max(.001,l)),C=Math.min(1,.02/Math.max(.001,c)),W=Math.min(1,.02/Math.max(.001,d));r&&!t.lastGate?(t.phase="ATTACK",t.sustainProgress=0):!r&&t.lastGate&&(t.phase="RELEASE",t.sustainProgress=0),t.lastGate=r,t.accumulator+=n;const j=1/oe.physicsRate;let se=!1,g=0;for(;t.accumulator>=j&&g<5;){t.accumulator-=j,g++;let P=M,O=W;t.isTouchingSim?(t.phase="MANUAL",se=!0,P=t.touchY,P=Math.max(M,Math.min(I,P)),O=D,t.sustainProgress=0):r?((t.phase==="IDLE"||t.phase==="RELEASE"||t.phase==="MANUAL")&&(t.phase==="MANUAL"?t.phase="ATTACK":(t.phase="ATTACK",t.sustainProgress=0)),t.phase==="ATTACK"?(P=q,O=D,Math.abs(t.plateY-q)<10&&(t.phase="DECAY")):t.phase==="DECAY"?(P=K,O=C,Math.abs(t.plateY-K)<5&&(t.phase="SUSTAIN")):t.phase==="SUSTAIN"&&(P=K,O=.1,t.sustainProgress+=(1-t.sustainProgress)*2*j),se=!0):(t.phase="RELEASE",P=M,O=W,Math.abs(t.plateY-M)<15?(se=!1,t.phase="IDLE"):se=!0);const ee=P-t.plateY;t.plateY+=ee*O;const Z=j/oe.solverSteps,le={gravity:oe.gravity,springK:y,magnetStrength:f,damping:v};for(let E=0;E<oe.solverSteps;E++)t.spheres.forEach(pe=>{pe.update(Z,b,t.plateY,se,le)})}t.accumulator>j&&(t.accumulator=0);let N=0,w=0,T=0,R=0,H=0;t.spheres.forEach(P=>{P.isLatched&&(H++,N+=P.tensionRatio);const O=Math.max(0,b-P.restLength-P.y);w+=O,T+=P.currentSpringForce,R+=P.currentMagForce});const U=H>0?N/H:0,$=Math.min(1,w/(b*oe.sphereCount*.4)),te=oe.sphereCount*y*b*.3,k=oe.sphereCount*f,z=Math.min(1,T/te),S=Math.min(1,R/k),L=[U,$,z,S],B={plateY:t.plateY,phase:t.phase,sustainProgress:t.sustainProgress,spheres:t.spheres.map(P=>({x:P.x,y:P.y,r:P.radius,l:P.isLatched,t:P.tensionRatio})),adsr:{attack:l,decay:c,sustain:u,release:d,peak:h},seed:p};return{outputs:{env:U,vec:L,ch1:U,ch2:$,ch3:z,ch4:S},ui:B}},compileConfig:e=>({seed:e?.seed??1337})});m(nn);const Oe=16,on=V({id:"seq.tomidi",version:"1.0.0",displayName:"To MIDI",metadata:{category:"Sequence",keywords:["pattern","sequencer","combiner","event","midi"],description:"Converts sequence(s) into a MIDI stream."},config:{},inputs:{seq_in:{type:ae,description:"Input sequence(s)",allowMultiConnection:!0}},outputs:{midi_out:A},autoBroadcast:!0,reshape:"none",isRealtime:()=>!0,createState:()=>({sequenceStates:new Map}),execute:(e,i,o,t)=>{let s=e.seq_in||[];s.length===1&&Array.isArray(s[0])&&s[0].length>0&&Array.isArray(s[0][0])&&(s=s[0]);const r=[],u=(Math.floor(o.clock.beat*4)%Oe+Oe)%Oe,d=new Set;s.forEach((h,p)=>d.add(p)),t.sequenceStates.forEach((h,p)=>d.add(p));for(const h of d){const p=s[h];t.sequenceStates.has(h)||t.sequenceStates.set(h,{lastStepIndex:-1,lastNoteIndex:null,lastHold:!1,activeNotes:new Map});const f=t.sequenceStates.get(h);if(!p&&f.lastNoteIndex===null){t.sequenceStates.delete(h);continue}let y={noteIndex:null,velocity:0,hold:!1};if(p&&p[u]&&(y=p[u]),u!==f.lastStepIndex||!p||y.noteIndex!==f.lastNoteIndex){const v=f.lastNoteIndex,b=f.lastHold,I=y.noteIndex!==null&&y.noteIndex!==void 0,_=I&&y.noteIndex===v,M=v!==null&&(!_||!b),q=I&&(!_||!b);M&&v!==null&&(r.push({type:"note_off",note:v,velocity:0,channel:1,deviceId:"tomidi",time:0}),f.activeNotes.delete(v),f.lastNoteIndex=null,f.lastHold=!1),q&&y.noteIndex!==null?(r.push({type:"note_on",note:y.noteIndex,velocity:y.velocity,channel:1,deviceId:"tomidi",time:0}),f.activeNotes.set(y.noteIndex,y.velocity),f.lastNoteIndex=y.noteIndex,f.lastHold=y.hold):_&&b&&(f.lastHold=y.hold),f.lastStepIndex=u}}return{midi_out:r}}});m(on);const sn=V({id:"seq.sequencer",version:"1.0.0",displayName:"Sequencer",metadata:{category:"Sequence",keywords:["sequencer","step","pattern"],description:"16-step sequencer."},config:{sequence:{kind:"array",size:16,element:{kind:"record",fields:{noteIndex:a,velocity:a,hold:{kind:"atomic",type:"boolean"}}}}},inputs:{},outputs:{seq_out:ae},ui:{},compileConfig:e=>{const i=Array(16).fill({noteIndex:null,velocity:0,hold:!1});return{sequence:e?.values?.sequence??i}},createState:()=>({currentStepIndex:0}),isRealtime:()=>!1,execute:(e,i,o,t)=>{const n=Array(16).fill({noteIndex:null,velocity:0,hold:!1});return{outputs:{seq_out:i.sequence||n},ui:{currentStepIndex:t.currentStepIndex}}}});m(sn);const rn=V({id:"seq.oneshot",version:"1.0.0",displayName:"One Shot",metadata:{category:"Sequence",keywords:["player","trigger","oneshot","envelope"],description:"Plays a sequence once upon trigger."},config:{},autoBroadcast:{seq_in:{combine:{reduce:"first"}},trigger:{combine:{reduce:"flatten"}}},reshape:"none",inputs:{seq_in:{type:ae,description:"Input sequence"},trigger:{type:A,description:"Trigger",allowMultiConnection:!0},duration:{type:a,defaultValue:4,description:"Duration (s)"}},outputs:{midi_out:A},isRealtime:()=>!0,createState:()=>({isPlaying:!1,startTime:0,lastStepIndex:-1,lastNoteIndex:null,lastHold:!1,activeNotes:new Map}),execute:(e,i,o,t)=>{const n=e.trigger||[];let s=!1;for(const v of n)if(v&&v.type==="note_on"&&v.velocity>0){s=!0;break}const r=o.audio?.context?.currentTime??0;s&&(t.isPlaying=!0,t.startTime=r);const l=e.seq_in||[],c=[];if(!t.isPlaying||!l||l.length===0)return t.lastNoteIndex!==null&&(c.push({type:"note_off",note:t.lastNoteIndex,velocity:0,channel:1,time:0,deviceId:"oneshot"}),t.lastNoteIndex=null,t.lastHold=!1),t.activeNotes.size>0&&t.activeNotes.clear(),{midi_out:c};const u=Math.max(.001,e.duration??4),h=(r-t.startTime)/u;if(h>=1)return t.isPlaying=!1,t.lastNoteIndex!==null&&(c.push({type:"note_off",note:t.lastNoteIndex,velocity:0,channel:1,time:0,deviceId:"oneshot"}),t.lastNoteIndex=null,t.lastHold=!1),{midi_out:c};const p=l.length,f=Math.floor(h*p);let y={noteIndex:null,velocity:0,hold:!1};if(l[f]&&(y=l[f]),f!==t.lastStepIndex||y.noteIndex!==t.lastNoteIndex){const v=t.lastNoteIndex,b=t.lastHold,I=y.noteIndex!==null,_=I&&y.noteIndex===v,M=v!==null&&(!_||!b),q=I&&(!_||!b);M&&v!==null&&(c.push({type:"note_off",note:v,velocity:0,channel:1,time:0,deviceId:"oneshot"}),t.activeNotes.delete(v),t.lastNoteIndex=null,t.lastHold=!1),q&&y.noteIndex!==null?(c.push({type:"note_on",note:y.noteIndex,velocity:y.velocity,channel:1,time:0,deviceId:"oneshot"}),t.activeNotes.set(y.noteIndex,y.velocity),t.lastNoteIndex=y.noteIndex,t.lastHold=y.hold):_&&b&&(t.lastHold=y.hold),t.lastStepIndex=f}return{midi_out:c}}}),an=V({id:"seq.scan",version:"1.0.0",displayName:"Scan Sequence",metadata:{category:"Sequence",keywords:["player","scan","scrub"],description:"Plays a sequence by scanning through positions."},config:{},autoBroadcast:{seq_in:{combine:{reduce:"first"}}},reshape:"none",inputs:{seq_in:{type:ae,description:"Input sequence"},pos:{type:a,defaultValue:0,description:"Position (0-1)"}},outputs:{midi_out:A},isRealtime:()=>!0,createState:()=>({lastStepIndex:-1,lastNoteIndex:null,lastHold:!1,activeNotes:new Map}),execute:(e,i,o,t)=>{const n=e.seq_in||[],s=e.pos??0,r=[];if(!n||n.length===0||s>=1||s<0)return t.lastNoteIndex!==null&&(r.push({type:"note_off",note:t.lastNoteIndex,velocity:0,channel:1,time:0,deviceId:"scan"}),t.lastNoteIndex=null,t.lastHold=!1),{midi_out:r};const l=n.length,c=Math.floor(s*l);let u={noteIndex:null,velocity:0,hold:!1};if(n[c]&&(u=n[c]),c!==t.lastStepIndex||u.noteIndex!==t.lastNoteIndex){const d=t.lastNoteIndex,h=t.lastHold,p=u.noteIndex!==null,f=p&&u.noteIndex===d,y=d!==null&&(!f||!h),v=p&&(!f||!h);y&&d!==null&&(r.push({type:"note_off",note:d,velocity:0,channel:1,time:0,deviceId:"scan"}),t.lastNoteIndex=null,t.lastHold=!1),v&&u.noteIndex!==null?(r.push({type:"note_on",note:u.noteIndex,velocity:u.velocity,channel:1,time:0,deviceId:"scan"}),t.lastNoteIndex=u.noteIndex,t.lastHold=u.hold):f&&h&&(t.lastHold=u.hold),t.lastStepIndex=c}return{midi_out:r}}});m(rn);m(an);const ln=V({id:"seq.crop",version:"1.0.0",displayName:"Crop Sequence",metadata:{category:"Sequence",keywords:["modifier","crop","slice"],description:"Mutes steps outside the specified range."},config:{mode:{kind:"atomic",type:"string",defaultValue:"start-end"}},autoBroadcast:{seq_in:{combine:{reduce:"first"}}},inputs:{seq_in:{type:ae,description:"Input sequence"},start:{type:a,defaultValue:0},end:{type:a,defaultValue:1,optional:!0},length:{type:a,defaultValue:1,optional:!0}},outputs:{seq_out:ae},ui:{inspector:{fields:[{type:"tab-bar",label:"Mode",path:"mode",options:[{label:"Start / End",value:"start-end"},{label:"Start / Length",value:"start-length"}]}]}},computeForwardPorts:(e,i)=>{const o=i.mode||"start-end",t={seq_in:ae,start:{...a,defaultValue:0}};return o==="start-length"?t.length={...a,defaultValue:1}:t.end={...a,defaultValue:1},{inputs:{kind:"record",fields:t},outputs:{kind:"record",fields:{seq_out:ae}}}},shouldRecompileOnConfigChange:()=>!0,compileConfig:e=>({mode:e.mode||"start-end"}),execute:(e,i)=>{const o=e.seq_in||[],t=i.mode||"start-end",n=o.map(c=>({...c})),s=e.start??0;let r=1;if(t==="start-length"){const c=e.length??1;r=s+c}else r=e.end??1;r<s&&(r=s);const l=n.length;for(let c=0;c<l;c++){const u=c/l;(u<s||u>=r)&&(n[c].noteIndex=null,n[c].velocity=0,n[c].hold=!1)}return{seq_out:n}}}),cn=V({id:"seq.fill",version:"1.0.0",displayName:"Fill Sequence",metadata:{category:"Sequence",keywords:["generator","fill","range"],description:"Generates a sequence where steps inside the specified range are ON."},config:{mode:{kind:"atomic",type:"string",defaultValue:"start-length"},count:{...a,defaultValue:16}},inputs:{start:{type:a,defaultValue:0},end:{type:a,defaultValue:1,optional:!0},length:{type:a,defaultValue:.5,optional:!0}},outputs:{seq_out:ae},ui:{inspector:{fields:[{type:"tab-bar",label:"Mode",path:"mode",options:[{label:"Start / End",value:"start-end"},{label:"Start / Length",value:"start-length"}],default:"start-length"},{type:"number",label:"Step Count",path:"count",min:1,max:128,step:1,default:16}]}},computeForwardPorts:(e,i)=>{const o=i.mode||"start-length",t={start:{...a,defaultValue:0}};return o==="start-length"?t.length={...a,defaultValue:.5}:t.end={...a,defaultValue:1},{inputs:{kind:"record",fields:t},outputs:{kind:"record",fields:{seq_out:ae}}}},shouldRecompileOnConfigChange:()=>!0,compileConfig:e=>({mode:e.mode||"start-length",count:e.count??16}),execute:(e,i)=>{const o=i.count??16,t=i.mode||"start-length",n=[];for(let r=0;r<o;r++)n.push({noteIndex:null,velocity:0,hold:!1});const s=e.start??0;if(t==="start-length"){const r=e.length??.5,l=Math.round(r*o),c=Math.floor(s*o);for(let u=0;u<l;u++){const d=c+u;d>=0&&d<o&&(n[d]={noteIndex:60,velocity:1,hold:!1})}}else{const r=e.end??1;let l=s,c=r;c<l&&(c=l);for(let u=0;u<o;u++){const d=u/o;d>=l&&d<c&&(n[u]={noteIndex:60,velocity:1,hold:!1})}}return{seq_out:n}}});m(ln);m(cn);const ge={noteIndex:null,velocity:0,hold:!1},ve=e=>e.noteIndex!==null&&e.noteIndex!==void 0,Se=(e,i,o,t)=>V({id:`seq.${e}`,version:"1.0.0",displayName:i,metadata:{category:"Sequence",keywords:["logic",e,"binary"],description:o},config:{},inputs:{inputs:{type:ae,description:"Sequences",allowMultiConnection:!0}},outputs:{seq_out:ae},execute:n=>{const s=n.inputs||[];if(s.length===0)return{seq_out:[]};let r=0;if(s.forEach(c=>r=Math.max(r,c.length)),r===0)return{seq_out:[]};const l=[];for(let c=0;c<r;c++){let u={...ge};const d=s[0];d.length>0?u={...d[c%d.length]}:u={...ge};for(let h=1;h<s.length;h++){const p=s[h],f=p.length>0?p[c%p.length]:ge;u=t(u,f)}l.push(u)}return{seq_out:l}}}),un=Se("xor","Sequence XOR","XORs multiple sequences.",(e,i)=>{const o=ve(e),t=ve(i);return o!==t?t?i:e:{...ge}}),dn=Se("sub","Sequence Subtract","Subtracts subsequent sequences from the first.",(e,i)=>ve(i)?{...ge}:e),pn=Se("and","Sequence AND","Output active only if both inputs active.",(e,i)=>ve(e)&&ve(i)?i:{...ge}),fn=Se("or","Sequence OR","Output active if any input active.",(e,i)=>ve(i)?i:e),mn=V({id:"seq.negate",version:"1.0.0",displayName:"Sequence Negate",metadata:{category:"Sequence",keywords:["logic","not","invert"],description:"Inverts sequence activity."},config:{},autoBroadcast:{seq_in:{combine:{reduce:"first"}}},inputs:{seq_in:{type:ae}},outputs:{seq_out:ae},execute:e=>({seq_out:(e.seq_in||[]).map(t=>{const n={...t};return n.noteIndex!==null?(n.noteIndex=null,n.velocity=0,n.hold=!1):(n.noteIndex=60,n.velocity=1,n.hold=!1),n})})});m(un);m(dn);m(pn);m(fn);m(mn);const yn=[{type:"string",label:"Path",path:"path",placeholder:"/composition/..."}],hn=V({id:"resolume.input",version:"1.0.0",displayName:"Resolume Input",metadata:{category:x.IO,keywords:["resolume","arena","parameter","read"],description:"Reads a parameter value from Resolume Arena."},inputs:{},config:{path:qe},outputs:{value:{type:a,suppressLabel:!0}},autoBroadcast:!1,isRealtime:()=>!0,ui:{inspector:{fields:yn}},getDisplayLabel:e=>{if(!e.path)return;const i=e.path.split("/");return i[i.length-1]||e.path},createState:(e,i)=>{const o={value:0,unsubscribe:()=>{},currentPath:e.path,callback:n=>{}};o.callback=n=>{o.value=n};const t=i.resolume;return e.path&&t&&(t.subscribe(e.path,o.callback,o.callback),o.unsubscribe=()=>t.unsubscribe(e.path,o.callback)),o},execute:(e,i,o,t)=>{if(i.path!==t.currentPath){t.currentPath&&t.unsubscribe(),t.currentPath=i.path;const n=o.resolume;i.path&&n&&(n.subscribe(i.path,t.callback),t.unsubscribe=()=>n.unsubscribe(i.path,t.callback))}return{value:t?.value??0}},compileConfig:e=>({path:e.path??""})});m(hn);const gn={kind:"atomic",type:"any"},vn=[{type:"string",label:"Path",path:"path",placeholder:"/composition/..."}],bn=V({id:"resolume.output",version:"1.0.0",displayName:"Resolume Output",metadata:{category:x.IO,keywords:["resolume","arena","parameter","write"],description:"Writes a value to a Resolume Arena parameter."},inputs:{value:{type:gn,suppressInputEditor:!0,suppressLabel:!0}},config:{path:qe},outputs:{},autoBroadcast:!0,ui:{inspector:{fields:vn}},getDisplayLabel:e=>{if(!e.path)return;const i=e.path.split("/");return i[i.length-1]||e.path},createState:(e,i)=>({lastValue:void 0}),execute:(e,i,o,t)=>{if(i.path&&e.value!==void 0){const n=e.value,s=t.lastValue;let r=!1;typeof n=="number"&&typeof s=="number"?Math.abs(n-s)>1e-5&&(r=!0):n!==s&&(r=!0);const l=o.resolume;r&&l&&(l.setValue(i.path,n),t.lastValue=n)}return{}},compileConfig:e=>({path:e.path??""})});m(bn);const Je=J("math.add",{category:x.Math,keywords:["sum","plus"],description:"Adds a and b."},(e,i)=>e+i);m({version:"1.0.0",...Je,displayName:"Add",aliases:["plus","sum"],extendedInputs:{a:{type:a,description:"Value A"},b:{type:a,description:"Value B"}},extendedOutputs:{result:{type:a,description:"Sum"}}});const Ke=J("math.subtract",{category:x.Math,keywords:["minus","difference"],description:"Subtracts b from a."},(e,i)=>e-i);m({version:"1.0.0",...Ke,displayName:"Subtract",aliases:["minus","difference"],extendedInputs:{a:{type:a,description:"Minuend"},b:{type:a,description:"Subtrahend"}},extendedOutputs:{result:{type:a,description:"Result"}}});const et=J("math.multiply",{category:x.Math,keywords:["times","product"],description:"Multiplies a and b."},(e,i)=>e*i);m({version:"1.0.0",...et,displayName:"Multiply",aliases:["times","product"],extendedInputs:{a:{type:a,description:"Factor A"},b:{type:a,description:"Factor B"}},extendedOutputs:{result:{type:a,description:"Product"}}});const tt=J("math.divide",{category:x.Math,keywords:["div","quotient"],description:"Divides a by b."},(e,i)=>e/i);m({version:"1.0.0",...tt,displayName:"Divide",aliases:["div","quotient"],extendedInputs:{a:{type:a,description:"Dividend"},b:{type:a,description:"Divisor"}},extendedOutputs:{result:{type:a,description:"Quotient"}}});const it=J("math.pow",{category:x.Math,keywords:["power","exponent"],description:"Raises a to the power of b."},(e,i)=>Math.pow(e,i));m({version:"1.0.0",...it,displayName:"Power",extendedInputs:{a:{type:a,description:"Base"},b:{type:a,description:"Exponent"}},extendedOutputs:{result:{type:a,description:"Result"}}});const nt=J("math.min",{category:x.Math,keywords:["minimum","smallest"],description:"Returns the smaller of a and b."},(e,i)=>Math.min(e,i));m({version:"1.0.0",...nt,displayName:"Min",extendedInputs:{a:{type:a,description:"Value A"},b:{type:a,description:"Value B"}},extendedOutputs:{result:{type:a,description:"Minimum"}}});const ot=J("math.max",{category:x.Math,keywords:["maximum","largest"],description:"Returns the larger of a and b."},(e,i)=>Math.max(e,i));m({version:"1.0.0",...ot,displayName:"Max",extendedInputs:{a:{type:a,description:"Value A"},b:{type:a,description:"Value B"}},extendedOutputs:{result:{type:a,description:"Maximum"}}});const st=ie({id:"math.fmod",metadata:{category:x.Math,keywords:["modulo","remainder"],description:"Floating point modulo operation."},inputs:{dividend:a,divisor:a},outputs:{div:a,mod:a},autoBroadcast:!0,execute:(e,i,o)=>{const{dividend:t,divisor:n}=e,s=Math.floor(t/n),r=t%n;return{div:s,mod:r}}});m({version:"1.0.0",...st,displayName:"FMod",extendedInputs:{dividend:{type:a,description:"Dividend"},divisor:{type:a,description:"Divisor",defaultValue:1,range:[0,10]}},extendedOutputs:{div:{type:a,description:"The integer division result."},mod:{type:a,description:"The remainder."}}});const rt=J("logic.and",{category:x.Logic,keywords:["boolean","&&"],description:"Logical AND (1 if both non-zero, else 0)."},(e,i)=>e!==0&&i!==0?1:0);m({version:"1.0.0",...rt,displayName:"AND",extendedInputs:{a:{type:a,description:"Value A"},b:{type:a,description:"Value B"}},extendedOutputs:{result:{type:a,description:"Result"}}});const at=J("logic.or",{category:x.Logic,keywords:["boolean","||"],description:"Logical OR (1 if either non-zero, else 0)."},(e,i)=>e!==0||i!==0?1:0);m({version:"1.0.0",...at,displayName:"OR",extendedInputs:{a:{type:a,description:"Value A"},b:{type:a,description:"Value B"}},extendedOutputs:{result:{type:a,description:"Result"}}});const lt=J("logic.xor",{category:x.Logic,keywords:["boolean","^"],description:"Logical XOR (1 if different truthiness, else 0)."},(e,i)=>e!==0!=(i!==0)?1:0);m({version:"1.0.0",...lt,displayName:"XOR",extendedInputs:{a:{type:a,description:"Value A"},b:{type:a,description:"Value B"}},extendedOutputs:{result:{type:a,description:"Result"}}});const ct=J("logic.equals",{category:x.Logic,keywords:["==","equality"],description:"Returns 1 if a equals b, else 0."},(e,i)=>e===i?1:0);m({version:"1.0.0",...ct,displayName:"Equals",extendedInputs:{a:{type:a,description:"Value A"},b:{type:a,description:"Value B"}},extendedOutputs:{result:{type:a,description:"Result"}}});const ut=J("logic.greater_than",{category:x.Logic,keywords:[">","gt"],description:"Returns 1 if a > b, else 0."},(e,i)=>e>i?1:0);m({version:"1.0.0",...ut,displayName:"Greater Than",extendedInputs:{a:{type:a,description:"Value A"},b:{type:a,description:"Value B"}},extendedOutputs:{result:{type:a,description:"Result"}}});const dt=J("logic.less_than",{category:x.Logic,keywords:["<","lt"],description:"Returns 1 if a < b, else 0."},(e,i)=>e<i?1:0);m({version:"1.0.0",...dt,displayName:"Less Than",extendedInputs:{a:{type:a,description:"Value A"},b:{type:a,description:"Value B"}},extendedOutputs:{result:{type:a,description:"Result"}}});var xn=Object.freeze({__proto__:null,primitive_add:Je,primitive_and:rt,primitive_divide:tt,primitive_equals:ct,primitive_fmod:st,primitive_greater_than:ut,primitive_less_than:dt,primitive_max:ot,primitive_min:nt,primitive_multiply:et,primitive_or:at,primitive_pow:it,primitive_subtract:Ke,primitive_xor:lt});const pt=J("math.abs",{category:x.Math,keywords:["absolute","magnitude"],description:"Returns the absolute value of a."},e=>Math.abs(e),"unary");m({version:"1.0.0",...pt,displayName:"Abs",extendedInputs:{a:{type:a,description:"Value"}},extendedOutputs:{result:{type:a,description:"Absolute Value"}}});const ft=J("math.negate",{category:x.Math,keywords:["negative","invert"],description:"Negates a."},e=>-e,"unary");m({version:"1.0.0",...ft,displayName:"Negate",extendedInputs:{a:{type:a,description:"Value"}},extendedOutputs:{result:{type:a,description:"Negated Value"}}});const mt=J("math.ceil",{category:x.Math,keywords:["ceiling","round up"],description:"Rounds a up to the nearest integer."},e=>Math.ceil(e),"unary");m({version:"1.0.0",...mt,displayName:"Ceil",extendedInputs:{a:{type:a,description:"Value"}},extendedOutputs:{result:{type:a,description:"Ceiling"}}});const yt=J("math.floor",{category:x.Math,keywords:["floor","round down"],description:"Rounds a down to the nearest integer."},e=>Math.floor(e),"unary");m({version:"1.0.0",...yt,displayName:"Floor",extendedInputs:{a:{type:a,description:"Value"}},extendedOutputs:{result:{type:a,description:"Floor"}}});const ht=J("math.round",{category:x.Math,keywords:["round","nearest"],description:"Rounds a to the nearest integer."},e=>Math.round(e),"unary");m({version:"1.0.0",...ht,displayName:"Round",extendedInputs:{a:{type:a,description:"Value"}},extendedOutputs:{result:{type:a,description:"Rounded Value"}}});const gt=J("math.sin",{category:x.Math,keywords:["sine"],description:"Returns the sine of a (radians)."},e=>Math.sin(e),"unary");m({version:"1.0.0",...gt,displayName:"Sin",extendedInputs:{a:{type:a,description:"Value (Radians)"}},extendedOutputs:{result:{type:a,description:"Sine"}}});const vt=J("math.cos",{category:x.Math,keywords:["cosine"],description:"Returns the cosine of a (radians)."},e=>Math.cos(e),"unary");m({version:"1.0.0",...vt,displayName:"Cos",extendedInputs:{a:{type:a,description:"Value (Radians)"}},extendedOutputs:{result:{type:a,description:"Cosine"}}});const bt=J("math.tan",{category:x.Math,keywords:["tangent"],description:"Returns the tangent of a (radians)."},e=>Math.tan(e),"unary");m({version:"1.0.0",...bt,displayName:"Tan",extendedInputs:{a:{type:a,description:"Value (Radians)"}},extendedOutputs:{result:{type:a,description:"Tangent"}}});const xt=J("math.sqrt",{category:x.Math,keywords:["square root"],description:"Returns the square root of a."},e=>Math.sqrt(e),"unary");m({version:"1.0.0",...xt,displayName:"Sqrt",extendedInputs:{a:{type:a,description:"Value"}},extendedOutputs:{result:{type:a,description:"Square Root"}}});const It=J("logic.not",{category:x.Logic,keywords:["!","invert"],description:"Logical NOT (1 if zero, 0 if non-zero)."},e=>e===0?1:0,"unary");m({version:"1.0.0",...It,displayName:"NOT",extendedInputs:{a:{type:a,description:"Value"}},extendedOutputs:{result:{type:a,description:"Result"}}});var In=Object.freeze({__proto__:null,primitive_abs:pt,primitive_ceil:mt,primitive_cos:vt,primitive_floor:yt,primitive_negate:ft,primitive_not:It,primitive_round:ht,primitive_sin:gt,primitive_sqrt:xt,primitive_tan:bt});const ue=(e,i,o,t=x.Math)=>{const n=ie({id:e,metadata:{category:t,description:`Apply ${e.split(".").pop()} to all inputs.`},inputs:{values:{kind:"array",element:Y,size:"dynamic",allowMultiConnection:!0}},outputs:{result:a},computeForwardPorts:(s,r,l)=>{const c=s.fields.values;let u=a;if(c&&c.kind==="array"){const d=c.element;(d.kind==="array"||d.kind==="record")&&(u=d)}return{inputs:{kind:"record",fields:{values:c}},outputs:{kind:"record",fields:{result:u}}}},execute:s=>{const r=s.values;if(!r||r.length===0)return{result:0};const l=r[0],c=Array.isArray(l);let u=!1,d=[];if(!c&&typeof l=="object"&&l!==null&&typeof l.x=="number"&&typeof l.y=="number"&&(u=!0,d=["x","y"],typeof l.z=="number"&&d.push("z"),typeof l.w=="number"&&d.push("w")),c||u||typeof l=="number"){const h=c?l.length:u?d.length:1,p=new Array(h);for(let f=0;f<h;f++){let y=c?l[f]:u?l[d[f]]:l;for(let v=1;v<r.length;v++){const b=r[v];let I;if(Array.isArray(b))I=b[f]??0;else if(typeof b=="object"&&b!==null&&"x"in b){const _=d[f];I=b[_],I===void 0&&(I=0)}else I=b;y=o(y,I)}p[f]=y}if(u){const f={};return d.forEach((y,v)=>f[y]=p[v]),{result:f}}else if(!c)return{result:p[0]};return{result:p}}else return{result:0}}});return m({version:"1.0.0",...n,displayName:i,extendedInputs:{values:{type:{kind:"array",element:a,size:"dynamic"},description:"Values to process.",suppressInputEditor:!0,suppressLabel:!0,allowMultiConnection:!0}},extendedOutputs:{result:{type:a,description:"Result"}}}),n},kn=ue("math.all.add","Sum All",(e,i)=>e+i),Nn=ue("math.all.subtract","Subtract All",(e,i)=>e-i),_n=ue("math.all.multiply","Multiply All",(e,i)=>e*i),Mn=ue("math.all.divide","Divide All",(e,i)=>e/i),wn=ue("math.all.pow","Power All",(e,i)=>Math.pow(e,i)),Cn=ue("math.all.min","Min All",(e,i)=>Math.min(e,i)),Sn=ue("math.all.max","Max All",(e,i)=>Math.max(e,i)),Tn=ue("logic.all.and","AND All",(e,i)=>e&&i?1:0,x.Logic),Vn=ue("logic.all.or","OR All",(e,i)=>e||i?1:0,x.Logic),An=ue("logic.all.xor","XOR All",(e,i)=>!!e!=!!i?1:0,x.Logic),On=ue("logic.all.equals","Equals All",(e,i)=>e===i?1:0,x.Logic),Rn=ue("logic.all.greater_than","Greater Than All",(e,i)=>e>i?1:0,x.Logic),qn=ue("logic.all.less_than","Less Than All",(e,i)=>e<i?1:0,x.Logic);var En=Object.freeze({__proto__:null,primitive_all_add:kn,primitive_all_and:Tn,primitive_all_divide:Mn,primitive_all_equals:On,primitive_all_greater_than:Rn,primitive_all_less_than:qn,primitive_all_max:Sn,primitive_all_min:Cn,primitive_all_multiply:_n,primitive_all_or:Vn,primitive_all_pow:wn,primitive_all_subtract:Nn,primitive_all_xor:An});const kt=ie({id:"math.pi",metadata:{category:x.Math,keywords:["pi","constant"],description:"Returns the value of Pi."},inputs:{},outputs:{result:a},execute:()=>({result:Math.PI})});m({version:"1.0.0",...kt,displayName:"Pi",extendedOutputs:{result:{type:a,description:"Pi"}}});const Nt=ie({id:"math.e",metadata:{category:x.Math,keywords:["e","euler","constant"],description:"Returns the value of Euler's number."},inputs:{},outputs:{result:a},execute:()=>({result:Math.E})});m({version:"1.0.0",...Nt,displayName:"E",extendedOutputs:{result:{type:a,description:"Euler's Number"}}});var Dn=Object.freeze({__proto__:null,primitive_e:Nt,primitive_pi:kt});const _t=ie({id:"math.clamp",metadata:{category:x.Math,keywords:["limit","range"],description:"Clamps a value between a minimum and maximum."},inputs:{value:a,min:{...a,defaultValue:0},max:{...a,defaultValue:1}},outputs:{result:a},autoBroadcast:{value:{combine:"collect"},min:{combine:"collect"},max:{combine:"collect"}},reshape:"vector",execute:e=>{const{value:i,min:o,max:t}=e;return{result:Math.max(o,Math.min(i,t))}}});m({version:"1.0.0",..._t,displayName:"Clamp",extendedInputs:{value:{type:a,description:"Value to clamp."},min:{type:a,description:"Minimum value.",defaultValue:0,range:[0,1]},max:{type:a,description:"Maximum value.",defaultValue:1,range:[0,1]}},extendedOutputs:{value:{type:a,description:"The clamped value."}}});const Mt=ie({id:"math.lerp",metadata:{category:x.Math,keywords:["lerp","mix","interpolate"],description:"Linear interpolation between a and b."},inputs:{a,b:a,t:a},config:{clamp:{kind:"atomic",type:"boolean",optional:!0}},outputs:{result:a},autoBroadcast:!0,execute:(e,i)=>{const{a:o,b:t,t:n}=e,s=i.clamp!==!1,r=o+(t-o)*n;return{result:s?Math.max(Math.min(r,Math.max(o,t)),Math.min(o,t)):r}}});m({version:"1.0.0",...Mt,displayName:"Lerp",extendedInputs:{a:{type:a,description:"Start Value"},b:{type:a,description:"End Value"},t:{type:a,description:"Interpolant (0-1)"}},extendedOutputs:{result:{type:a,description:"Interpolated Value"}},compileConfig:e=>({fields:{clamp:e.clamp??!0},untagged:[]})});const wt=ie({id:"math.map",metadata:{category:x.Math,keywords:["map","remap","range"],description:"Maps a value from one range to another."},inputs:{value:a,inMin:a,inMax:a,outMin:a,outMax:a},outputs:{result:a},autoBroadcast:!0,execute:e=>{const{value:i,inMin:o,inMax:t,outMin:n,outMax:s}=e;return{result:n+(i-o)*(s-n)/(t-o)}}});m({version:"1.0.0",...wt,displayName:"Map",extendedInputs:{value:{type:a,description:"Input Value"},inMin:{type:a,description:"Input Min",defaultValue:0},inMax:{type:a,description:"Input Max",defaultValue:1},outMin:{type:a,description:"Output Min",defaultValue:0},outMax:{type:a,description:"Output Max",defaultValue:1}},extendedOutputs:{result:{type:a,description:"Mapped Value"}}});var Pn=Object.freeze({__proto__:null,primitive_clamp:_t,primitive_lerp:Mt,primitive_map:wt});function Ln(e){if(!e)return;const i=e.type;if(!(!i||i==="any")){if(i==="float")return{kind:"atomic",type:"number"};if(i==="string")return{kind:"atomic",type:"string"};if(i.startsWith("float")){const o=parseInt(i.slice(5));if(!isNaN(o))return{kind:"array",size:o,element:{kind:"atomic",type:"number"}}}}}const Ct={kind:"record",fields:{name:{kind:"atomic",type:"string"},type:Y}},St={id:"io.input",kind:"primitive",metadata:{category:x.IO,keywords:["source","in"],description:"Graph input node."},configType:Ct,ui:{inspector:{fields:[{type:"structor-type",label:"Type",path:"type",default:"float"},{type:"string",label:"Name",path:"name"}]}},computeForwardPorts:(e,i,o)=>{let t=e.fields.value;if(!t){const n=Ln(i);n&&(t=n)}return t||(t={kind:"atomic",type:"number"}),{inputs:{kind:"record",fields:{value:{kind:"atomic",type:"number"}}},outputs:{kind:"record",fields:{value:t}}}},execute:(e,i,o)=>{const n=i?.fields?.name??"value";return{fields:{value:e.fields[n]!==void 0?e.fields[n]:e.fields.value}}}};m({version:"1.0.0",...St,displayName:"Input",aliases:["in","source"],extendedOutputs:{value:{type:Y,description:"The input value.",suppressInputEditor:!0,suppressLabel:!0}},compileConfig:e=>{const i=he(e,Ct);return e.values&&(i.values=e.values),i}});var Fn=Object.freeze({__proto__:null,primitive_input:St});const Tt={id:"io.output",kind:"primitive",metadata:{category:x.IO,keywords:["sink","out"],description:"Graph output node."},computeForwardPorts:(e,i,o)=>{const t=e.fields.value||{kind:"atomic",type:"any"};return{inputs:{kind:"record",fields:{value:t}},outputs:{kind:"record",fields:{value:t}}}},execute:(e,i,o)=>({fields:{value:e.fields.value}})};m({version:"1.0.0",...Tt,displayName:"Output",aliases:["out","sink"],extendedInputs:{value:{type:Y,description:"The output value.",suppressInputEditor:!0,suppressLabel:!0}},extendedOutputs:{value:{type:Y,description:"The graph output value.",suppressInputEditor:!0,suppressLabel:!0}}});var jn=Object.freeze({__proto__:null,primitive_output:Tt});function zn(e){if(!e)return;const i=e.type;if(!(!i||i==="any")){if(i==="float")return{kind:"atomic",type:"number"};if(i==="string")return{kind:"atomic",type:"string"};if(i.startsWith("float")){const o=parseInt(i.slice(5));if(!isNaN(o))return{kind:"array",size:o,element:{kind:"atomic",type:"number"}}}}}function ye(e,i,o,t){if(!e||!e.includes("#"))return e;let n="";return o===1?n=t==="input"?"in":"out":o<=4?n=["x","y","z","w"][i]:n=i.toString(),e.replace(/#/g,n)}const Pe=(e,i,o)=>{const n=o.loadedSubgraphs;if(!n)return{inputs:{kind:"record",fields:{}},outputs:{kind:"record",fields:{}}};const s=i.subgraphId,r=n.get(s);if(r){const l=Object.values(r.inner.nodes),c={},u=l.filter(p=>p.config.typeId==="io.input"||p.config.typeId==="input").sort((p,f)=>p.y-f.y);u.forEach((p,f)=>{let y=p.config.name||"value";y=ye(y,f,u.length,"input");const v=zn(p.config);c[y]=v||{kind:"atomic",type:"any"}});const d={},h=l.filter(p=>p.config.typeId==="io.output"||p.config.typeId==="output").sort((p,f)=>p.y-f.y);return h.forEach((p,f)=>{let y=p.config.name||"value";y=ye(y,f,h.length,"output"),d[y]={kind:"atomic",type:"any"}}),{inputs:{kind:"record",fields:c},outputs:{kind:"record",fields:d}}}return{inputs:{kind:"record",fields:{}},outputs:{kind:"record",fields:{}}}},Vt=ie({id:"core.subgraph",subgraphExpansionTag:"inline",metadata:{category:x.Core,keywords:["nested","graph"],description:"Executes a nested subgraph."},config:{subgraphId:{kind:"atomic",type:"string"}},inputs:{},outputs:{},ui:{inspector:{fields:[{type:"string",label:"Subgraph ID",path:"subgraphId"}]}},getDisplayLabel:e=>{if(e.subgraphId){const i=e.subgraphId.split(".");return i[i.length-1]}},computeForwardPorts:Pe,execute:(e,i,o)=>({fields:{}})});m({version:"1.0.0",...Vt,displayName:"Subgraph"});var Bn=Object.freeze({__proto__:null,computeSubgraphPorts:Pe,primitive_subgraph:Vt,resolvePortName:ye});const At=ie({id:"core.thensubgraph",subgraphExpansionTag:"onTrigger",metadata:{category:x.Core,keywords:["nested","graph","conditional","midi","trigger"],description:"Executes a nested subgraph when a MIDI Note On event is received."},config:{subgraphId:{kind:"atomic",type:"string"}},inputs:{midi_in:A},outputs:{},ui:{inspector:{fields:[{type:"string",label:"Subgraph ID",path:"subgraphId"}]}},getDisplayLabel:e=>{if(e.subgraphId){const i=e.subgraphId.split(".");return`OnNote: ${i[i.length-1]}`}return"OnNote"},computeForwardPorts:((e,i,o)=>{const t=Pe(e,i,o);return{inputs:{kind:"record",fields:{...t.inputs.fields,midi_in:A}},outputs:t.outputs}}),execute:(e,i,o)=>{const t=e.midi_in||[],n=Array.isArray(t)?t:[];let s=!1;for(const r of n)if(r.type==="note_on"&&(r.velocity??0)>0){s=!0;break}return s&&o.executeSubgraph&&o.executeSubgraph("onTrigger"),{fields:{}}}});m(At);var $n=Object.freeze({__proto__:null,primitive_thensubgraph:At});const Ot=ie({id:"core.pack",metadata:{category:x.Core,keywords:["pack","record","struct","vector"],description:"Packs inputs into a record or vector."},config:{targetType:{kind:"atomic",type:"string",defaultValue:"infer"}},inputs:{},outputs:{result:Y},ui:{inspector:{fields:[{type:"tab-bar",label:"Target Type",path:"targetType",options:[{label:"Infer",value:"infer"},{label:"float2",value:"float2"},{label:"float3",value:"float3"},{label:"float4",value:"float4"}]}]}},computeBackwardPorts:(e,i,o)=>{const t=i?.targetType||"infer";let n=null;if(t==="infer"){const r=e.fields.result;r&&r.kind==="record"&&(r.fields.x&&r.fields.y&&r.fields.z&&r.fields.w?n="float4":r.fields.x&&r.fields.y&&r.fields.z?n="float3":r.fields.x&&r.fields.y&&(n="float2"))}else n=t;const s={kind:"record",fields:{}};return n==="float4"?s.fields={x:a,y:a,z:a,w:a}:n==="float3"?s.fields={x:a,y:a,z:a}:n==="float2"&&(s.fields={x:a,y:a}),{inputRequirements:s,backwardMetadata:{inferredType:n}}},computeForwardPorts:(e,i,o,t)=>{const n=i,s=n?.targetType||n?.fields?.targetType||"infer";let r=s!=="infer"?s:t?.inferredType||"float2";const l={},c={};return["float2","float3","float4"].includes(r)||(r="float2"),r==="float4"?(l.x=a,l.y=a,l.z=a,l.w=a,c.result={kind:"array",size:4,element:a,hint:"float4"}):r==="float3"?(l.x=a,l.y=a,l.z=a,c.result={kind:"array",size:3,element:a,hint:"float3"}):(l.x=a,l.y=a,c.result={kind:"array",size:2,element:a,hint:"float2"}),{inputs:{kind:"record",fields:l},outputs:{kind:"record",fields:c}}},shouldRecompileOnConfigChange:(e,i)=>e?.targetType!==i?.targetType,execute:(e,i)=>{const o=e?.fields||{};let t=i?.targetType||"infer";return t==="infer"&&(o.w!==void 0?t="float4":o.z!==void 0?t="float3":o.y!==void 0&&o.x!==void 0?t="float2":t="record"),t==="float4"?{result:[o.x??0,o.y??0,o.z??0,o.w??0]}:t==="float3"?{result:[o.x??0,o.y??0,o.z??0]}:t==="float2"?{result:[o.x??0,o.y??0]}:{result:{fields:o}}}});m({version:"1.0.0",...Ot,displayName:"Pack",extendedOutputs:{result:{type:Y,description:"Record"}}});var Gn=Object.freeze({__proto__:null,primitive_pack:Ot});const Rt=ie({id:"core.unpack",metadata:{category:x.Core,keywords:["unpack","destructure","split"],description:"Unpacks a record or fixed-length vector into outputs."},config:{},inputs:{record:Y},computeForwardPorts:(e,i,o)=>{const t=e.fields.record;let n={};if(t){if(t.kind==="record")n=t.fields;else if(t.kind==="array"&&typeof t.size=="number"&&t.size<=16){const s=t.size;if(s===2)n.x=t.element,n.y=t.element;else if(s===3)n.x=t.element,n.y=t.element,n.z=t.element;else if(s===4)n.x=t.element,n.y=t.element,n.z=t.element,n.w=t.element;else for(let r=0;r<s;r++)n[r.toString()]=t.element}}return{inputs:{kind:"record",fields:{record:t||Y}},outputs:{kind:"record",fields:n}}},outputs:{},dynamicOutputType:Y,execute:e=>{let i=e.record;if(!i)return{};if(Array.isArray(i)&&i.length===1&&typeof i[0]=="object"&&i[0]!==null){const o=i[0];("x"in o||"fields"in o||Object.keys(o).length>0)&&(i=o)}if(Array.isArray(i)){const o=i.length,t={};if(o===2)t.x=i[0],t.y=i[1];else if(o===3)t.x=i[0],t.y=i[1],t.z=i[2];else if(o===4)t.x=i[0],t.y=i[1],t.z=i[2],t.w=i[3];else for(let n=0;n<o;n++)n<16&&(t[n.toString()]=i[n]);return t}return typeof i=="object"&&i!==null?"fields"in i?i.fields:i:{}}});m({version:"1.0.0",...Rt,displayName:"Unpack",extendedInputs:{record:{type:Y,description:"Record to unpack"}}});var Hn=Object.freeze({__proto__:null,primitive_unpack:Rt});function qt(e){return e&&e.kind==="array"&&e.element?.kind==="record"?"midi":"primitive"}function Et(e,i){if(i==="primitive")if(Array.isArray(e)){for(const o of e)if(o)return!0;return!1}else return!!e;else{const o=e||[];if(Array.isArray(o)){for(const t of o)if(t&&t.type==="note_on"&&(t.velocity??0)>0)return!0}return!1}}const Dt=ie({id:"core.ifthen",subgraphExpansionTag:"onTrigger",metadata:{category:x.Core,keywords:["group","conditional","spatial","if","then"],description:"Spatially groups nodes and executes them when a MIDI Note On event is received."},config:{width:{kind:"atomic",type:"number",defaultValue:3},height:{kind:"atomic",type:"number",defaultValue:3},regionX:{kind:"atomic",type:"number",defaultValue:0,optional:!0},regionY:{kind:"atomic",type:"number",defaultValue:0,optional:!0},visibility:{kind:"atomic",type:"string",defaultValue:"auto",optional:!0},mode:{kind:"atomic",type:"string",defaultValue:"midi",optional:!0}},inputs:{midi_in:A},outputs:{},ui:{inspector:{fields:[{type:"number",label:"Width",path:"width",min:1,step:1},{type:"number",label:"Height",path:"height",min:1,step:1},{type:"number",label:"Region X (Offset)",path:"regionX",step:1},{type:"number",label:"Region Y (Offset)",path:"regionY",step:1},{type:"tab-bar",label:"Visibility",path:"visibility",options:[{label:"Auto",value:"auto"},{label:"Show",value:"show"},{label:"Hide",value:"hide"}],default:"auto"}]}},getDisplayLabel:()=>"IfThen",getRegion:e=>({x:e.regionX??0,y:e.regionY??0,width:e.width??1,height:e.height??1,visibility:e.visibility||$e.Show}),getChildren:(e,i)=>{const o=[],t=e.config,n=t.regionX??0,s=t.regionY??0,r=t.width??1,l=t.height??1,c=e.x+n,u=e.y+s,d=c+r,h=u+l;for(const p of Object.values(i))p.id!==e.id&&p.x>=c&&p.x<d&&p.y>=u&&p.y<h&&o.push(p.id);return o},execute:(e,i,o)=>{const t=i.mode||"midi",n=e.midi_in;return Et(n,t)&&o.executeSubgraph&&o.executeSubgraph("onTrigger"),{fields:{}}},computeForwardPorts:(e,i,o)=>{const t=e.fields.midi_in;let n="midi",s=A;return t&&(n=qt(t),n==="primitive"&&(s=t)),{inputs:{kind:"record",fields:{midi_in:s}},outputs:{kind:"record",fields:{}},forwardMetadata:{mode:n}}},compileConfig:(e,i)=>{const o=i?.metadata;return{fields:{...e,mode:o?.mode||"midi"}}}});m(Dt);var Un=Object.freeze({__proto__:null,primitive_ifthen:Dt});function Pt(e){return typeof e=="number"?a:typeof e=="string"?{kind:"atomic",type:"string"}:typeof e=="boolean"?{kind:"atomic",type:"boolean"}:Array.isArray(e)?{kind:"array",element:e.length>0?Pt(e[0]):Y,size:e.length}:Y}const Lt={id:"data.literal",kind:"primitive",metadata:{category:x.Data,keywords:["value","constant"],description:"Outputs a constant value."},configType:{kind:"atomic",type:"any"},computeForwardPorts:(e,i,o)=>({inputs:{kind:"record",fields:{}},outputs:{kind:"record",fields:{value:Pt(i)}}}),execute:(e,i,o)=>({fields:{value:i&&typeof i=="object"&&"value"in i?i.value:i}})};m({version:"1.0.0",...Lt,displayName:"Literal",extendedOutputs:{value:{type:Y,description:"The literal value."}},compileConfig:e=>e?.literal?.value??0});var Yn=Object.freeze({__proto__:null,primitive_literal:Lt});const Ft=ie({id:"util.hub",metadata:{category:x.Utility,keywords:["hub","reroute"],description:"Passes input to output."},inputs:{value:Y},outputs:{value:Y},autoBroadcast:!0,execute:e=>({value:e.value})});m({version:"1.0.0",...Ft,displayName:"Hub",extendedInputs:{value:{type:Y,description:"Input",suppressInputEditor:!0,suppressLabel:!0}},extendedOutputs:{value:{type:Y,description:"Output",suppressLabel:!0}}});const jt=ie({id:"data.float",metadata:{category:x.Data,keywords:["float","number","slider"],description:"Float value with slider."},inputs:{value:a},outputs:{value:a},autoBroadcast:!0,execute:e=>({value:e.value})});m({version:"1.0.0",...jt,displayName:"Float",extendedInputs:{value:{type:a,description:"Value",defaultValue:0}},extendedOutputs:{value:{type:a,description:"Value"}},compileConfig:e=>({values:{value:e.value??0},fields:{},untagged:[]})});var Wn=Object.freeze({__proto__:null,primitive_float:jt,primitive_hub:Ft});const zt={id:"functional.apply",kind:"primitive",metadata:{category:x.Functional,keywords:["call","invoke"],description:"Applies a functor to an input value."},computeForwardPorts:(e,i,o)=>{const t=e.fields.functor;return{inputs:e,outputs:{kind:"record",fields:{result:t?t.output:{kind:"atomic",type:"any"}}}}},execute:(e,i,o)=>{const t=e.fields.functor,n=e.fields.input;return{fields:{result:t(n)}}}};m({version:"1.0.0",...zt,displayName:"Apply Functor",extendedInputs:{functor:{type:{kind:"functor",input:Y,output:Y},description:"The functor to apply."},value:{type:Y,description:"The value to apply the functor to."}},extendedOutputs:{result:{type:Y,description:"The result of the functor application."}}});var Zn=Object.freeze({__proto__:null,primitive_apply:zt});const Bt=ie({id:"logic.select",metadata:{category:x.Logic,keywords:["switch","case","mux","conditional","select"],description:"Selects an output value from multiple inputs based on a control value."},inputs:{},config:{count:{kind:"atomic",type:"number",defaultValue:2},mode:{kind:"atomic",type:"string",defaultValue:"value"},base:{kind:"atomic",type:"number",defaultValue:0,optional:!0},step:{kind:"atomic",type:"number",defaultValue:1,optional:!0}},outputs:{result:Q},autoBroadcast:!1,computeForwardPorts:(e,i,o)=>{const t=i.fields,n=t.count||2,s=t.mode||"value",r={value:a},l=[];for(let u=0;u<n;u++)if(s==="range"){const d=`val_${u}`;r[d]={...a,description:`Case ${u+1} Value`},e.fields&&e.fields[d]&&l.push(e.fields[d])}else s==="value"?(r[`match_${u}`]={...a,description:`Case ${u+1} Match`},r[`val_${u}`]={...a,description:`Case ${u+1} Value`},e.fields&&e.fields[`val_${u}`]&&l.push(e.fields[`val_${u}`])):s==="zone"&&(r[`threshold_${u}`]={...a,description:`Case ${u+1} Threshold`},r[`val_${u}`]={...a,description:`Case ${u+1} Value`},e.fields&&e.fields[`val_${u}`]&&l.push(e.fields[`val_${u}`]));const c=Ee(l);return{inputs:{kind:"record",fields:r},outputs:{kind:"record",fields:{result:c}}}},compileConfig:e=>({fields:{count:e.count||2,mode:e.mode||"value",base:e.base||0,step:e.step||1}}),shouldRecompileOnConfigChange:(e,i)=>{const o=e,t=i;return o.count!==t?.count||o.mode!==t?.mode},execute:(e,i,o)=>{const t=i.count??2,n=i.mode??"value",s=i.base??0,r=i.step??1,l={value:{type:a}};for(let p=0;p<t;p++){const f=`val_${p}`;l[f]={type:Q},n==="value"?l[`match_${p}`]={type:a}:n==="zone"&&(l[`threshold_${p}`]={type:a})}const c=Ut(o,l,e),u=c.value??0;let d=-1;if(n==="range")if(r===0)d=0;else{const p=Math.round((u-s)/r);d=Math.max(0,Math.min(t-1,p))}else if(n==="value")for(let f=0;f<t;f++){const y=c[`match_${f}`]??f+1;if(Math.abs(u-y)<1e-4){d=f;break}}else if(n==="zone")for(let p=0;p<t;p++){const f=c[`threshold_${p}`]??1/0;if(u<=f){d=p;break}}let h=0;return d!==-1?h=c[`val_${d}`]??0:h=0,{result:h}}});m({version:"1.0.0",...Bt,displayName:"Select",extendedInputs:{value:{type:a,description:"Control Value"}},extendedOutputs:{result:{type:Q,description:"Selected Value"}},ui:{inspector:{fields:[{type:"number",label:"Count",path:"count",min:2,max:32,step:1,default:2},{type:"tab-bar",label:"Mode",path:"mode",default:"value",options:[{label:"Value (Match)",value:"value"},{label:"Range (Index)",value:"range"},{label:"Zone (Threshold)",value:"zone"}]},{type:"number",label:"Base Index",path:"base",step:1,default:0,visible:e=>e.mode==="range"},{type:"number",label:"Step Size",path:"step",step:1,default:1,visible:e=>e.mode==="range"}]}}});var Xn=Object.freeze({__proto__:null,logic_select:Bt});const $t=ie({id:"logic.latch",metadata:{category:x.Logic,keywords:["latch","sample","hold","trigger","store"],description:"Stores and outputs a value when the trigger condition is met."},config:{initMode:{kind:"atomic",type:"string",defaultValue:"auto"},mode:{kind:"atomic",type:"string",defaultValue:"midi",optional:!0}},inputs:{condition:A,value:Q,init:Q},outputs:{result:Q},autoBroadcast:!1,createState:()=>({currentValue:void 0,initialized:!1}),computeForwardPorts:(e,i,o)=>{const n=i.fields.initMode||"auto",s=(e.fields||e).condition,r=qt(s),l=(e.fields||e).value||Q;let c=(e.fields||e).init||Q;n==="auto"&&(c=l);const u=Ee([l,c]),d={condition:s||A,value:l};return n==="manual"&&(d.init=c),{inputs:{kind:"record",fields:d},outputs:{kind:"record",fields:{result:u}},forwardMetadata:{mode:r}}},compileConfig:(e,i)=>({fields:{initMode:e.initMode||"auto",mode:i?.mode||"midi"}}),shouldRecompileOnConfigChange:(e,i)=>{const o=e,t=i;return o.initMode!==t?.initMode},execute:(e,i,o,t)=>{const n=e.condition,s=e.value,r=e.init,l=i.mode||"midi",c=i.initMode||"auto";Et(n,l)&&(t.currentValue=s,t.initialized=!0);let u=t.currentValue;return t.initialized||(c==="auto"&&(u=s),t.initialized||(t.currentValue=c==="auto"?s:r,t.initialized=!0,u=t.currentValue)),{result:u}}});m({version:"1.0.0",...$t,inputs:{},displayName:"Latch",extendedInputs:{condition:{type:A,description:"Trigger"},value:{type:Q,description:"Value to Latch"},init:{type:Q,description:"Initial Value"}},extendedOutputs:{result:{type:Q,description:"Latched Value"}},ui:{inspector:{fields:[{type:"tab-bar",label:"Init Mode",path:"initMode",default:"auto",options:[{label:"Auto (Use Value)",value:"auto"},{label:"Manual",value:"manual"}]}]}}});var Qn=Object.freeze({__proto__:null,logic_latch:$t});const Gt=ie({id:"logic.delay",metadata:{category:x.Logic,keywords:["delay","z-1","feedback","memory","prev"],description:"Outputs the value from the previous frame (z)."},config:{initMode:{kind:"atomic",type:"string",defaultValue:"auto"}},inputs:{value:Q,init:Q},outputs:{result:Q},autoBroadcast:!1,isRealtime:()=>!0,createState:()=>({storedValue:void 0,initialized:!1}),computeForwardPorts:(e,i,o)=>{const n=i.fields.initMode||"auto",s=(e.fields||e).value||Q;let r=(e.fields||e).init||Q;n==="auto"&&(r=s);const l=Ee([s,r]),c={value:s};return n==="manual"&&(c.init=r),{inputs:{kind:"record",fields:c},outputs:{kind:"record",fields:{result:l}}}},compileConfig:(e,i)=>({fields:{initMode:e.initMode||"auto"}}),shouldRecompileOnConfigChange:(e,i)=>{const o=e,t=i;return o.initMode!==t?.initMode},cycleBreakingPorts:["value"],execute:(e,i,o,t)=>{const n=e.init,s=i.initMode||"auto";let r;return t.initialized?r=t.storedValue:(s==="auto"?r=e.value:r=n,t.initialized=!0),e.value!==void 0&&(t.storedValue=e.value),{result:r}},consolidate:(e,i,o,t)=>{e.value!==void 0&&(t.storedValue=e.value),t.initialized=!0}});m({version:"1.0.0",...Gt,inputs:{},displayName:"Delay",extendedInputs:{value:{type:Q,description:"Input Value"},init:{type:Q,description:"Initial Value"}},extendedOutputs:{result:{type:Q,description:"Delayed Value"}},ui:{inspector:{fields:[{type:"tab-bar",label:"Init Mode",path:"initMode",default:"auto",options:[{label:"Auto (Use Value)",value:"auto"},{label:"Manual",value:"manual"}]}]}}});var Jn=Object.freeze({__proto__:null,logic_delay:Gt});const Kn=[xn,In,En,Dn,Pn,Fn,jn,Bn,$n,Gn,Hn,Un,Yn,Wn,Zn,Xn,Qn,Jn];Kn.flatMap(e=>Object.values(e).filter(i=>typeof i=="object"&&i!==null&&"kind"in i&&i.kind==="primitive"));function eo(e,i,o,t=new Map){const n={},s={},r={},l={},c=[],u={},d={},h={},p={};function f(g,N,w={},T=null,R=new Set,H=void 0,U=void 0){const $=new Map,te=new Set;for(const k of Object.values(g.inner.nodes)){const z=o.getNodeType(k.config.typeId);if(z&&z.getChildren){const S=z.getChildren(k,g.inner.nodes);for(const L of S){if($.has(L)){console.warn(`Node ${L} is owned by multiple parents! Keeping ${$.get(L)}, ignoring ${k.id}.`);continue}$.set(L,k.id)}S.length>0&&te.add(k.id)}}for(const k of Object.values(g.inner.nodes)){if($.has(k.id))continue;const z=N+k.id,S=o.getNodeType(k.config.typeId);if(S&&S.getChildren){const L=S.getChildren(k,g.inner.nodes);if(L.length>0){const P={inner:{nodes:{},connections:{}}},O=new Set(L);L.forEach(E=>{P.inner.nodes[E]=g.inner.nodes[E]}),Object.values(g.inner.connections).forEach(E=>{O.has(E.fromNodeId)&&O.has(E.toNodeId)&&(P.inner.connections[E.id]=E)});const ee=S?.definition?.subgraphExpansionTag;let Z=H,le=U;ee&&ee!=="inline"&&(Z=ee,le=z),f(P,z+".",k.config.values||{},k.id,R,Z,le)}const B=S?.compileConfig?S.compileConfig(k.config):k.config;n[z]={definitionId:k.config.typeId,defaultConfig:B,executionOwnerId:U},s[z]=k.config}else if(S?.definition?.subgraphExpansionTag){const L=S.definition.subgraphExpansionTag,B=k.config.subgraphId;if(R.has(B)){console.error(`Cycle detected: Subgraph ${B} includes itself (stack: ${Array.from(R).join(" -> ")}). Skipping.`);continue}const P=i.get(B);if(!P){console.warn(`Subgraph ${B} not found for node ${k.id}`);continue}let O=H,ee=U;L!=="inline"&&(O=L,ee=z);const Z=new Set(R);Z.add(B),f(P,z+".",k.config.values||{},k.id,Z,O,ee);const le=S?.compileConfig?S.compileConfig(k.config):k.config;n[z]={definitionId:k.config.typeId,defaultConfig:le,executionOwnerId:U},s[z]=k.config}else{const{typeId:L}=k.config,B=o.getNodeType(L),P=B?.compileConfig?B.compileConfig(k.config):k.config,O={definitionId:L,defaultConfig:P,executionTag:H,executionOwnerId:U},ee=z;if(n[ee]=O,s[ee]=k.config,l[k.id]=ee,N===""){if(k.config.typeId==="io.input"||k.config.typeId==="input"){const E=k.config.name||k.id;u[E]={nodeId:z,port:"value"}}else if(k.config.typeId==="io.output"||k.config.typeId==="output"){const E=k.config.name||k.id;d[E]={nodeId:z,port:"value"}}}if(N!==""&&(k.config.typeId==="io.input"||k.config.typeId==="input")){const E=Object.values(g.inner.nodes).filter(F=>F.config.typeId==="io.input"||F.config.typeId==="input").sort((F,X)=>F.y-X.y),pe=E.findIndex(F=>F.id===k.id);if(pe!==-1){const F=k.config.name||"value",X=ye(F,pe,E.length,"input"),fe=w[X];O.defaultConfig||(O.defaultConfig={fields:{}}),fe!==void 0&&(O.defaultConfig.values||(O.defaultConfig.values={}),O.defaultConfig.values[X]=fe),O.defaultConfig.fields?O.defaultConfig.fields.name=X:O.defaultConfig.name=X,O.defaultConfig.values||(O.defaultConfig.values={}),Object.prototype.hasOwnProperty.call(O.defaultConfig.values,X)||(O.defaultConfig.values[X]=void 0),T&&(h[T]||(h[T]={}),h[T][X]=z)}}if(N!==""&&(k.config.typeId==="io.output"||k.config.typeId==="output")&&T){const E=Object.values(g.inner.nodes).filter(F=>F.config.typeId==="io.output"||F.config.typeId==="output").sort((F,X)=>F.y-X.y),pe=E.findIndex(F=>F.id===k.id);if(pe!==-1){const F=k.config.name||"value",X=ye(F,pe,E.length,"output");p[T]||(p[T]={}),p[T][X]=z}}let Z=[];B&&(Array.isArray(B.inputs)?Z=B.inputs:B.inputs&&B.inputs.kind==="record"&&(Z=Object.entries(B.inputs.fields||{}).map(([E,pe])=>({name:E,defaultValue:pe.defaultValue}))));const le=new Set(Z.map(E=>E.name));k.config.values&&Object.keys(k.config.values).forEach(E=>le.add(E));for(const E of le)if(!Object.values(g.inner.connections).some(F=>F.toNodeId===k.id&&F.toPort===E)){let F=k.config.values?.[E];if(F===void 0){const X=Z.find(fe=>fe.name===E);X&&X.defaultValue!==void 0?F=X.defaultValue:X&&X.type&&X.type.defaultValue!==void 0&&(F=X.type.defaultValue)}F!==void 0&&(O.defaultConfig||(O.defaultConfig={fields:{}}),O.defaultConfig.values||(O.defaultConfig.values={}),O.defaultConfig.values[E]=F)}}}for(const k of Object.values(g.inner.connections)){let z=N+k.fromNodeId;$.has(k.fromNodeId)&&(z=N+$.get(k.fromNodeId)+"."+k.fromNodeId);let S=z,L=k.fromPort;const B=g.inner.nodes[k.fromNodeId],O=(B?o.getNodeType(B.config.typeId):void 0)?.definition?.subgraphExpansionTag;if(B&&O){const de=B.config.subgraphId,be=i.get(de);if(be){const xe=Object.values(be.inner.nodes).filter(ce=>ce.config.typeId==="io.output"||ce.config.typeId==="output").sort((ce,me)=>ce.y-me.y),Ie=xe.find((ce,me)=>{const Te=ce.config.name||"value";return ye(Te,me,xe.length,"output")===L});Ie&&(S=z+"."+Ie.id,L="value")}}let ee=N+k.toNodeId;$.has(k.toNodeId)&&(ee=N+$.get(k.toNodeId)+"."+k.toNodeId);let Z=ee,le=k.toPort;const E=g.inner.nodes[k.toNodeId],F=(E?o.getNodeType(E.config.typeId):void 0)?.definition?.subgraphExpansionTag;if(E&&F){const de=E.config.subgraphId,be=i.get(de);if(be){const xe=Object.values(be.inner.nodes).filter(ce=>ce.config.typeId==="io.input"||ce.config.typeId==="input").sort((ce,me)=>ce.y-me.y),Ie=xe.find((ce,me)=>{const Te=ce.config.name||"value";return ye(Te,me,xe.length,"input")===le});Ie&&(Z=ee+"."+Ie.id,le=le)}}let X=!0;B&&O&&O==="inline"&&S===z&&(X=!1);let fe=!0;if(E&&F&&F==="inline"&&Z===ee&&(fe=!1),X&&fe){if(c.push({fromNode:S,fromPort:L,toNode:Z,toPort:le}),$.has(k.fromNodeId)){const de=N+$.get(k.fromNodeId);de!==Z&&c.push({fromNode:de,fromPort:"___control___",toNode:Z,toPort:"___control___"})}if(O&&O!=="inline"){const de=z;S!==de&&c.push({fromNode:de,fromPort:"___control___",toNode:Z,toPort:"___control___"})}if(F&&F!=="inline"){const de=ee;Z!==de&&c.push({fromNode:S,fromPort:"___control___",toNode:de,toPort:"___control___"})}}}}f(e.graph,"");const y=new Map,v=new Map;Object.keys(n).forEach(g=>v.set(g,0)),c.forEach((g,N)=>{!n[g.fromNode]||!n[g.toNode]||(y.has(g.fromNode)||y.set(g.fromNode,[]),y.get(g.fromNode).push({toNode:g.toNode,connIndex:N}),v.set(g.toNode,(v.get(g.toNode)||0)+1))});const b=[],I=[],_=new Set;for(const[g,N]of v)N===0&&I.push(g);for(;b.length<Object.keys(n).length;){if(I.length===0){const g=Object.keys(n).filter(w=>!b.includes(w));let N=!1;for(const w of g){const T=n[w],R=o.get(T.definitionId);if(R&&R.kind==="primitive"&&R.cycleBreakingPorts&&R.cycleBreakingPorts.length>0){const H=new Set(R.cycleBreakingPorts);let U=0;c.forEach(($,te)=>{$.toNode===w&&g.includes($.fromNode)&&H.has($.toPort.toString())&&(v.set(w,(v.get(w)||0)-1),_.add(te),U++)}),U>0&&(N=!0,(v.get(w)||0)<=0&&I.push(w))}}if(!N&&g.length>0){let w=1/0,T=g[0];for(const R of g){const H=v.get(R)||0;H<w&&(w=H,T=R)}I.push(T)}if(I.length===0)break}if(I.length>0){const g=I.shift();if(b.push(g),y.has(g))for(const{toNode:N,connIndex:w}of y.get(g))_.add(w),v.set(N,(v.get(N)||0)-1),v.get(N)===0&&I.push(N)}}if(b.length!==Object.keys(n).length){console.warn("Graph contains cycles! Forced execution order.");for(const g of Object.keys(n))b.includes(g)||b.push(g)}const M=c.filter((g,N)=>_.has(N)).filter(g=>n[g.fromNode]&&n[g.toNode]),q=new Map,K=new Map,D=new Map;for(const g of b)K.set(g,{});let C=!1;for(const g of b){const N=n[g],w=o.get(N.definitionId);if(w&&w.kind==="primitive"&&w.usesMidiDeviceIO&&w.usesMidiDeviceIO(N.defaultConfig)){C=!0;break}}const W={repository:o,broadcast:()=>{},loadedSubgraphs:i};for(let g=b.length-1;g>=0;g--){const N=b[g],w=n[N],T=o.get(w.definitionId);if(T&&T.kind==="primitive"){const R={kind:"record",fields:K.get(N)||{}},H=w.defaultConfig||{fields:{}};let U={kind:"record",fields:T.inputs?{...T.inputs}:{}};if(T.computeBackwardPorts)try{const te=T.computeBackwardPorts(R,H,W);U={kind:"record",fields:{...U.fields,...te.inputRequirements.fields}},te.backwardMetadata&&D.set(N,te.backwardMetadata)}catch(te){console.warn(`Backward pass failed for ${N} (${T.id}):`,te)}const $=M.filter(te=>te.toNode===N);for(const te of $){const k=te.fromNode,z=te.fromPort.toString(),S=te.toPort.toString();if(U.fields[S]){const L=K.get(k);L[z]=U.fields[S]}}}}for(const g of b){const N=n[g],w=o.get(N.definitionId);if(!w)continue;const T={},R=M.filter(S=>S.toNode===g),H=new Map;for(const S of R){if(!q.has(S.fromNode))continue;const L=q.get(S.fromNode)?.outputs;if(L&&L.kind==="record"){const B=S.fromPort.toString();L.fields[B]&&(H.has(S.toPort.toString())||H.set(S.toPort.toString(),[]),H.get(S.toPort.toString()).push(L.fields[B]))}}const U=w.inputs||{};for(const[S,L]of H){const B=U[S];B&&"kind"in B&&B.kind==="array"?L.length>0&&(T[S]={kind:"array",element:L[0],size:L.length}):L.length>0&&(T[S]=L[L.length-1])}const $={kind:"record",fields:T},te=N.defaultConfig||{fields:{}};let k,z=$;try{if(w.kind==="primitive"&&w.computeForwardPorts){const S=w.computeForwardPorts($,te,W,D.get(g));z=S.inputs,k=S.outputs,S.forwardMetadata&&(r[g]=S.forwardMetadata)}else k=w.outputs&&w.outputs.kind==="record"?w.outputs:{kind:"record",fields:{}}}catch(S){console.warn(`Failed to compute output types for node ${g} (${w.id}):`,S),k={kind:"record",fields:{}}}q.set(g,{inputs:z,outputs:k})}for(const g of b){const N=n[g],w=o.get(N.definitionId),T=r[g];if(T&&w&&w.kind==="primitive"&&w.compileConfig){const R=s[g];if(R)try{const H=w.compileConfig(R,{compileCache:t,metadata:T}),U=N.defaultConfig?.values;N.defaultConfig=H,U&&(N.defaultConfig.values||(N.defaultConfig.values={}),Object.assign(N.defaultConfig.values,U))}catch(H){console.warn(`Re-compilation failed for ${g} (${w.id}):`,H)}}}const j={};for(const[g,N]of q)j[g]=N;return{graph:{id:"compiled-graph",kind:"graph",type:{kind:"graph",inputs:{kind:"record",fields:{}},outputs:{kind:"record",fields:{}}},nodes:n,connections:M,inputs:u,outputs:d,executionOrder:b,virtualInputMappings:h},inferredTypes:j,virtualInputMappings:h,outputRemappings:p,nodeMetadata:r,idMap:l,usesMidi:C}}self.onerror=e=>{console.error("Compiler Worker Error (Global):",e)};const Be=new Map;self.onmessage=async e=>{const{type:i}=e.data;if(i==="COMPILE_GRAPH"){const{state:o,subgraphs:t}=e.data;try{const n=new Map(Object.entries(t)),s=new Set;o.graph&&o.graph.inner&&o.graph.inner.nodes&&Object.values(o.graph.inner.nodes).forEach(b=>s.add(b.config.typeId)),n.forEach(b=>{b.inner&&b.inner.nodes&&Object.values(b.inner.nodes).forEach(I=>s.add(I.config.typeId))});const r=new Set,l=[];for(const b of s){if(r.has(b))continue;r.add(b);const I=ke.getNodeType(b);I&&I.definition&&I.definition.loadCompileDeps&&l.push(I.definition.loadCompileDeps())}l.length>0&&await Promise.all(l);const{graph:c,inferredTypes:u,virtualInputMappings:d,outputRemappings:h,nodeMetadata:p,idMap:f,usesMidi:y}=eo(o,n,ke,Be),v={type:"GRAPH_COMPILED",graph:c,inferredTypes:u,virtualInputMappings:d,outputRemappings:h,nodeMetadata:p,idMap:f,usesMidi:y};self.postMessage(v)}catch(n){console.error("Compiler Worker Error:",n)}}else if(i==="COMPILE_CONFIGS")try{const{nodes:o}=e.data,t=new Set;o.forEach(l=>t.add(l.typeId));const n=[],s=new Set;for(const l of t){if(s.has(l))continue;s.add(l);const c=ke.getNodeType(l);c&&c.definition&&c.definition.loadCompileDeps&&n.push(c.definition.loadCompileDeps())}n.length>0&&await Promise.all(n);const r={};for(const l of o){const c=ke.getNodeType(l.typeId);c&&c.compileConfig?r[l.id]=c.compileConfig(l.config,{compileCache:Be}):r[l.id]=l.config}self.postMessage({type:"CONFIGS_COMPILED",configs:r})}catch(o){console.error("Compiler Worker Error (Multi Config):",o)}};export{Re as D,ni as O,ii as a};
//# sourceMappingURL=compiler.worker-DXaGLi0n.js.map
