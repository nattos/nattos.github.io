{"version":3,"file":"wire-layout.worker-80sQ2dZk.js","sources":["../src/utils/min-heap.ts","../src/layout/wire-layout.ts","../src/workers/wire-layout.worker.ts"],"sourcesContent":["\nexport interface HeapItem {\n  key: number; // Packed integer coordinate\n  fScore: number;\n}\n\nexport class MinHeap {\n  private items: HeapItem[] = [];\n\n  push(key: number, fScore: number) {\n    this.items.push({ key, fScore });\n    this.bubbleUp(this.items.length - 1);\n  }\n\n  pop(): HeapItem | undefined {\n    if (this.items.length === 0) return undefined;\n    const root = this.items[0];\n    const last = this.items.pop();\n    if (this.items.length > 0 && last) {\n      this.items[0] = last;\n      this.bubbleDown(0);\n    }\n    return root;\n  }\n\n  size(): number {\n    return this.items.length;\n  }\n\n  private bubbleUp(index: number) {\n    while (index > 0) {\n      const parentIndex = Math.floor((index - 1) / 2);\n      if (this.items[index].fScore >= this.items[parentIndex].fScore) break;\n      this.swap(index, parentIndex);\n      index = parentIndex;\n    }\n  }\n\n  private bubbleDown(index: number) {\n    const length = this.items.length;\n    const element = this.items[index];\n\n    while (true) {\n      let leftChildIndex = 2 * index + 1;\n      let rightChildIndex = 2 * index + 2;\n      let leftChild, rightChild;\n      let swap = null;\n\n      if (leftChildIndex < length) {\n        leftChild = this.items[leftChildIndex];\n        if (leftChild.fScore < element.fScore) {\n          swap = leftChildIndex;\n        }\n      }\n\n      if (rightChildIndex < length) {\n        rightChild = this.items[rightChildIndex];\n        if (\n          (swap === null && rightChild.fScore < element.fScore) ||\n          (swap !== null && rightChild.fScore < leftChild!.fScore)\n        ) {\n          swap = rightChildIndex;\n        }\n      }\n\n      if (swap === null) break;\n      this.swap(index, swap);\n      index = swap;\n    }\n  }\n\n  private swap(i: number, j: number) {\n    const temp = this.items[i];\n    this.items[i] = this.items[j];\n    this.items[j] = temp;\n  }\n}\n","import { MinHeap } from '../utils/min-heap';\n\n/**\n * Wire Layout Engine\n *\n * Computes wires on a Logical Grid using A* with Gap bias.\n */\n\nexport interface GridPoint {\n    x: number;\n    y: number;\n}\n\nexport interface WireDef {\n    id: string;\n    start: GridPoint; // Node coordinates (x,y)\n    end: GridPoint;   // Node coordinates (x,y)\n    fromPort: string;\n    toPort: string;\n    startOffset?: number; // Row offset from start node top\n    endOffset?: number;   // Row offset from end node top\n}\n\nexport enum SegmentType {\n    Horizontal = 'h',\n    Vertical = 'v',\n    CornerTL = 'ctl',\n    CornerTR = 'ctr',\n    CornerBL = 'cbl',\n    CornerBR = 'cbr',\n    Start = 'start', // Stub?\n    End = 'end'\n}\n\nexport interface WireSegment {\n    id: string;\n    wireId: string;\n    x: number;\n    y: number;\n    type: SegmentType;\n    lane?: number; // Deprecated, use laneH for Y-spread\n    totalLanes?: number; // Deprecated, use totalHLanes\n\n    // Vertical Spreading (X-offset)\n    laneV?: number;\n    totalVLanes?: number;\n\n    // Horizontal Spreading (Y-offset)\n    laneH?: number;\n    totalHLanes?: number;\n\n    length?: number;\n    clipTopRem?: number; // If set, clip vertical top to this Rem's offset\n    clipBotRem?: number; // If set, clip vertical bot to this Rem's offset\n}\n\nexport interface LayoutResult {\n    segments: WireSegment[];\n    wires: Record<string, { path: GridPoint[] }>;\n}\n\n// Obstacle Map: \"x,y\" -> Set of Logical Lanes blocked?\n// Or simpler: We just block coordinate strings \"x,logicY\".\n// BUT to support \"Wormholes\", we need to know the 'Height' of each Node Column.\n// Map: `${x},${gridRow}` -> Height (number of used lanes 0..H-1).\ninterface Obstacle {\n    x: number;\n    y: number;\n    height?: number; // Logical height (1..32)\n}\n\ninterface InternalObstacle {\n    x: number;\n    y: number; // Logical Y\n}\n\nexport interface LayoutOptions {\n    obstacles?: Obstacle[];\n    algorithm?: 'astar' | 'greedy';\n    previousResult?: LayoutResult;\n}\n\nfunction pack(x: number, y: number): number {\n    return (x & 0xFFFF) | (y << 16);\n}\n\nfunction unpack(key: number): GridPoint {\n    return { x: key & 0xFFFF, y: key >>> 16 };\n}\n\nfunction getKey(p: GridPoint) { return `${p.x},${p.y}`; }\nfunction pointsEqual(a: GridPoint, b: GridPoint) { return a.x === b.x && a.y === b.y; }\n\nexport function computeWireLayout(wires: WireDef[], options: LayoutOptions = {}): LayoutResult {\n    const segments: WireSegment[] = [];\n    const wirePaths: Record<string, { path: GridPoint[] }> = {};\n\n    // 1. Build Obstacle Map (Logical Coordinates) using Packed Integers\n    const obstacles = new Set<number>();\n    const colHeightMap = new Map<string, number>();\n\n    // Config: Logical Scale\n    // X: Odd = Node, Even = Gap. (Base x*2+1).\n    // Y: 1 Logical Unit = 1 Grid Row (Possible Lanes).\n    // Increased to 32 to support high port count nodes.\n    const LOGICAL_Y_SCALE = 32;\n\n    for (const obs of (options.obstacles || [])) {\n        const lx = obs.x * 2 + 1;\n        const basePathY = obs.y * LOGICAL_Y_SCALE;\n\n        if (obs.height && obs.height > 1) {\n            // Register Column Height\n            colHeightMap.set(`${lx},${obs.y}`, obs.height);\n\n            const effectiveH = Math.min(obs.height, 31); // Don't block gap lane\n            for (let i = 0; i < effectiveH; i++) {\n                obstacles.add(pack(lx, basePathY + i));\n            }\n        } else {\n            // Default\n            colHeightMap.set(`${lx},${obs.y}`, 1);\n            obstacles.add(pack(lx, basePathY));\n        }\n    }\n\n    const toLogical = (p: GridPoint) => ({\n        // Logical Grid aligned with GraphGrid:\n        // Nodes are at Odd X (1, 3, 5).\n        // Gaps are at Even X (0, 2, 4, 6).\n        // Y: 1 Unit = 1 Row.\n        x: p.x * 2 + 1,\n        y: p.y * LOGICAL_Y_SCALE\n    });\n\n    const gridUsage = new Map<number, number>();\n    const gridUsageH = new Map<number, number>();\n    const currentUsageH = new Map<number, number>();\n    const gridUsageV = new Map<number, number>();\n    const currentUsageV = new Map<number, number>();\n\n    // 2. Route Wires\n    for (const wire of wires) {\n        // const startNode = toLogical(wire.start);\n        // const endNode = toLogical(wire.end);\n\n        const startP = { x: wire.start.x * 2 + 2, y: wire.start.y * LOGICAL_Y_SCALE + (wire.startOffset || 0) };\n        const endP = { x: wire.end.x * 2, y: wire.end.y * LOGICAL_Y_SCALE + (wire.endOffset || 0) };\n\n        let path: GridPoint[] = [];\n\n        // Simple case: Direct connection?\n        if (pointsEqual(startP, endP)) {\n            path = [startP];\n        } else {\n            // A* Search Optimized with MinHeap and Integer Keys\n            const openSet = new MinHeap();\n            const cameFrom = new Map<number, number>();\n            const gScore = new Map<number, number>();\n            // fScore is stored in the heap item\n\n            const startKey = pack(startP.x, startP.y);\n            const endKey = pack(endP.x, endP.y);\n\n            gScore.set(startKey, 0);\n\n            // Virtual Parent to enforce \"Horizontal\" start direction (Wire comes out of Right)\n            // This forces any immediate vertical drop to be considered a 'Turn', incurring penalties.\n            const virtualParentKey = pack(startP.x - 1, startP.y);\n            cameFrom.set(startKey, virtualParentKey);\n\n            // Heuristic\n            const h = (ax: number, ay: number) => Math.abs(ax - endP.x) + Math.abs(ay - endP.y);\n\n            openSet.push(startKey, h(startP.x, startP.y));\n\n            const visited = new Set<number>();\n\n            // Safety Bounds\n            const searchMinY = -1;\n            const searchMaxY = Math.max(startP.y, endP.y) + 256; // Allow some slack but prevent infinity\n            const searchMinX = Math.min(startP.x, endP.x) - 100;\n            const searchMaxX = Math.max(startP.x, endP.x) + 100;\n            let safetyCounter = 0;\n            const SAFETY_LIMIT = 500000; // Increased limit because heap is fast\n\n            while (openSet.size() > 0) {\n                safetyCounter++;\n                if (safetyCounter > SAFETY_LIMIT) {\n                    console.warn(`WireLayout: A* Safety Limit Reached (${SAFETY_LIMIT}) for wire ${wire.id}`);\n                    break;\n                }\n\n                const currentItem = openSet.pop();\n                if (!currentItem) break;\n                const currentKey = currentItem.key;\n\n                // If we found the goal\n                if (currentKey === endKey) {\n                    // Reconstruct\n                    let currKey = currentKey;\n                    path = [unpack(currKey)];\n                    while (cameFrom.has(currKey)) {\n                        const prev = cameFrom.get(currKey)!;\n                        // Stop if we reach the virtual parent\n                        if (prev === virtualParentKey) break;\n\n                        currKey = prev;\n                        path.unshift(unpack(currKey));\n                    }\n                    break;\n                }\n\n                // If already visited with a lower cost? Heap doesn't support update key easily,\n                // so we might pop duplicates.\n                if (visited.has(currentKey)) continue;\n                visited.add(currentKey);\n\n                const cP = unpack(currentKey);\n\n                // Neighbors\n                // Generate directly\n                const neighborsX = [cP.x + 1, cP.x - 1];\n                const neighborsY = [cP.y, cP.y];\n\n                // Vertical Steps: Only allow Vertical movement in GAP Columns (Even X).\n                if (cP.x % 2 === 0) {\n                    if (cP.y > searchMinY) { neighborsX.push(cP.x); neighborsY.push(cP.y - 1); }\n                    if (cP.y < searchMaxY) { neighborsX.push(cP.x); neighborsY.push(cP.y + 1); }\n                }\n\n                for (let i = 0; i < neighborsX.length; i++) {\n                    const nx = neighborsX[i];\n                    const ny = neighborsY[i];\n\n                    if (nx < searchMinX || nx > searchMaxX || ny < searchMinY || ny > searchMaxY) continue; // Boundary Check\n\n                    const nKey = pack(nx, ny);\n                    // Checking visited here is optimization but technically handled by set check above.\n                    // But good for perf.\n                    if (visited.has(nKey)) continue;\n\n                    let cost = 1;\n                    const isEnd = (nKey === endKey);\n\n                    // Obstacle Check\n                    if (obstacles.has(nKey) && !isEnd) {\n                        continue; // Blocked\n                    }\n\n                    // Turn Penalty (Direction Change)\n                    const prevKey = cameFrom.get(currentKey);\n                    if (prevKey !== undefined) {\n                        const prevP = unpack(prevKey);\n                        if (prevP.x !== nx && prevP.y !== ny) {\n                            cost += 1;\n                            // Gap Turn Penalty: Turning in Gap Column (Even X)\n                            if (cP.x % 2 === 0) {\n                                cost += 20;\n                            }\n                        }\n\n                        // Midpoint Bias: Penalize turning Vertical if far from Midpoint\n                        // We only care if we are turning FROM Horizontal TO Vertical.\n                        // cP is 'current' (parent of neighbor 'n'). prevP is 'grandparent'.\n                        // Direction prevP -> cP. Direction cP -> n(nx,ny).\n                        const dx1 = cP.x - prevP.x;\n                        const dy1 = cP.y - prevP.y;\n                        const dx2 = nx - cP.x;\n                        const dy2 = ny - cP.y;\n\n                        // Check if turn: (dx1 != dx2 || dy1 != dy2).\n                        // Specifically, check if we are turning Vertical (dy2 != 0) from Horizontal (dy1 == 0).\n                        if (dy1 === 0 && dy2 !== 0) {\n                            const midX = (startP.x + endP.x) / 2;\n                            const dist = Math.abs(cP.x - midX);\n                            // Penalty proportional to distance from midpoint.\n                            // We want to encourage being CLOSE to midX.\n                            // A linear penalty.\n                            // We need this to optionally outweigh the cost of an extra turn (GapTurn ~20).\n                            // If we turn at the end (L-shape), we save 1 turn.\n                            // So (Penalty at End) must be > (Cost of Extra Turn).\n                            // Penalty > 20.\n                            // If End is 10 units away, Factor 2 => 20. Borderline.\n                            // Factor 4 => 40. Clearly favors S-shape.\n                            // To force S-shape even for close nodes (Dist=1), we need Factor > 20.\n                            const midPenalty = dist * 25;\n                            cost += midPenalty;\n                        }\n                    }\n\n                    const tentativeG = (gScore.get(currentKey) || 0) + cost;\n\n                    if (tentativeG < (gScore.get(nKey) || Infinity)) {\n                        cameFrom.set(nKey, currentKey);\n                        gScore.set(nKey, tentativeG);\n                        const f = tentativeG + h(nx, ny);\n                        openSet.push(nKey, f);\n                    }\n                }\n            }\n        }\n\n        // Check if path found\n        if (path.length === 0) {\n            // Fallback\n            path = [startP, endP];\n        }\n\n        // Deduplication\n        if (path.length > 0) {\n            const dedup: GridPoint[] = [path[0]];\n            for (let i = 1; i < path.length; i++) {\n                const prev = dedup[dedup.length - 1];\n                const curr = path[i];\n                if (!pointsEqual(prev, curr)) {\n                    dedup.push(curr);\n                }\n            }\n            path = dedup;\n        }\n\n        wirePaths[wire.id] = { path };\n        for (let i = 0; i < path.length; i++) {\n            const p = path[i];\n            const k = pack(p.x, p.y);\n            gridUsage.set(k, (gridUsage.get(k) || 0) + 1);\n\n            // Determine if this point is part of a Horizontal Wire\n            const prev = i > 0 ? path[i - 1] : null;\n            const next = i < path.length - 1 ? path[i + 1] : null;\n\n            let isH = false;\n            // It is horizontal if we enter or exit horizontally\n            if (prev && prev.x !== p.x) isH = true;\n            if (next && next.x !== p.x) isH = true;\n            // Single point path default to Horizontal (e.g. adjacent nodes)\n            if (!prev && !next) isH = true;\n\n            let isV = false;\n            // It is vertical if we enter or exit vertically\n            if (prev && prev.y !== p.y) isV = true;\n            if (next && next.y !== p.y) isV = true;\n\n            if (isH) {\n                gridUsageH.set(k, (gridUsageH.get(k) || 0) + 1);\n            }\n            if (isV) {\n                gridUsageV.set(k, (gridUsageV.get(k) || 0) + 1);\n            }\n        }\n    }\n\n    // 3. Assign Lanes\n    const currentUsage = new Map<number, number>();\n    const GAP_LANE_INDEX = LOGICAL_Y_SCALE - 1;\n\n    for (const wire of wires) {\n        const path = wirePaths[wire.id].path;\n        if (!path || path.length === 0) continue;\n\n        // Add Start Stub\n        const startNode = toLogical(wire.start);\n        segments.push({\n            id: `${wire.id}-start`,\n            wireId: wire.id,\n            x: startNode.x,\n            y: startNode.y + (wire.startOffset || 0),\n            type: SegmentType.Start,\n            lane: 0,\n            totalLanes: 1,\n            length: 1\n        });\n\n        // Add End Stub\n        const endNode = toLogical(wire.end);\n        const endStubY = endNode.y + (wire.endOffset || 0);\n        segments.push({\n            id: `${wire.id}-end`,\n            wireId: wire.id,\n            x: endNode.x,\n            y: endStubY,\n            type: SegmentType.End,\n            lane: 0,\n            totalLanes: 1,\n            length: 1\n        });\n\n        for (let i = 0; i < path.length; i++) {\n            const p = path[i];\n            const k = pack(p.x, p.y); // Use packed key for usage map\n            const total = gridUsage.get(k) || 1;\n            const index = currentUsage.get(k) || 0;\n            currentUsage.set(k, index + 1);\n\n\n            // Determine Type\n            const prev = i > 0 ? path[i - 1] : null;\n            const next = i < path.length - 1 ? path[i + 1] : null;\n\n            let type = SegmentType.Horizontal;\n\n            if (prev && next) {\n                const dx1 = p.x - prev.x;\n                const dy1 = p.y - prev.y;\n                const dx2 = next.x - p.x;\n                const dy2 = next.y - p.y;\n\n                if (dx1 !== 0 && dx2 !== 0) type = SegmentType.Horizontal;\n                else if (dy1 !== 0 && dy2 !== 0) type = SegmentType.Vertical;\n                else {\n                    if (dx1 === 1 && dy2 > 0) type = SegmentType.CornerTR;\n                    else if (dx1 === 1 && dy2 < 0) type = SegmentType.CornerBR;\n                    else if (dx1 === -1 && dy2 > 0) type = SegmentType.CornerTL;\n                    else if (dx1 === -1 && dy2 < 0) type = SegmentType.CornerBL;\n                    else if (dy1 > 0 && dx2 === 1) type = SegmentType.CornerBL;\n                    else if (dy1 > 0 && dx2 === -1) type = SegmentType.CornerBR;\n                    else if (dy1 < 0 && dx2 === 1) type = SegmentType.CornerTL;\n                    else if (dy1 < 0 && dx2 === -1) type = SegmentType.CornerTR;\n                }\n            } else if (!prev) {\n                if (!next) {\n                    type = SegmentType.Horizontal;\n                } else {\n                    type = (next.x !== p.x) ? SegmentType.Horizontal : SegmentType.Vertical;\n                }\n                if (next) {\n                    if (next.y < p.y) type = SegmentType.CornerBR;\n                    else if (next.y > p.y) type = SegmentType.CornerTR;\n                }\n            } else if (!next) {\n                if (prev) {\n                    const isRight = endNode.x > p.x;\n                    if (prev.y < p.y) {\n                        type = isRight ? SegmentType.CornerBL : SegmentType.CornerBR;\n                    } else if (prev.y > p.y) {\n                        type = isRight ? SegmentType.CornerTL : SegmentType.CornerTR;\n                    } else {\n                        type = SegmentType.Horizontal;\n                    }\n                }\n            }\n\n            let clipTopRem = undefined;\n            let clipBotRem = undefined;\n\n            const gridY = Math.floor(p.y / LOGICAL_Y_SCALE);\n            const rem = p.y % LOGICAL_Y_SCALE;\n            const isNodeRow = rem < GAP_LANE_INDEX;\n\n            // Clipping Logic\n            if (isNodeRow) {\n                if (prev) {\n                    if (prev.x === p.x && prev.y < p.y) {\n                        const prevGridY = Math.floor(prev.y / LOGICAL_Y_SCALE);\n                        if (prevGridY === gridY) {\n                            if ((prev.y % LOGICAL_Y_SCALE) < GAP_LANE_INDEX) {\n                                clipTopRem = prev.y % LOGICAL_Y_SCALE;\n                            }\n                        } else if (prevGridY === gridY - 1) {\n                            if ((prev.y % LOGICAL_Y_SCALE) === GAP_LANE_INDEX) {\n                                clipTopRem = -1;\n                            }\n                        }\n                    }\n                }\n                if (next) {\n                    if (next.x === p.x && next.y > p.y) {\n                        const nextGridY = Math.floor(next.y / LOGICAL_Y_SCALE);\n                        if (nextGridY === gridY) {\n                            if ((next.y % LOGICAL_Y_SCALE) < GAP_LANE_INDEX) {\n                                clipBotRem = next.y % LOGICAL_Y_SCALE;\n                            } else if ((next.y % LOGICAL_Y_SCALE) === GAP_LANE_INDEX) {\n                                clipBotRem = GAP_LANE_INDEX;\n                            }\n                        }\n                    }\n                }\n\n                // Reverse Checks\n                if (prev) {\n                    if (prev.x === p.x && prev.y > p.y) {\n                        const prevGridY = Math.floor(prev.y / LOGICAL_Y_SCALE);\n                        if (prevGridY === gridY) {\n                            if ((prev.y % LOGICAL_Y_SCALE) < GAP_LANE_INDEX) {\n                                clipBotRem = prev.y % LOGICAL_Y_SCALE;\n                            } else if ((prev.y % LOGICAL_Y_SCALE) === GAP_LANE_INDEX) {\n                                clipBotRem = GAP_LANE_INDEX;\n                            }\n                        }\n                    }\n                }\n                if (next) {\n                    if (next.x === p.x && next.y < p.y) {\n                        const nextGridY = Math.floor(next.y / LOGICAL_Y_SCALE);\n                        if (nextGridY === gridY) {\n                            if ((next.y % LOGICAL_Y_SCALE) < GAP_LANE_INDEX) {\n                                clipTopRem = next.y % LOGICAL_Y_SCALE;\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (prev && prev.x === p.x && prev.y < p.y) {\n                    clipTopRem = -1;\n                }\n            }\n\n            if (type === SegmentType.Horizontal || type === SegmentType.CornerBL || type === SegmentType.CornerBR || type === SegmentType.CornerTL || type === SegmentType.CornerTR) {\n                const idx = currentUsageH.get(k) || 0;\n                currentUsageH.set(k, idx + 1);\n            }\n            if (type === SegmentType.Vertical || type === SegmentType.CornerBL || type === SegmentType.CornerBR || type === SegmentType.CornerTL || type === SegmentType.CornerTR) {\n                const idx = currentUsageV.get(k) || 0;\n                currentUsageV.set(k, idx + 1);\n            }\n\n            segments.push({\n                id: `${wire.id}-${i}`,\n                wireId: wire.id,\n                x: p.x,\n                y: p.y,\n                type,\n                // Assign BOTH H and V lanes if applicable\n                // For pure H, laneH is valid, laneV is undefined\n                // For pure V, laneV is valid, laneH is undefined\n                // For Corner, BOTH are valid.\n                laneH: (type === SegmentType.Horizontal || type === SegmentType.CornerBL || type === SegmentType.CornerBR || type === SegmentType.CornerTL || type === SegmentType.CornerTR) ? (currentUsageH.get(k) || 1) : undefined,\n                totalHLanes: (type === SegmentType.Horizontal || type === SegmentType.CornerBL || type === SegmentType.CornerBR || type === SegmentType.CornerTL || type === SegmentType.CornerTR) ? (gridUsageH.get(k) || 0) : undefined,\n\n                laneV: (type === SegmentType.Vertical || type === SegmentType.CornerBL || type === SegmentType.CornerBR || type === SegmentType.CornerTL || type === SegmentType.CornerTR) ? (currentUsageV.get(k) || 1) : undefined,\n                totalVLanes: (type === SegmentType.Vertical || type === SegmentType.CornerBL || type === SegmentType.CornerBR || type === SegmentType.CornerTL || type === SegmentType.CornerTR) ? (gridUsageV.get(k) || 0) : undefined,\n\n                length: 1,\n                clipTopRem,\n                clipBotRem\n            });\n        }\n    }\n\n    // 4. Post-Process Coalescing\n    const coalescedSegments: WireSegment[] = [];\n    const slotMap = new Map<string, WireSegment[]>();\n\n    for (const seg of segments) {\n        const logicalSlot = Math.floor(seg.y / LOGICAL_Y_SCALE);\n        const rem = seg.y % LOGICAL_Y_SCALE;\n\n        let gridRowKey = '';\n        if (rem < GAP_LANE_INDEX) {\n            gridRowKey = `${seg.wireId}:${seg.x}:${logicalSlot}:node`;\n        } else {\n            gridRowKey = `${seg.wireId}:${seg.x}:${logicalSlot}:gap`;\n        }\n\n        if (!slotMap.has(gridRowKey)) slotMap.set(gridRowKey, []);\n        slotMap.get(gridRowKey)!.push(seg);\n    }\n\n    // Process buckets\n    for (const [key, bucket] of slotMap.entries()) {\n        const hasCorner = bucket.some(s => s.type !== SegmentType.Horizontal && s.type !== SegmentType.Vertical && s.type !== SegmentType.Start && s.type !== SegmentType.End);\n\n        const extendsHigher = (aRem: number | undefined, bRem: number | undefined) => {\n            if (aRem === undefined && bRem !== undefined) return true;\n            if (aRem !== undefined && bRem !== undefined && aRem < bRem) return true;\n            return false;\n        };\n\n        const extendsLower = (aRem: number | undefined, bRem: number | undefined) => {\n            if (aRem === undefined && bRem !== undefined) return true;\n            if (aRem !== undefined && bRem !== undefined && aRem > bRem) return true;\n            return false;\n        };\n\n        if (hasCorner) {\n            const verticals = bucket.filter(s => s.type === SegmentType.Vertical);\n            const corners = bucket.filter(s => s.type !== SegmentType.Vertical && s.type !== SegmentType.Horizontal && s.type !== SegmentType.Start && s.type !== SegmentType.End);\n\n            for (const c of corners) {\n                if (c.type === SegmentType.CornerBL || c.type === SegmentType.CornerBR) {\n                    for (const v of verticals) {\n                        if (extendsHigher(v.clipTopRem, c.clipTopRem)) {\n                            c.clipTopRem = v.clipTopRem;\n                        }\n                    }\n                } else if (c.type === SegmentType.CornerTL || c.type === SegmentType.CornerTR) {\n                    for (const v of verticals) {\n                        if (extendsLower(v.clipBotRem, c.clipBotRem)) {\n                            c.clipBotRem = v.clipBotRem;\n                        }\n                    }\n                }\n            }\n\n            for (const s of bucket) {\n                if (s.type !== SegmentType.Vertical) {\n                    coalescedSegments.push(s);\n                }\n            }\n        } else {\n            const verticals = bucket.filter(s => s.type === SegmentType.Vertical);\n            const others = bucket.filter(s => s.type !== SegmentType.Vertical);\n\n            if (verticals.length > 0) {\n                let merged = { ...verticals[0] };\n                for (let i = 1; i < verticals.length; i++) {\n                    const v = verticals[i];\n                    if (extendsHigher(v.clipTopRem, merged.clipTopRem)) {\n                        merged.clipTopRem = v.clipTopRem;\n                    }\n                    if (extendsLower(v.clipBotRem, merged.clipBotRem)) {\n                        merged.clipBotRem = v.clipBotRem;\n                    }\n                }\n                coalescedSegments.push(merged);\n            }\n            coalescedSegments.push(...others);\n        }\n    }\n\n    return {\n        segments: coalescedSegments,\n        wires: wirePaths\n    };\n}\n","\nimport { computeWireLayout } from '../layout/wire-layout';\nimport { WiringWorkerMessage, WiringMainMessage } from './types';\n\nconst ctx: Worker = self as any;\n\nctx.onmessage = (event: MessageEvent<WiringWorkerMessage>) => {\n  const { type, wires, options } = event.data;\n\n  if (type === 'LAYOUT_REQUEST') {\n    const layout = computeWireLayout(wires, options);\n\n    const response: WiringMainMessage = {\n      type: 'LAYOUT_RESULT',\n      layout\n    };\n\n    ctx.postMessage(response);\n  }\n};\n"],"names":["MinHeap","key","fScore","root","last","index","parentIndex","length","element","leftChildIndex","rightChildIndex","leftChild","rightChild","swap","i","j","temp","pack","x","y","unpack","pointsEqual","a","b","computeWireLayout","wires","options","segments","wirePaths","obstacles","colHeightMap","LOGICAL_Y_SCALE","obs","lx","basePathY","effectiveH","toLogical","p","gridUsage","gridUsageH","currentUsageH","gridUsageV","currentUsageV","wire","startP","endP","path","openSet","cameFrom","gScore","startKey","endKey","virtualParentKey","h","ax","ay","visited","searchMinY","searchMaxY","searchMinX","searchMaxX","safetyCounter","SAFETY_LIMIT","currentItem","currentKey","currKey","prev","cP","neighborsX","neighborsY","nx","ny","nKey","cost","isEnd","prevKey","prevP","dy1","dy2","midX","midPenalty","tentativeG","f","dedup","curr","k","next","isH","isV","currentUsage","GAP_LANE_INDEX","startNode","endNode","endStubY","type","dx1","dx2","isRight","clipTopRem","clipBotRem","gridY","prevGridY","idx","coalescedSegments","slotMap","seg","logicalSlot","rem","gridRowKey","bucket","hasCorner","s","extendsHigher","aRem","bRem","extendsLower","verticals","corners","c","v","others","merged","ctx","event","response"],"mappings":"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"}