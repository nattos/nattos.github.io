{"version":3,"file":"compiler.worker-Bo2AcOGZ.js","sources":["../src/structor/type-helpers.ts","../src/structor/repository.ts","../src/structor/node-helpers.ts","../src/structor/structor.ts","../src/customnodes/curve/types.ts","../src/customnodes/curve/curve-ease.ts","../src/customnodes/curve/curve-env.ts","../src/customnodes/curve/curve-crop.ts","../src/structor/std-types.ts","../src/customnodes/debug/debug-scope.ts","../src/customnodes/debug/nodes-registration.ts","../src/customnodes/expr/expr-executor.ts","../src/customnodes/expr/expr-eval.ts","../src/customnodes/gen/gen-sawtooth.ts","../src/customnodes/gen/gen-adsr.ts","../src/customnodes/math/math-random.ts","../src/customnodes/midi/midi-input.ts","../src/customnodes/midi/midi-cc.ts","../src/customnodes/midi/midi-note.ts","../src/customnodes/midi/midi-to-mono.ts","../src/customnodes/midi/midi-filter.ts","../src/customnodes/midi/midi-pitch.ts","../src/customnodes/midi/midi-trigger.ts","../src/customnodes/midi/midi-merge.ts","../src/customnodes/midi/midi-select.ts","../src/customnodes/midi/midi-on-change.ts","../src/customnodes/midi/midi-on-range.ts","../src/customnodes/shared-inspector-fields.ts","../src/customnodes/midi/midi-delay.ts","../src/customnodes/midi/midi-istrigger.ts","../src/customnodes/midi/midi-metronome.ts","../src/customnodes/time/time-nodes.ts","../src/customnodes/nicepattern/nice-types.ts","../src/customnodes/nicepattern/nice-rhythmic.ts","../src/customnodes/nicepattern/utils.ts","../src/customnodes/nicepattern/nice-chaos.ts","../src/customnodes/nicepattern/abstract-layer.ts","../src/customnodes/nicepattern/layers.ts","../src/customnodes/nicepattern/nice-layers.ts","../src/customnodes/nicepattern/nice-tonesynth.ts","../src/customnodes/nicepattern/orthomod.ts","../src/customnodes/nicepattern/tone4.ts","../src/customnodes/nicepattern/magneto.ts","../src/customnodes/seq/seq-tomidi.ts","../src/customnodes/seq/seq-sequencer.ts","../src/customnodes/seq/seq-player.ts","../src/customnodes/seq/seq-modifier.ts","../src/customnodes/seq/seq-logic.ts","../src/structor/nodes/binary.ts","../src/structor/nodes/unary.ts","../src/structor/nodes/list.ts","../src/structor/nodes/constants.ts","../src/structor/nodes/utils.ts","../src/structor/nodes/io_input.ts","../src/structor/nodes/io_output.ts","../src/structor/nodes/core_subgraph.ts","../src/structor/nodes/core_thensubgraph.ts","../src/structor/nodes/core_pack.ts","../src/structor/nodes/core_unpack.ts","../src/structor/trigger-helpers.ts","../src/structor/nodes/core_ifthen.ts","../src/structor/nodes/data_literal.ts","../src/structor/nodes/data_hub.ts","../src/structor/nodes/functional.ts","../src/structor/nodes/logic_select.ts","../src/structor/nodes/logic_latch.ts","../src/structor/nodes/logic_delay.ts","../src/structor/primitives.ts","../src/builder/compiler.ts","../src/workers/compiler.worker.ts"],"sourcesContent":["import {\n  StructorType,\n  AtomicType,\n  ArrayType,\n  RecordType,\n  PrimitiveNodeDefinition,\n  StructorRecord,\n  ExecutionContext,\n  Structor,\n  BroadcastConfig,\n  NodeMetadata,\n  AnalysisContext\n} from './structor';\nimport { RegionVisibility } from './repository';\n\nexport const NumberType = { kind: 'atomic' as const, type: 'number' as const, defaultValue: 0 };\nexport const StringType = { kind: 'atomic' as const, type: 'string' as const, defaultValue: '' };\nexport const AnyType: StructorType = { kind: 'atomic', type: 'any' };\n\n// --- Type Inference Helpers ---\n\nexport type InferStructorType<T extends StructorType> =\n  T extends { optional: true }\n  ? InferStructorTypeBase<T> | undefined | null\n  : InferStructorTypeBase<T>;\n\ntype InferStructorTypeBase<T extends StructorType> =\n  T extends AtomicType ? InferAtomic<T> :\n  T extends ArrayType ? Array<InferStructorType<T['element']>> :\n  T extends RecordType ? InferRecord<T> :\n  any;\n\ntype InferAtomic<T extends AtomicType> =\n  T['type'] extends 'number' ? number :\n  T['type'] extends 'string' ? string :\n  T['type'] extends 'boolean' ? boolean :\n  any;\n\nexport type InferRecord<T extends RecordType> =\n  { [K in keyof T['fields']as T['fields'][K] extends { optional: true } ? K : never]?: InferStructorType<T['fields'][K]> } &\n  { [K in keyof T['fields']as T['fields'][K] extends { optional: true } ? never : K]: InferStructorType<T['fields'][K]> };\n\n// Helper to define a type while preserving its literal nature for inference\nexport function defineType<T extends StructorType>(t: T): T {\n  return t;\n}\n\n// --- Type Enforcement Helpers ---\n\nexport type TypedStructorType<T> =\n  T extends number ? { kind: 'atomic', type: 'number' } & Partial<AtomicType> :\n  T extends string ? { kind: 'atomic', type: 'string' } & Partial<AtomicType> :\n  T extends boolean ? { kind: 'atomic', type: 'boolean' } & Partial<AtomicType> :\n  T extends (infer U)[] ? { kind: 'array', element: TypedStructorType<U> } & Partial<ArrayType> :\n  T extends Record<string, any> ? TypedRecordType<T> :\n  StructorType;\n\nexport type TypedRecordType<T> = {\n  kind: 'record';\n  fields: {\n    [K in keyof T]-?: TypedStructorType<NonNullable<T[K]>> & (undefined extends T[K] ? { optional: true } : unknown)\n  };\n} & Partial<Omit<RecordType, 'fields'>>;\n\nexport function defineRecordType<T>(def: TypedRecordType<T>): RecordType {\n  return def as unknown as RecordType;\n}\n\n\n// --- Marshalling Helpers ---\n\nexport function fromStructor(value: Structor, type: StructorType): any {\n  if (value === undefined || value === null) return value;\n\n  if (type.kind === 'atomic') {\n    if (value && typeof value === 'object' && 'kind' in value && (value as any).kind === 'atomic') {\n      return (value as any).value;\n    }\n    return value;\n  }\n\n  if (type.kind === 'array') {\n    if (Array.isArray(value)) {\n      return value.map(v => fromStructor(v, type.element));\n    }\n    return []; // Should not happen if types match\n  }\n\n  if (type.kind === 'record') {\n    // Value could be StructorRecord OR plain object (if system is loose)\n    if (typeof value === 'object') {\n      // Check if it's a StructorRecord (has fields)\n      if ('fields' in value) {\n        const rec = value as StructorRecord;\n        const result: any = {};\n        for (const [k, fieldType] of Object.entries(type.fields)) {\n          if (k in rec.fields) {\n            result[k] = fromStructor(rec.fields[k], fieldType);\n          }\n        }\n\n        return result;\n      }\n      // Fallback: treat as plain object (already unwrapped or loose)\n      // We still need to recursively unwrap fields if they are StructorRecords\n      const result: any = {};\n      for (const [k, fieldType] of Object.entries(type.fields)) {\n        if (k in value) {\n          result[k] = fromStructor((value as any)[k], fieldType);\n        }\n      }\n\n      return result;\n    }\n    return value;\n  }\n\n  return value;\n}\n\nexport function toStructor(value: any, type: StructorType): Structor {\n  if (value === undefined || value === null) return value; // Or throw?\n\n  if (type.kind === 'atomic') return value;\n\n  if (type.kind === 'array') {\n    if (Array.isArray(value)) {\n      const res = value.map(v => toStructor(v, type.element));\n      // console.error('toStructor array res', res);\n      return res;\n    }\n    console.error('toStructor array fail: not array', value);\n    return [];\n  }\n\n  if (type.kind === 'record') {\n    const fields: Record<string, Structor> = {};\n    for (const [k, fieldType] of Object.entries(type.fields)) {\n      if (value[k] !== undefined) {\n        fields[k] = toStructor(value[k], fieldType);\n      }\n    }\n    return { fields };\n  }\n\n  return value;\n}\n\n// --- Node Definition Helper ---\n\nexport type NodeInputsDef = Record<string, StructorType & { redirect?: string; defaultValue?: any }>;\nexport type NodeConfigDef = Record<string, StructorType>;\nexport type NodeOutputsDef = Record<string, StructorType>;\n\nexport interface TypedNodeOptions<\n  TInputs extends NodeInputsDef,\n  TConfig extends NodeConfigDef,\n  TOutputs extends NodeOutputsDef,\n  TState = undefined\n> {\n  id: string;\n  metadata?: NodeMetadata;\n  inputs?: TInputs;\n  config?: TConfig;\n  outputs: TOutputs;\n  dynamicOutputType?: StructorType; // Allow dynamic keys with this type\n  isRealtime?: (config: Structor) => boolean;\n\n  /**\n   * Optional factory for creating the initial state of the node.\n   * If provided, the execute function will receive the state as the 4th argument.\n   */\n  createState?: (\n    config: InferRecord<{ kind: 'record', fields: TConfig, untagged: [] }>,\n    context: ExecutionContext\n  ) => TState;\n\n  /**\n   * If true, inputs are automatically broadcasted to match the input definition.\n   * Can also be a record to override specific input broadcast settings.\n   */\n  autoBroadcast?: boolean | Record<string, Partial<TypedBroadcastChannel>>;\n  reshape?: 'none' | 'vector';\n  onMessage?: (state: TState, message: any) => void;\n\n  computeBackwardPorts?: (\n    outputRequirements: RecordType,\n    config: Structor,\n    context: AnalysisContext,\n  ) => {\n    inputRequirements: RecordType;\n    backwardMetadata?: any;\n  };\n\n  computeForwardPorts?: (\n    inputTypes: RecordType,\n    config: Structor,\n    context: AnalysisContext,\n    backwardMetadata?: any,\n  ) => { inputs: RecordType; outputs: RecordType; forwardMetadata?: any };\n\n  compileConfig?: (uiConfig: any, metadata?: any) => Structor;\n\n  shouldRecompileOnConfigChange?: (\n    newConfig: InferRecord<{ kind: 'record', fields: TConfig, untagged: [] }>,\n    oldConfig: InferRecord<{ kind: 'record', fields: TConfig, untagged: [] }>\n  ) => boolean;\n\n  ui?: any;\n\n  execute: (\n    inputs: InferRecord<{ kind: 'record', fields: TInputs, untagged: [] }>,\n    config: InferRecord<{ kind: 'record', fields: TConfig, untagged: [] }>,\n    context: ExecutionContext,\n    state: TState\n  ) => InferRecord<{ kind: 'record', fields: TOutputs, untagged: [] }> | { outputs: InferRecord<{ kind: 'record', fields: TOutputs, untagged: [] }>; ui?: any };\n\n  getDisplayLabel?: (config: InferRecord<{ kind: 'record', fields: TConfig, untagged: [] }>) => string | undefined;\n\n  subgraphExpansionTag?: string;\n  getChildren?: (node: any, allNodes: any) => string[];\n  getRegion?: (config: InferRecord<{ kind: 'record', fields: TConfig, untagged: [] }>) => {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    visibility: RegionVisibility;\n  };\n\n  cycleBreakingPorts?: string[];\n\n  consolidate?: (\n    inputs: InferRecord<{ kind: 'record', fields: TInputs, untagged: [] }>,\n    config: InferRecord<{ kind: 'record', fields: TConfig, untagged: [] }>,\n    context: ExecutionContext,\n    state: TState\n  ) => void;\n}\n\nexport function definePrimitiveNode<\n  TInputs extends NodeInputsDef,\n  TConfig extends NodeConfigDef,\n  TOutputs extends NodeOutputsDef,\n  TState = undefined\n>(\n  options: TypedNodeOptions<TInputs, TConfig, TOutputs, TState>\n): PrimitiveNodeDefinition {\n  const configType: RecordType = defineRecordType({\n    kind: 'record',\n    fields: (options.config || {}) as any\n  });\n\n  const outputType: RecordType = defineRecordType({\n    kind: 'record',\n    fields: options.outputs as any\n  });\n\n  return {\n    id: options.id,\n    kind: 'primitive',\n    metadata: options.metadata,\n    inputs: options.inputs, // Expose inputs for reflection\n    outputs: options.outputs, // Expose outputs for reflection\n    configType,\n    isRealtime: options.isRealtime,\n    onMessage: options.onMessage,\n    getDisplayLabel: options.getDisplayLabel as any, // Cast to generic Structor type\n    subgraphExpansionTag: options.subgraphExpansionTag,\n    getChildren: options.getChildren,\n    getRegion: options.getRegion as any,\n    cycleBreakingPorts: options.cycleBreakingPorts,\n    consolidate: options.consolidate ? (rawInput, rawConfig, context, state) => {\n      // Unwrap config (reuse same logic as execute?)\n      // We assume config is already unwrapped/same ref?\n      // Actually execute unwraps it. We should probably unwrap here too.\n      // But for performance, maybe we can refactor unwrapping.\n      // For now, duplicate unwrapping logic roughly.\n\n      const processedConfig = fromStructor(rawConfig, configType) as InferRecord<{ kind: 'record', fields: TConfig, untagged: [] }>;\n\n      // Unwrap inputs\n      // Note: Consolidate inputs might only contain the \"late\" inputs.\n      // We'll use the same input processing logic as execute if possible.\n      // Or simplified: Just unwrap what we have.\n\n      const inputs: any = {};\n      const rawFields = rawInput.fields || {};\n      for (const [key, type] of Object.entries(options.inputs || {})) {\n        if (rawFields[key] !== undefined) {\n          inputs[key] = fromStructor(rawFields[key], type);\n        }\n      }\n\n      options.consolidate!(inputs, processedConfig as any, context, state);\n    } : undefined,\n    computeBackwardPorts: options.computeBackwardPorts,\n    computeForwardPorts: (i, c, ctx, meta) => {\n      if (options.computeForwardPorts) {\n        return options.computeForwardPorts(i, c, ctx, meta);\n      }\n      const inputFields: RecordType = defineRecordType({\n        kind: 'record',\n        fields: (options.inputs || {}) as any\n      });\n      return { inputs: inputFields, outputs: outputType }; // Fallback using static inputs\n    },\n    shouldRecompileOnConfigChange: (newConfig, oldConfig) => {\n      if (options.shouldRecompileOnConfigChange) {\n        // Pass raw config through. Cast to 'any' to satisfy typed interface which expects unwrapped config.\n        // In practice, primitives often handle raw config safely or the unwrap logic matches.\n        return options.shouldRecompileOnConfigChange(newConfig as any, oldConfig as any);\n      }\n      return false;\n    },\n    compileConfig: options.compileConfig as any, // Pass through compileConfig\n    ui: options.ui,\n    createState: options.createState as any,\n    execute: (rawInput, rawConfig, context) => {\n      // Unwrap config\n      const processedConfig = fromStructor(rawConfig, configType) as InferRecord<{ kind: 'record', fields: TConfig, untagged: [] }>;\n\n      // Handle State\n      let state: TState = undefined as any;\n      if (options.createState) {\n        const key = context.nodeId || `${options.id}-${JSON.stringify(rawConfig)}`;\n        if (!context.nodeState.has(key)) {\n          context.nodeState.set(key, options.createState(processedConfig as any, context));\n        }\n        state = context.nodeState.get(key);\n      }\n\n      let processedInput: any = rawInput;\n\n      if (options.autoBroadcast && options.inputs) {\n\n        const broadcastConfig: BroadcastConfig = {\n          outputs: {},\n          reshape: options.reshape ?? 'none'\n        };\n\n        const overrides = typeof options.autoBroadcast === 'object' ? options.autoBroadcast : {};\n\n        // Dynamic AutoBroadcast Override from Config\n        // Check if config has an 'autoBroadcast' field that overrides static options\n        if (processedConfig && typeof processedConfig === 'object' && 'autoBroadcast' in processedConfig) {\n          const dynamicOverride = (processedConfig as any).autoBroadcast;\n          if (dynamicOverride && typeof dynamicOverride === 'object') {\n            Object.assign(overrides, dynamicOverride);\n            // If explicit override exists, we should probably ensure keys are covered?\n            // But the loop below iterates over options.inputs.\n            // If dynamicOverride adds keys not in inputs, they will be ignored by loop below, which is correct.\n          }\n        }\n\n        for (const [key, type] of Object.entries(options.inputs)) {\n          const isArray = type.kind === 'array';\n          const override = overrides[key];\n          const defaultCombine = isArray ? 'collect' : { reduce: 'first' } as const;\n          const combine = (override && 'combine' in override) ? override.combine : defaultCombine;\n\n          broadcastConfig.outputs[key] = {\n            fromFields: [key],\n            combine: combine ?? undefined\n          };\n        }\n        // console.error('Broadcast call:', { nodeId: options.id, configKeys: Object.keys(broadcastConfig.outputs) });\n        const broadcasted = context.broadcast(broadcastConfig, rawInput);\n\n        const result = broadcasted.apply((args: any) => {\n\n          // Unwrap inputs\n          const inputs: any = {};\n          for (const [key, type] of Object.entries(options.inputs!)) {\n            const isCollect = broadcastConfig.outputs[key]?.combine === 'collect';\n            if (isCollect && Array.isArray(args[key])) {\n              const mapped = args[key].map((v: any) => {\n                // If v is a collected list of inputs (e.g. Reference<Sequence>[]), we needs to map each one.\n                if (Array.isArray(v) && v.length > 0 && Array.isArray(v[0]) && type.kind === 'array' && type.element.kind === 'record') {\n                  return v.map(item => fromStructor(item, type.element));\n                }\n\n                // Logic: If type is Nested (Array<Array>), we expect v to be Array.\n                // If v is flat Array (Stream), and type is Nested, use type.element (Unwrap as Stream).\n                // If type is Not Nested (Array), and v is Array (Stream), use type (Unwrap as Stream).\n                const typeIsNested = (type as any).element?.kind === 'array';\n                const valueIsNested = Array.isArray(v) && v.length > 0 && Array.isArray(v[0]);\n\n                if (typeIsNested && !valueIsNested) {\n                  return fromStructor(v, (type as any).element);\n                }\n                return fromStructor(v, type);\n              });\n\n              // Conditional flatten:\n              // If we collected a single stream [Stream], flatten to Stream if type expects Stream (not Nested).\n              // If type expects List of Streams (Nested), keep [Stream] (or [ [Seq1] ]).\n              // We check type.element.kind to see if the NODE TYPE expects a nested array.\n              const typeIsNested = (type as any).element?.kind === 'array';\n              if (mapped.length === 1 && Array.isArray(mapped[0]) && !typeIsNested) {\n                inputs[key] = mapped[0];\n              } else {\n                inputs[key] = mapped;\n              }\n            } else {\n              const val = args[key];\n              // Heuristic: if type anticipates nesting (Wrapped Array) but value is flat (Scalar/Stream), unwrap using inner element.\n              const typeIsNested = (type as any).element?.kind === 'array';\n              const valueIsNested = Array.isArray(val) && val.length > 0 && Array.isArray(val[0]);\n\n              let unwrap;\n              if (type.kind === 'array' && typeIsNested && !valueIsNested) {\n                unwrap = fromStructor(val, type.element);\n              } else {\n                unwrap = fromStructor(val, type);\n              }\n              inputs[key] = unwrap !== undefined ? unwrap : (type as any).defaultValue;\n            }\n          }\n          // console.error('Execute Inputs:', JSON.stringify(inputs));\n\n\n          // Execute\n\n\n          const execResult = options.execute(inputs, processedConfig as any, context, state);\n          // console.error('Execute Result:', JSON.stringify(execResult));\n          return execResult;\n        });\n\n        // Transpose result if it's an array (vector broadcast)\n        if (Array.isArray(result)) {\n          if (result.length > 0) {\n            const fields: Record<string, Structor[]> = {};\n            const first = result[0];\n            for (const key of Object.keys(first)) {\n              fields[key] = [];\n            }\n\n            for (const res of result) {\n              for (const [key, val] of Object.entries(res)) {\n                if (fields[key]) fields[key].push(val as Structor);\n              }\n            }\n\n            // Wrap outputs\n            const wrappedFields: Record<string, Structor> = {};\n            for (const [key, val] of Object.entries(fields)) {\n              const type = options.outputs[key] || options.dynamicOutputType;\n              if (type) {\n                wrappedFields[key] = toStructor(val, { kind: 'array', element: type, size: result.length });\n              }\n            }\n            return { fields: wrappedFields };\n          } else {\n            return { fields: {} };\n          }\n        } else {\n          // Scalar result\n          let rawOutputs = result as any;\n          let uiOutputs: any = undefined;\n\n          // Check for { outputs, ui } pattern\n          if (rawOutputs && typeof rawOutputs === 'object') {\n            // Logic matches the non-broadcast handler below\n            if ('outputs' in rawOutputs && ('ui' in rawOutputs || Object.keys(rawOutputs).length === 2)) {\n              if (!('outputs' in options.outputs)) {\n                uiOutputs = rawOutputs.ui;\n                rawOutputs = rawOutputs.outputs;\n              }\n            }\n          }\n\n          const keys = new Set([...Object.keys(options.outputs), ...Object.keys(rawOutputs)]);\n          const wrappedFields: Record<string, Structor> = {};\n          for (const key of keys) {\n            const type = options.outputs[key] || options.dynamicOutputType;\n            if (type && rawOutputs[key] !== undefined) {\n              wrappedFields[key] = toStructor(rawOutputs[key], type);\n            }\n          }\n\n          const structorResult = { fields: wrappedFields };\n          if (uiOutputs !== undefined) {\n            return { outputs: structorResult, ui: uiOutputs };\n          }\n          return structorResult;\n        }\n      } else if (options.inputs && Object.keys(options.inputs).length > 0) {\n        // Even if not broadcasting, we might want to unwrap the raw inputs if they match the schema\n        const inputs: any = {};\n        for (const [key, type] of Object.entries(options.inputs)) {\n          if (rawInput.fields && rawInput.fields[key] !== undefined) {\n            inputs[key] = fromStructor(rawInput.fields[key], type);\n          } else if ((type as any).defaultValue !== undefined) {\n            inputs[key] = (type as any).defaultValue;\n          }\n        }\n        processedInput = inputs;\n      }\n\n      const result = options.execute(\n        processedInput,\n        processedConfig as any,\n        context,\n        state\n      );\n\n      // Handle ExecuteResult (with potential UI outputs)\n      let rawOutputs: any = result;\n      let uiOutputs: any = undefined;\n\n      if (rawOutputs && typeof rawOutputs === 'object') {\n        if ('outputs' in rawOutputs && ('ui' in rawOutputs || Object.keys(rawOutputs).length === 2)) {\n          // It's likely an ExecuteResult\n          // (We check strictly for 'outputs' property)\n          // But wait, if the user returns { outputName: val }, 'outputs' is not a reserved output name usually.\n          // However, `options.outputs` defines valid output names.\n          // If 'outputs' is NOT in options.outputs, then we can assume it's the wrapper object.\n          if (!('outputs' in options.outputs)) {\n            uiOutputs = rawOutputs.ui;\n            rawOutputs = rawOutputs.outputs;\n          }\n        }\n      }\n\n      // Wrap output\n      const wrappedFields: Record<string, Structor> = {};\n      const anyResult = rawOutputs as any;\n      if (anyResult) {\n        // combine static outputs and dynamic outputs\n        const keys = new Set([...Object.keys(options.outputs), ...Object.keys(anyResult)]);\n\n        for (const key of keys) {\n          const type = options.outputs[key] || options.dynamicOutputType;\n          // Only process if we have a type and a value\n          if (type && anyResult[key] !== undefined) {\n            wrappedFields[key] = toStructor(anyResult[key], type);\n          }\n        }\n      }\n\n      const structorResult: StructorRecord = {\n        fields: wrappedFields\n      };\n\n      if (uiOutputs !== undefined) {\n        return {\n          outputs: structorResult,\n          ui: uiOutputs\n        };\n      } else {\n        return structorResult;\n      }\n    }\n  };\n}\n\n\n\nexport interface TypedBroadcastChannel {\n  source?: string | string[]; // Default to channel name if omitted\n  type?: StructorType; // Used for inference\n  combine?: 'collect' | { reduce: 'min' | 'max' | 'add' | 'first' | 'flatten' } | null;\n}\n\nexport type TypedBroadcastSchema = Record<string, TypedBroadcastChannel>;\n\nexport type InferBroadcastResult<TSchema extends TypedBroadcastSchema> = {\n  [K in keyof TSchema]: TSchema[K]['combine'] extends 'collect'\n  ? Array<InferStructorType<NonNullable<TSchema[K]['type']>>>\n  : InferStructorType<NonNullable<TSchema[K]['type']>>\n};\n\nexport function typedBroadcast<TSchema extends TypedBroadcastSchema>(\n  context: ExecutionContext,\n  schema: TSchema,\n  inputs: StructorRecord\n): InferBroadcastResult<TSchema> {\n  const config: BroadcastConfig = {\n    outputs: {},\n    reshape: 'none'\n  };\n\n  for (const [key, def] of Object.entries(schema)) {\n    config.outputs[key] = {\n      fromFields: def.source ? (Array.isArray(def.source) ? def.source : [def.source]) : [key],\n      combine: def.combine ?? { reduce: 'first' }\n    };\n  }\n\n  const broadcasted = context.broadcast(config, inputs);\n\n  // Use apply to get the data structure (AoS)\n  const result = broadcasted.apply((args: any) => args);\n\n  const processedResult: any = {};\n\n  // Transpose if vector\n  if (Array.isArray(result)) {\n    // Initialize arrays\n    for (const key of Object.keys(schema)) {\n      processedResult[key] = [];\n    }\n    for (const item of result) {\n      for (const key of Object.keys(schema)) {\n        processedResult[key].push(item[key]);\n      }\n    }\n  } else {\n    // Scalar\n    for (const key of Object.keys(schema)) {\n      processedResult[key] = result[key];\n    }\n  }\n\n  // Type conversion\n  for (const [key, def] of Object.entries(schema)) {\n    if (def.type) {\n      if (def.combine === 'collect') {\n        // If collect, the value is already an array (from broadcast logic)\n        // But if we transposed a vector of collects, we have array of arrays?\n        // Wait, if result is array (vector), then processedResult[key] is array of values.\n        // If combine is collect, values are arrays.\n        // So processedResult[key] is array of arrays.\n\n        // typedBroadcast expects `Array<InferStructorType>`.\n        // If it's a vector, it expects `Array<Array<...>>`?\n        // The type definition says `Array<InferStructorType>`.\n\n        // If typedBroadcast is used for manual handling, maybe it doesn't expect vectors?\n        // Or maybe it expects the \"column\".\n\n        // Let's assume processedResult[key] IS the column.\n        const val = processedResult[key];\n        if (Array.isArray(val)) {\n          processedResult[key] = val.map((v: any) => fromStructor(v, def.type!));\n        } else {\n          processedResult[key] = fromStructor(val, def.type!);\n        }\n      } else {\n        const val = processedResult[key];\n        if (Array.isArray(val)) {\n          processedResult[key] = val.map((v: any) => fromStructor(v, def.type!));\n        } else {\n          processedResult[key] = fromStructor(val, def.type!);\n        }\n      }\n    }\n  }\n\n  return processedResult;\n}\nexport function defineMathNode(\n  id: string,\n  metadata: NodeMetadata,\n  op: (a: number, b: number) => number,\n  arity: 'unary' | 'binary' = 'binary'\n): PrimitiveNodeDefinition {\n  const inputs: NodeInputsDef = arity === 'binary'\n    ? { a: NumberType, b: NumberType }\n    : { a: NumberType };\n\n  return definePrimitiveNode({\n    id,\n    metadata,\n    inputs,\n    outputs: { result: NumberType },\n    autoBroadcast: true,\n    reshape: 'vector',\n    execute: (inputs, config, context) => {\n      if (arity === 'binary') {\n        const { a, b } = inputs as { a: number, b: number };\n        return { result: op(a, b) };\n      } else {\n        const { a } = inputs as { a: number };\n        return { result: op(a, 0) };\n      }\n    }\n  });\n}\n\n// --- Type Unification Helpers ---\n\nexport function unifyTypes(types: StructorType[]): StructorType {\n  if (types.length === 0) return AnyType;\n\n  const first = types[0];\n  /* Safe check for exact equality */\n  if (types.every(t =>\n    t.kind === first.kind &&\n    (t.kind === 'atomic' ? t.type === (first as AtomicType).type : true)\n    // TODO: deep compare for compound types if needed, for now exact ref or simple atomic match\n  )) {\n    return first;\n  }\n\n  const hasString = types.some(t => t.kind === 'atomic' && t.type === 'string');\n  if (hasString) return AnyType;\n\n  const hasNumber = types.some(t => t.kind === 'atomic' && t.type === 'number');\n  const hasBoolean = types.some(t => t.kind === 'atomic' && t.type === 'boolean');\n\n  if (hasNumber || hasBoolean) return NumberType;\n\n  return AnyType;\n}\n","import { NodeDefinition, Structor, StructorType } from './structor';\nimport type { GraphState, GridNode } from '../builder/state';\n\nexport interface PortHint {\n  name: string; // Corresponds to tag. Empty string for default/untagged.\n  type: StructorType;\n  description?: string;\n  // For \"virtual inputs\"\n  defaultValue?: any;\n  range?: [number, number];\n  step?: number;\n  redirect?: 'untagged';\n  suppressInputEditor?: boolean;\n  alwaysShowInputEditor?: boolean;\n  suppressLabel?: boolean;\n  allowMultiConnection?: boolean; // Forces collection of all inputs into an array, even if types match.\n}\n\nexport type InspectorChangeHandler = (config: Partial<GridNode['config']>) => void;\nexport interface GraphNodeRenderHandlers {\n  handleVirtualInputChange: (e: Event, portName: string) => void;\n}\n\n// Enum for Region Visibility\nexport enum RegionVisibility {\n  Auto = 'auto',\n  Show = 'show',\n  Hide = 'hide',\n}\n\nexport interface NodeType {\n  id: string;\n  version: string;\n  displayName: string;\n  aliases?: string[];\n  definition: NodeDefinition;\n  inputs?: PortHint[];\n  outputs?: PortHint[];\n\n  /**\n   * A function that compiles the UI-friendly `GridNode.config` object\n   * into the `Structor`-formatted `defaultConfig` for a `NodeInstance`.\n   * If not provided, the config is assumed to be undefined.\n   */\n  compileConfig?: (uiConfig: any, metadata?: any) => Structor;\n\n  /**\n   * A custom Lit-element renderer for the node's body.\n   * If not provided, a default renderer is used.\n   */\n  renderBody?: (node: GridNode, handlers: GraphNodeRenderHandlers) => unknown;\n\n  /**\n   * Returns the exact pixel height required for the custom body.\n   * If provided, this is used for layout calculations instead of heuristics.\n   */\n  getBodyHeight?: (node: GridNode) => number;\n\n  /**\n   * A custom Lit-element renderer for the node's inspector content.\n   */\n  renderInspector?: (node: GridNode, onchange: InspectorChangeHandler) => unknown;\n\n  /**\n   * Returns the exact pixel height required for the custom inspector editor.\n   */\n  getInspectorHeight?: (node: GridNode) => number;\n\n  /**\n   * A custom Lit-element renderer for a specific input port.\n   * Renders in place of the default virtual input when the port is disconnected.\n   */\n  renderInputEditor?: (node: GridNode, portName: string, handlers: GraphNodeRenderHandlers) => unknown;\n\n  /**\n   * Returns the exact pixel height required for the custom input editor.\n   */\n  getInputEditorHeight?: (node: GridNode, portName: string) => number;\n\n  ui?: {\n    body?: () => Promise<(node: GridNode, handlers: GraphNodeRenderHandlers) => unknown>;\n    getBodyHeight?: () => Promise<(node: GridNode) => number>;\n    inspector?: (() => Promise<(node: GridNode, onchange: InspectorChangeHandler) => unknown>) | { fields: any[] };\n    inputEditor?: () => Promise<(node: GridNode, portName: string, handlers: GraphNodeRenderHandlers) => unknown>;\n    getInputEditorHeight?: () => Promise<(node: GridNode, portName: string) => number>;\n  };\n\n  /**\n   * Optional callback to determine the dynamic display label of a node.\n   */\n  getDisplayLabel?: (uiConfig: any) => string | undefined;\n\n  /**\n   * Whether to capture inputs for this node type in the executor.\n   */\n  inspectInputs?: boolean;\n\n  /**\n   * Whether structural changes in the node's config (affecting ports) require a full graph compilation.\n   * TODO: The signature should be ((newConfig: any, oldConfig?: any) => boolean).\n   */\n  shouldRecompileOnConfigChange?: ((uiConfig: any) => boolean) | ((newConfig: any, oldConfig: any) => boolean);\n\n  /**\n   * Optional method to identify child nodes owned by this node (e.g. for spatial groups).\n   */\n  getChildren?: (node: GridNode, allNodes: Record<string, GridNode>) => string[];\n\n  /**\n   * Optional method to define the spatial region associated with this node.\n   */\n  getRegion?: (uiConfig: any) => {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    visibility: RegionVisibility;\n  };\n}\n\nexport class NodeRepository {\n  private nodes = new Map<string, NodeType>();\n\n  register(node: NodeType): void {\n    this.nodes.set(node.id, node);\n  }\n\n  get(id: string): NodeDefinition | undefined {\n    return this.nodes.get(id)?.definition;\n  }\n\n  getNodeType(id: string): NodeType | undefined {\n    return this.nodes.get(id);\n  }\n\n  getAllNodeTypes(): IterableIterator<NodeType> {\n    return this.nodes.values();\n  }\n}\n\nexport const defaultNodeRepository = new NodeRepository();","import {\n  definePrimitiveNode,\n  TypedNodeOptions,\n  NodeInputsDef,\n  NodeConfigDef,\n  NodeOutputsDef,\n  InferRecord\n} from './type-helpers';\nimport {\n  PrimitiveNodeDefinition,\n  StructorType,\n  ExecutionContext,\n  RecordType,\n  AnalysisContext,\n  TypedBroadcastChannel\n} from './structor';\nimport { defaultNodeRepository, PortHint, NodeType, RegionVisibility } from './repository';\nimport { UIConfigStructorType } from './std-types';\nimport type { GridNode } from '../builder/state';\n\n// --- Enhanced Node Definition ---\n\nexport type InspectorFieldDef =\n  | { type: 'string'; label: string; path: string; placeholder?: string; default?: string; visible?: (config: any) => boolean }\n  | { type: 'number'; label: string; path: string; min?: number; max?: number; step?: number; default?: number; visible?: (config: any) => boolean }\n  | { type: 'slider'; label: string; path: string; min: number; max: number; step?: number; default?: number; visible?: (config: any) => boolean }\n  | { type: 'boolean'; label: string; path: string; default?: boolean; visible?: (config: any) => boolean }\n  | { type: 'select'; label: string; path: string; options: { label: string; value: any }[]; default?: any; visible?: (config: any) => boolean }\n  | { type: 'structor-type'; label: string; path: string; default?: UIConfigStructorType; visible?: (config: any) => boolean }\n  | { type: 'tab-bar'; label: string; path: string; options: { label: string; value: any }[]; default?: any; visible?: (config: any) => boolean }\n  | { type: 'button'; label: string; path: string; text?: string; visible?: (config: any) => boolean };\n\nexport interface GenericInspector {\n  fields: InspectorFieldDef[];\n}\n\nexport interface NodeUI {\n  inspector?: (() => Promise<any>) | GenericInspector;\n  body?: () => Promise<any>;\n  getBodyHeight?: () => Promise<any>;\n  inputEditor?: () => Promise<any>;\n  getInputEditorHeight?: () => Promise<any>;\n}\n\nexport interface ExtendedInputDef {\n  type: StructorType;\n  description?: string;\n  defaultValue?: any;\n  range?: [number, number];\n  step?: number;\n  suppressInputEditor?: boolean;\n  alwaysShowInputEditor?: boolean;\n  suppressLabel?: boolean;\n  redirect?: string;\n  allowMultiConnection?: boolean;\n}\n\nexport type ExtendedNodeInputsDef = Record<string, StructorType | ExtendedInputDef>;\n\nexport interface ExtendedOutputDef {\n  type: StructorType;\n  description?: string;\n  suppressLabel?: boolean;\n  suppressInputEditor?: boolean;\n}\n\nexport type ExtendedNodeOutputsDef = Record<string, StructorType | ExtendedOutputDef>;\n\n\nexport type AutoBroadcastDef = boolean | Record<string, Partial<TypedBroadcastChannel>>;\n\nexport type SimplifyInputs<\n  T extends ExtendedNodeInputsDef,\n  TBroadcast extends AutoBroadcastDef | undefined = undefined\n> = {\n  [K in keyof T]: T[K] extends ExtendedInputDef\n  ? (\n    // Check for flatten in broadcast config\n    (TBroadcast extends Record<string, any>\n      ? (K extends keyof TBroadcast\n        ? (TBroadcast[K]['combine'] extends { reduce: 'flatten' } ? true : false)\n        : false)\n      : false\n    ) extends true\n    ? T[K]['type'] // Flattened -> Base type\n    : (\n      T[K]['allowMultiConnection'] extends true\n      ? { kind: 'array', size: 'dynamic', element: T[K]['type'] }\n      : T[K]['type']\n    )\n  )\n  : T[K]\n} & Record<string, StructorType>;\n\nexport type SimplifyOutputs<T extends ExtendedNodeOutputsDef> = {\n  [K in keyof T]: T[K] extends ExtendedOutputDef ? T[K]['type'] : T[K]\n} & Record<string, StructorType>;\n\nexport interface EnhancedNodeOptions<\n  TInputs extends ExtendedNodeInputsDef,\n  TUIConfig extends Record<string, any> | any, // Allow strict structural typing\n  TCompiledConfig extends NodeConfigDef,\n  TOutputs extends ExtendedNodeOutputsDef,\n  TState = undefined,\n  TAutoBroadcast extends AutoBroadcastDef | undefined = undefined\n> extends Omit<TypedNodeOptions<any, TCompiledConfig, any, TState>, 'inputs' | 'outputs' | 'execute' | 'computeForwardPorts' | 'computeBackwardPorts' | 'config' | 'shouldRecompileOnConfigChange' | 'getDisplayLabel' | 'autoBroadcast' | 'getRegion'> { // Exclude config to redefine it\n  inputs?: TInputs;\n  autoBroadcast?: TAutoBroadcast; // Explicit override\n  outputs: TOutputs; // Explicit override\n  dynamicOutputType?: StructorType;\n  ui?: NodeUI;\n  version?: string;\n  displayName?: string;\n  aliases?: string[];\n  compileConfig?: (uiConfig: TUIConfig) => any; // Returns TCompiledConfig (raw values struct) or just any\n  getDisplayLabel?: (uiConfig: TUIConfig) => string | undefined;\n  subgraphExpansionTag?: string; // This ends up on the definitions\n  getChildren?: (node: any, allNodes: any) => string[]; // Helper to attach to NodeType\n\n  getRegion?: (uiConfig: TUIConfig) => {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    visibility: RegionVisibility;\n  };\n\n  /**\n   * Optional async method to load dependencies required for compilation (e.g. TypeScript).\n   * Called by the Compiler Worker before compilation.\n   */\n  loadCompileDeps?: () => Promise<void>;\n\n  inspectInputs?: boolean;\n  onMessage?: (state: TState, message: any) => void;\n  shouldRecompileOnConfigChange?: (uiConfig: TUIConfig) => boolean;\n\n  // Re-declare with explicit names\n  computeForwardPorts?: (\n    inputTypes: RecordType,\n    uiConfig: TUIConfig, // Use UI Config here\n    context: AnalysisContext,\n    backwardMetadata?: any,\n  ) => { inputs: RecordType; outputs: RecordType };\n\n  computeBackwardPorts?: (\n    outputRequirements: RecordType,\n    uiConfig: TUIConfig,\n    context: AnalysisContext,\n  ) => {\n    inputRequirements: RecordType;\n    backwardMetadata?: any;\n  };\n\n  // NOTE: This config property is used to define the schema of the COMPILED config for runtime validation/marshaling\n  config?: TCompiledConfig;\n\n  execute: (\n    inputs: InferRecord<{ kind: 'record', fields: SimplifyInputs<TInputs, TAutoBroadcast> }>,\n    config: InferRecord<{ kind: 'record', fields: TCompiledConfig }>, // This is the compiled runtime config\n    context: ExecutionContext,\n    state: TState\n  ) => InferRecord<{ kind: 'record', fields: SimplifyOutputs<TOutputs> }> | { outputs: InferRecord<{ kind: 'record', fields: SimplifyOutputs<TOutputs> }>; ui?: any };\n\n\n}\n\nexport interface EnhancedNodeDefinition extends PrimitiveNodeDefinition {\n  ui?: NodeUI;\n  version: string;\n  displayName: string;\n  aliases?: string[];\n  compileConfig?: (uiConfig: any) => any;\n  loadCompileDeps?: () => Promise<void>;\n  getDisplayLabel?: (uiConfig: any) => string | undefined;\n  subgraphExpansionTag?: string; // Inherited from PrimitiveNodeDefinition but explicit here for clarity if needed\n  extendedInputs?: ExtendedNodeInputsDef;\n  extendedOutputs?: ExtendedNodeOutputsDef;\n\n  inspectInputs?: boolean;\n  shouldRecompileOnConfigChange?: ((uiConfig: any) => boolean) | ((newConfig: any, oldConfig: any) => boolean);\n  // onMessage is inherited from PrimitiveNodeDefinition\n  getChildren?: (node: GridNode, allNodes: Record<string, GridNode>) => string[];\n  getRegion?: (config: any) => { x: number; y: number; width: number; height: number };\n}\n\nexport function defineNode<\n  const TInputs extends ExtendedNodeInputsDef,\n  TUIConfig extends Record<string, any> | any = any,\n  TCompiledConfig extends NodeConfigDef = any,\n  TOutputs extends ExtendedNodeOutputsDef = ExtendedNodeOutputsDef,\n  TState = undefined,\n  const TAutoBroadcast extends AutoBroadcastDef | undefined = undefined\n>(\n  options: EnhancedNodeOptions<TInputs, TUIConfig, TCompiledConfig, TOutputs, TState, TAutoBroadcast>\n): EnhancedNodeDefinition {\n  // 1. Strip down inputs to NodeInputsDef (just types) for definePrimitiveNode\n  const simpleInputs: NodeInputsDef = {};\n  for (const [key, val] of Object.entries(options.inputs || {})) {\n    if ('kind' in (val as any)) {\n      // It's StructorType\n      simpleInputs[key] = val as StructorType;\n    } else if ('type' in (val as any)) {\n      // It's ExtendedInputDef\n      const ext = val as ExtendedInputDef;\n      const type = ext.type;\n      const inputType = ext.allowMultiConnection\n        ? { kind: 'array', size: 'dynamic', element: type } as StructorType\n        : type;\n\n      simpleInputs[key] = {\n        ...inputType,\n        redirect: ext.redirect,\n        defaultValue: 'defaultValue' in ext ? ext.defaultValue : (type as any).defaultValue\n      };\n    }\n  }\n\n  // 2. Strip down outputs to NodeOutputsDef\n  const simpleOutputs: NodeOutputsDef = {};\n  for (const [key, val] of Object.entries(options.outputs || {})) {\n    if ('kind' in (val as any)) {\n      simpleOutputs[key] = val as StructorType;\n    } else if ('type' in (val as any)) {\n      simpleOutputs[key] = (val as ExtendedOutputDef).type;\n    }\n  }\n\n  const primitiveDef = definePrimitiveNode({\n    ...options,\n    autoBroadcast: options.autoBroadcast,\n    inputs: simpleInputs,\n    outputs: simpleOutputs, // Use stripped outputs\n    compileConfig: (uiConfig: any, metadata?: any) => {\n      // Config here is coming from the Graph/Builder, so it is UIConfig\n      if (options.compileConfig) {\n        return (options.compileConfig as any)(uiConfig); // Note: We might need to pass metadata here if API allows\n      }\n      return uiConfig;\n    },\n    // We need to properly check signature of compileConfig in definePrimitiveNode\n    // It's manually constructed below, but definePrimitiveNode uses options...\n    // WAIT: definePrimitiveNode takes TypedNodeOptions.\n    // The previous implementation was:\n    /*\n    compileConfig: (uiConfig: any) => {\n      // ...\n      if (options.compileConfig) {\n         return options.compileConfig(uiConfig);\n      }\n      return { ... }\n    }\n    */\n    // Let's restore the previous logic but ensure loadCompileDeps is passed if definePrimitiveNode supported it (it doesn't yet).\n    // We'll add it to the return object.\n\n    computeForwardPorts: (inputTypes: any, config: any, context: any, backwardMetadata?: any) => {\n      // Config here is coming from the Graph/Builder, so it is UIConfig\n      if (options.computeForwardPorts) {\n        return options.computeForwardPorts(inputTypes, config, context, backwardMetadata);\n      }\n      return {\n        // Return static definition for inputs and outputs.\n        inputs: { kind: 'record', fields: simpleInputs },\n        outputs: { kind: 'record', fields: simpleOutputs }\n      };\n    },\n    // Same for Backward\n    computeBackwardPorts: (outputRequirements: any, config: any, context: any) => {\n      if (options.computeBackwardPorts) {\n        return options.computeBackwardPorts(outputRequirements, config, context);\n      }\n      return { inputRequirements: { kind: 'record', fields: {} } };\n    },\n    onMessage: options.onMessage,\n    config: options.config // Pass the Compiled config schema\n  } as unknown as TypedNodeOptions<any, TCompiledConfig, any, TState>);\n  // Cast to unknown first to avoid incompatibility issues with Simplify types vs constraints\n\n  return {\n    ...primitiveDef,\n    ui: options.ui,\n    version: options.version || '1.0.0',\n    displayName: options.displayName || options.id,\n    aliases: options.aliases,\n    compileConfig: options.compileConfig,\n    loadCompileDeps: options.loadCompileDeps, // Pass it through\n    getDisplayLabel: options.getDisplayLabel,\n    subgraphExpansionTag: options.subgraphExpansionTag,\n    extendedInputs: options.inputs,\n    extendedOutputs: options.outputs,\n\n    inspectInputs: options.inspectInputs,\n    shouldRecompileOnConfigChange: options.shouldRecompileOnConfigChange,\n    getChildren: options.getChildren,\n    getRegion: options.getRegion\n  };\n}\n\n// --- Registration Helper ---\n\nexport function registerNode(def: PrimitiveNodeDefinition & Partial<EnhancedNodeDefinition>) {\n  const inputsSource = def.extendedInputs || (def.inputs as any) || {};\n  const inputs: PortHint[] = Object.entries(inputsSource).map(([name, val]: [string, any]) => {\n    const isExtended = 'type' in val && typeof (val as any).type === 'object' && 'kind' in (val as any).type;\n\n\n    const type = isExtended ? val.type : val;\n    return {\n      name,\n      type,\n      description: isExtended ? val.description : undefined,\n      defaultValue: isExtended ? val.defaultValue : undefined,\n      range: isExtended ? val.range : undefined,\n      step: isExtended ? val.step : undefined,\n      suppressInputEditor: isExtended ? val.suppressInputEditor : (type.kind === 'atomic' && type.type === 'any' ? true : undefined),\n      alwaysShowInputEditor: isExtended ? val.alwaysShowInputEditor : undefined,\n      suppressLabel: isExtended ? val.suppressLabel : undefined,\n      redirect: isExtended ? val.redirect : undefined,\n      allowMultiConnection: isExtended ? val.allowMultiConnection : undefined,\n    };\n  });\n\n  const outputsSource = def.extendedOutputs || (def.outputs as any) || {};\n  const outputs: PortHint[] = Object.entries(outputsSource).map(([name, val]: [string, any]) => {\n    const isExtended = 'type' in val && typeof (val as any).type === 'object' && 'kind' in (val as any).type;\n    const type = isExtended ? val.type : val;\n    return {\n      name,\n      type,\n      description: isExtended ? val.description : undefined,\n      suppressLabel: isExtended ? val.suppressLabel : undefined,\n    };\n  });\n\n  const nodeType: NodeType = {\n    id: def.id,\n    version: def.version || '1.0.0',\n    displayName: def.displayName || def.id,\n    aliases: def.aliases,\n    definition: def,\n    inputs,\n    outputs,\n    compileConfig: def.compileConfig,\n    getDisplayLabel: def.getDisplayLabel,\n\n    inspectInputs: def.inspectInputs,\n    shouldRecompileOnConfigChange: def.shouldRecompileOnConfigChange,\n    getChildren: def.getChildren,\n    getRegion: def.getRegion as any,\n  };\n\n  // If UI is provided, we need to hook it up.\n  // Since we can't import Lit here, we can attach the loaders to the NodeType\n  // and let the View layer (GraphNode) handle the loading.\n  // We need to extend NodeType interface to support `ui` property.\n  // For now, we cast to any or augment the type.\n  (nodeType as any).ui = def.ui;\n\n  defaultNodeRepository.register(nodeType);\n}\n\nexport function getNodeDisplayName(nodeConfig: any, nodeType: NodeType | undefined): string {\n  const name = nodeConfig.name;\n  const typeId = nodeConfig.typeId;\n\n  if (!nodeType) {\n    // Fallback if node type validation is not available\n    const isDefault = !name || name === '#';\n    if (isDefault) return typeId;\n\n    // Attempt hash replacement with typeId\n    if (name && name.includes('#')) {\n      return name.replace(/#/g, typeId);\n    }\n\n    return name;\n  }\n\n  // If user explicitly clears the name, it might be empty string.\n  // We treat empty string as \"use default dynamic label\".\n  // The special value \"#\" also means \"use default dynamic label\".\n\n  const isDefault = !name || name === '#';\n  const hasHash = name && name.includes('#');\n\n  if (isDefault) {\n    // Attempt dynamic label\n    if (nodeType.getDisplayLabel) {\n      const dynamic = nodeType.getDisplayLabel(nodeConfig);\n      if (dynamic) return dynamic;\n    }\n    // Fallback to static display name\n    return nodeType.displayName;\n  }\n\n  if (hasHash) {\n    // Replace hash with dynamic label\n    const dynamic = nodeType.getDisplayLabel ? nodeType.getDisplayLabel(nodeConfig) : nodeType.displayName;\n    return name.replace(/#/g, dynamic || nodeType.displayName);\n  }\n\n  return name;\n}\n","\n// Based on README.md\n/* ===================================================================\n * 1. Core Static Types (The \"Shape\")\n * =================================================================== */\n\nexport interface AtomicType {\n  readonly kind: 'atomic';\n  readonly type: 'number' | 'string' | 'boolean' | 'any';\n  readonly optional?: boolean;\n  readonly defaultValue?: any;\n  readonly description?: string;\n}\n\nexport interface FunctorType {\n  readonly kind: 'functor';\n  readonly input: StructorType;\n  readonly output: StructorType;\n  readonly optional?: boolean;\n}\n\nexport interface ArrayType {\n  readonly kind: 'array';\n  readonly size: number | 'dynamic'; // 'dynamic' for runtime-sized/ragged arrays\n  readonly element: StructorType;\n  readonly optional?: boolean;\n  readonly hint?: string;\n  readonly description?: string;\n}\n\nexport interface RecordType {\n  readonly kind: 'record';\n  readonly fields: Record<string, StructorType>; // Named/tagged inputs\n  readonly optional?: boolean;\n  readonly hint?: string;\n  readonly untagged?: readonly StructorType[];\n  readonly description?: string;\n}\n\nexport interface GraphType {\n  readonly kind: 'graph';\n  readonly inputs: RecordType;\n  readonly outputs: RecordType;\n  readonly optional?: boolean;\n}\n\nexport type StructorType =\n  | AtomicType\n  | FunctorType\n  | ArrayType\n  | RecordType\n  | GraphType;\n\n/* ===================================================================\n * 2. Core Runtime Types (The \"Data\")\n * =================================================================== */\n\nexport type Functor = (input: Structor) => Structor;\nexport interface StructorArray extends Array<Structor> { }\nexport interface StructorRecord {\n  fields: Record<string, Structor>;\n}\n\nexport type Structor =\n  | number\n  | string\n  | boolean\n  | Functor\n  | StructorArray\n  | StructorRecord;\n\nimport type { NodeRepository } from './repository';\n\n/* ===================================================================\n * 3. Node Definitions\n * =================================================================== */\n\nexport type NodeDefinition = PrimitiveNodeDefinition | GraphDefinition;\n\nexport interface BroadcastResult {\n  apply(lambda: (args: any) => any): any;\n}\n\n// Faking the contexts for now\nexport interface AnalysisContext {\n  broadcast: (config: BroadcastConfig, inputs: RecordType) => any;\n  repository: NodeRepository;\n};\nexport interface ExecutionContext {\n  broadcast: (config: BroadcastConfig, inputs: StructorRecord) => BroadcastResult;\n  repository: NodeRepository;\n  clock: {\n    beat: number;\n    dt: number;\n  };\n  audio?: {\n    context: any;\n  };\n  // Access to the global node state cache\n  // In a real implementation, this would be scoped to the graph instance\n  nodeState: Map<string, any>;\n  nodeId?: string;\n  midi?: {\n    values: Map<string, number>;\n    events?: any[]; // Typed as MidiEvent[] in implementation\n  };\n  resolume?: any; // Injected ResolumeManager\n  requestUiOutputs?: boolean;\n  time?: number; // Absolute time in seconds\n  markSelfDirty?: () => void;\n  executeSubgraph?: (tag: string) => void;\n};\n\n\n\nexport enum NodeCategory {\n  IO = 'IO',\n  Math = 'Math',\n  Logic = 'Logic',\n  Data = 'Data',\n  Functional = 'Functional',\n  Core = 'Core',\n  Custom = 'Custom',\n  Utility = 'Utility',\n  Debug = 'Debug',\n}\n\nexport interface NodeMetadata {\n  category: NodeCategory | string;\n  keywords?: string[];\n  description?: string;\n  deprecated?: boolean;\n}\n\nexport type ExecuteResult = StructorRecord | { outputs: StructorRecord; ui?: any };\n\n/**\n * A \"black box\" operation implemented in native TypeScript.\n */\nexport interface PrimitiveNodeDefinition {\n  id: string;\n  kind: 'primitive';\n  metadata?: NodeMetadata;\n  configType?: StructorType;\n  /**\n    * Compiles the UI configuration (from inspector) into the runtime configuration.\n    * Can use inferred metadata (e.g. input types) to adjust the configuration.\n    */\n  compileConfig?: (uiConfig: any, metadata?: any) => Structor;\n  inputs?: Record<string, StructorType & { redirect?: string }>; // Exposed for reflection (e.g. tests)\n  outputs?: Record<string, StructorType>; // Exposed for reflection (e.g. registration)\n\n  /**\n   * BACKWARD PASS: Computes the constraints this node places on its inputs,\n   * based on the requirements placed on its outputs by downstream nodes.\n   * @param outputRequirements The types/constraints expected by downstream nodes.\n   */\n  computeBackwardPorts?: (\n    outputRequirements: RecordType,\n    config: Structor,\n    context: AnalysisContext,\n  ) => {\n    inputRequirements: RecordType;\n    // Arbitrary data to pass to the forward pass (e.g. \"I decided to be float3\")\n    backwardMetadata?: any;\n  };\n\n  /**\n   * FORWARD PASS: Computes the final canonical input and output types.\n   * Can use the metadata from the backward pass.\n   */\n  /**\n   * FORWARD PASS: Computes the final canonical input and output types.\n   * Can use the metadata from the backward pass.\n   */\n  computeForwardPorts?: (\n    inputTypes: RecordType,\n    config: Structor,\n    context: AnalysisContext,\n    backwardMetadata?: any,\n  ) => { inputs: RecordType; outputs: RecordType; forwardMetadata?: any };\n\n  shouldRecompileOnConfigChange?: (\n    newConfig: StructorRecord,\n    oldConfig: StructorRecord\n  ) => boolean;\n\n  /** Runtime execution function: computes output data from input data. */\n  execute: (\n    input: StructorRecord,\n    config: Structor,\n    context: ExecutionContext,\n    state?: any // State is allowed in Enhanced definition\n  ) => ExecuteResult;\n\n  isRealtime?: (config: Structor) => boolean;\n\n  /** Optional handler for realtime messages from UI */\n  onMessage?: (state: any, message: any) => void;\n\n  /**\n   * Optional UI definition for the node.\n   * Can contain inspector fields, body renderers, etc.\n   */\n  /**\n   * Optional UI definition for the node.\n   * Can contain inspector fields, body renderers, etc.\n   */\n  ui?: any;\n\n  /**\n   * Optional factory for creating the initial state of the node.\n   * Used by the executor to initialize state before execution.\n   */\n  createState?: (\n    config: Structor,\n    context: ExecutionContext\n  ) => any;\n\n  getDisplayLabel?: (config: Structor) => string | undefined;\n\n  /**\n   * Defines a tag for subgraph expansion.\n   * If present, the compiler will expand this node as a subgraph.\n   * \"inline\" means standard inline expansion.\n   * Any other string means the nodes are expanded but deferred/conditional.\n   */\n  subgraphExpansionTag?: string;\n\n  /**\n   * Optional function to determine implicitly owned child nodes.\n   * Used for spatial grouping (e.g. core.ifthen).\n   */\n  getChildren?: (node: any, allNodes: any) => string[];\n\n  /**\n   * Optional function to determine the spatial region of a node.\n   * Returns a bounding box relative to the node's origin.\n   * Used for smart recompilation when nodes move in/out of regions.\n   */\n  getRegion?: (config: Structor) => { x: number; y: number; width: number; height: number; };\n\n  /**\n   * Optional list of input port names that can be \"broken\" to resolve cycles.\n   * If a cycle is detected involving this node, the compiler will attempt to break it\n   * at these ports.\n   *\n   * WARNING: If a cycle is broken at these ports, the `execute` method will receive\n   * `undefined` (or missing keys) for these inputs during the first execution pass.\n   * The node implementation MUST handle this lack of type safety gracefully.\n   */\n  cycleBreakingPorts?: string[];\n\n  /**\n   * Optional secondary execution phase for cycle-broken nodes.\n   * If a node is executed a second time in the same tick (due to cycle consolidation),\n   * this method will be called instead of `execute`.\n   * Use this to capture the \"feedback\" values that were missing during the first pass.\n   *\n   * @param inputs The inputs available for consolidation (likely containing the feedback values).\n   */\n  consolidate?: (\n    inputs: StructorRecord,\n    config: Structor,\n    context: ExecutionContext,\n    state: any\n  ) => void;\n\n  /**\n   * Optional async method to load dependencies required for compilation (e.g. TypeScript).\n   * Called by the Compiler Worker before compilation.\n   */\n  loadCompileDeps?: () => Promise<void>;\n}\n\n/**\n * A composite node implemented as a nested graph.\n */\nexport interface GraphDefinition {\n  id: string;\n  kind: 'graph';\n  metadata?: NodeMetadata;\n  type: GraphType; // The pre-computed I/O signature of this graph\n  nodes: Record<string, NodeInstance>;\n  connections: { fromNode: string; fromPort: string | number; toNode: string; toPort: string | number; }[];\n  // Simplified for test purposes\n  inputs: Record<string, { nodeId: string; port: string | number }>;\n  outputs: Record<string, { nodeId: string; port: string | number }>;\n  executionOrder?: string[];\n  virtualInputMappings?: Record<string, Record<string, string>>; // ParentNodeId -> PortName -> ChildNodeId\n}\n\n// Added for GraphDefinition\nexport interface NodeInstance {\n  definitionId: string;\n  defaultConfig?: Structor;\n  executionTag?: string; // If set, this node is not part of the main execution loop\n  executionOwnerId?: string; // The ID of the node that \"owns\" this subgraph (e.g. the thensubgraph node)\n}\n\n\n\n/* ===================================================================\n * 4. The Universal Broadcast Operation Config\n * =================================================================== */\n\n/**\n * This is the \"query\" a node sends to the broadcast engine\n * to request its data in a specific shape.\n */\n// Extracted for use in AutoBroadcastDef\nexport interface TypedBroadcastChannel {\n  /** Which *named* input fields to pull from. `['*']` means all. */\n  fromFields: string[];\n  /**\n   * How to combine all collected inputs for this channel.\n   */\n  combine?: 'collect' | { reduce: 'min' | 'max' | 'add' | 'first' | 'flatten' };\n  /**\n   * (Optional) Request that all data in this channel be coerced to a number\n   * during the broadcast operation.\n   */\n  coerceTo?: 'number';\n}\n\n/**\n * This is the \"query\" a node sends to the broadcast engine\n * to request its data in a specific shape.\n */\nexport interface BroadcastConfig {\n  /**\n   * Defines the output \"channels\" the node's logic will receive.\n   */\n  outputs: Record<string, TypedBroadcastChannel>;\n\n  /**\n   * How to align the resulting channels relative to each other.\n   * 'none': Pass channels as-is (e.g., { values: [...], min: 5, max: 10 }).\n   * 'vector': Tensor-broadcast and \"zip\" all 'collect' channels\n   * (e.g., { 'broadcasted': [[v1, m1], [v2, m2], ...] }).\n   */\n  reshape: 'none' | 'vector';\n}\n","import { defineRecordType, NumberType, StringType } from \"../../structor/type-helpers\";\n\nexport type CurveType = 'exponential' | 'linear' | 'step' | 'sin' | 'quad' | 'points';\n\nexport interface GraphSegment {\n  id: string;\n  weight: number;\n  curve: {\n    type: CurveType;\n    value?: number;\n    points?: { x: number, y: number }[];\n  };\n}\n\nexport interface GraphWidgetConfig {\n  domain: [number, number];\n  range: [number, number];\n  segments: GraphSegment[];\n  envelopeNodes?: { id: string, x: number, y: number }[];\n}\n\nexport const curveStructorType = defineRecordType<GraphWidgetConfig>({\n  kind: 'record',\n  fields: {\n    domain: { kind: 'array', element: NumberType, size: 2 },\n    range: { kind: 'array', element: NumberType, size: 2 },\n    segments: {\n      kind: 'array',\n      element: {\n        kind: 'record',\n        fields: {\n          id: { kind: 'atomic', type: 'string' },\n          weight: NumberType,\n          curve: {\n            kind: 'record',\n            fields: {\n              type: { kind: 'atomic', type: 'string' },\n              value: { ...NumberType, optional: true },\n              points: {\n                kind: 'array',\n                element: {\n                  kind: 'record',\n                  fields: { x: NumberType, y: NumberType }\n                },\n                optional: true,\n                size: 'dynamic'\n              }\n            }\n          }\n        }\n      },\n      size: 'dynamic'\n    },\n    envelopeNodes: {\n      kind: 'array',\n      element: {\n        kind: 'record',\n        fields: {\n          id: { kind: 'atomic', type: 'string' },\n          x: NumberType,\n          y: NumberType\n        }\n      },\n      optional: true,\n      size: 'dynamic'\n    }\n  },\n  hint: 'curve'\n});\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { NumberType } from \"../../structor/type-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { curveStructorType, GraphWidgetConfig } from \"./types\";\n\nconst executeCurveEase = (inputs: { value?: number, easing?: GraphWidgetConfig }, config: any) => {\n  const value = inputs.value as number;\n  // Use input easing if provided\n  const easingConfig = inputs.easing as GraphWidgetConfig;\n\n  if (!easingConfig || !easingConfig.segments || easingConfig.segments.length === 0) {\n    return { result: value };\n  }\n\n  const { domain, range, segments } = easingConfig;\n  const [minIn, maxIn] = domain;\n  const [minOut, maxOut] = range;\n\n  // Normalize input to 0-1 based on domain\n  // If domain is 0-1, t = value\n  let t = (value - minIn) / (maxIn - minIn);\n\n  // Clamp t to 0-1 for safety (or should we extrapolate? usually easing is clamped)\n  t = Math.max(0, Math.min(1, t));\n\n  // Find segment\n  const totalWeight = segments.reduce((sum, s) => sum + s.weight, 0) || 1;\n  let currentT = 0;\n  let matchedSegment = segments[segments.length - 1]; // Default to last\n  let segmentStartT = 0;\n  let segmentWidthT = 0;\n\n  for (const segment of segments) {\n    const widthT = segment.weight / totalWeight;\n    if (t >= currentT && t <= currentT + widthT) {\n      matchedSegment = segment;\n      segmentStartT = currentT;\n      segmentWidthT = widthT;\n      break;\n    }\n    currentT += widthT;\n  }\n\n  // Normalize t within segment (0-1)\n  // tInSegment = (t - segmentStartT) / segmentWidthT\n  const tInSegment = (t - segmentStartT) / segmentWidthT;\n\n  // Evaluate curve\n  let normY = 0;\n  const curve = matchedSegment.curve;\n  const steps = curve.type === 'step' ? (curve.value ?? 2) : 1;\n\n  switch (curve.type) {\n    case 'exponential':\n      // Map value (-1 to 1) to exponent\n      // exponent = 10^(-value)\n      const exponent = Math.pow(10, -(curve.value ?? 0));\n      normY = Math.pow(tInSegment, exponent);\n      break;\n    case 'linear':\n      normY = tInSegment;\n      break;\n    case 'step':\n      if (steps <= 1) normY = 0;\n      else normY = Math.floor(tInSegment * steps) / (steps - 1);\n      if (tInSegment >= 0.999) normY = 1;\n      break;\n    case 'sin':\n      // EaseInOutSine: -(cos(PI * x) - 1) / 2\n      normY = -(Math.cos(Math.PI * tInSegment) - 1) / 2;\n      break;\n    case 'quad':\n      // EaseInQuad: t * t\n      normY = tInSegment * tInSegment;\n      break;\n    case 'points':\n      if (curve.points && curve.points.length > 0) {\n        // Linear interpolation between points\n        // Points are sorted by x? Assuming yes based on user request \"sorted\"\n        // Find p1, p2 such that p1.x <= tInSegment <= p2.x\n        const points = curve.points;\n        if (tInSegment <= points[0].x) normY = points[0].y;\n        else if (tInSegment >= points[points.length - 1].x) normY = points[points.length - 1].y;\n        else {\n          for (let i = 0; i < points.length - 1; i++) {\n            const p1 = points[i];\n            const p2 = points[i + 1];\n            if (tInSegment >= p1.x && tInSegment <= p2.x) {\n              const localT = (tInSegment - p1.x) / (p2.x - p1.x);\n              normY = p1.y + localT * (p2.y - p1.y);\n              break;\n            }\n          }\n        }\n      } else {\n        normY = tInSegment;\n      }\n      break;\n    default:\n      normY = tInSegment;\n  }\n\n  // Map to output range\n  const result = minOut + normY * (maxOut - minOut);\n\n  return { result };\n};\n\nexport const curve_ease = defineNode({\n  id: 'curve.ease',\n  version: '1.0.0',\n  displayName: 'Curve Ease',\n  metadata: {\n    category: NodeCategory.Math,\n    keywords: ['curve', 'ease', 'envelope', 'shape'],\n    description: 'Applies a custom curve easing to the input value.'\n  },\n  inputs: {\n    value: { type: NumberType, description: 'Input value (0-1)', defaultValue: 0 },\n    easing: {\n      type: { ...curveStructorType, optional: true },\n      description: 'Easing Curve Configuration',\n      suppressInputEditor: true\n    }\n  },\n  outputs: {\n    result: NumberType\n  },\n  autoBroadcast: true,\n  inspectInputs: true,\n  /* UI registered in register-ui.ts */\n  compileConfig: (uiConfig) => {\n    return {\n      fields: {\n        easing: uiConfig?.easing ?? {\n          domain: [0, 1],\n          range: [0, 1],\n          segments: [{\n            id: 's1',\n            weight: 1,\n            curve: { type: 'exponential', value: 0 }\n          }]\n        }\n      },\n      untagged: []\n    };\n  },\n  execute: executeCurveEase as any\n});\n\nexport const curve_ease4 = defineNode({\n  id: 'curve.ease4',\n  version: '1.0.0',\n  displayName: 'Curve Ease 4',\n  metadata: {\n    category: NodeCategory.Math,\n    keywords: ['curve', 'ease', 'envelope', 'shape', 'multi'],\n    description: 'Applies a custom 4-segment curve easing to the input value.'\n  },\n  inputs: {\n    value: { type: NumberType, description: 'Input value (0-1)', defaultValue: 0 },\n    easing: {\n      type: { ...curveStructorType, optional: true },\n      description: 'Easing Curve Configuration',\n      suppressInputEditor: true,\n      defaultValue: {\n        domain: [0, 1],\n        range: [0, 1],\n        segments: [\n          { id: 's1', weight: 1, curve: { type: 'exponential', value: 0.5 } },\n          { id: 's2', weight: 1, curve: { type: 'exponential', value: 0.0 } },\n          { id: 's3', weight: 1, curve: { type: 'exponential', value: -0.5 } },\n          { id: 's4', weight: 1, curve: { type: 'exponential', value: -1.0 } }\n        ]\n      }\n    }\n  },\n  outputs: {\n    result: NumberType\n  },\n  autoBroadcast: true,\n  inspectInputs: true,\n  /* UI registered in register-ui.ts */\n  compileConfig: (uiConfig) => {\n    return {\n      fields: {\n        easing: uiConfig?.easing ?? {\n          domain: [0, 1],\n          range: [0, 1],\n          segments: [\n            { id: 's1', weight: 1, curve: { type: 'exponential', value: 0.5 } },\n            { id: 's2', weight: 1, curve: { type: 'exponential', value: 0.0 } },\n            { id: 's3', weight: 1, curve: { type: 'exponential', value: -0.5 } },\n            { id: 's4', weight: 1, curve: { type: 'exponential', value: -1.0 } }\n          ]\n        }\n      },\n      untagged: []\n    };\n  },\n  execute: executeCurveEase as any\n});\n\nregisterNode(curve_ease);\nregisterNode(curve_ease4);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { NumberType, AnyType } from \"../../structor/type-helpers\";\nimport { ExecutionContext } from \"../../structor/structor\";\nimport { GraphWidgetConfig } from \"./types\";\n\ninterface CurveEnvState {\n  lastSegmentIndex: number;\n}\n\nconst executeCurveEnv = (inputs: { value?: number; }, config: { config?: GraphWidgetConfig; }, context: ExecutionContext, state: CurveEnvState) => {\n  // console.log('executeCurveEnv inputs:', inputs);\n  const value = inputs.value ?? 0;\n\n  // Prioritize inputs.config (runtime updates) over config.config (compiled snapshot)\n  // Check all possible locations for config\n  const envConfig = config?.config;\n\n  // DEBUG SIGNALS REMOVED\n  if (!envConfig ||\n    !envConfig.envelopeNodes ||\n    envConfig.envelopeNodes.length < 2 ||\n    !envConfig.segments) {\n    // If config is missing or invalid, pass through input value (Identity)\n    return { result: value };\n  }\n\n  const nodes = envConfig.envelopeNodes;\n  const segments = envConfig.segments || [];\n\n  // Boundary Handling\n  const firstNode = nodes[0];\n  const lastNode = nodes[nodes.length - 1];\n\n  if (value <= firstNode.x) return { result: firstNode.y };\n  if (value >= lastNode.x) return { result: lastNode.y };\n\n  // Optimization: Check cached segment index\n  let segmentIndex = state.lastSegmentIndex || 0;\n  // Verify cache\n  if (segmentIndex >= nodes.length - 1 || value < nodes[segmentIndex].x || value >= nodes[segmentIndex + 1].x) {\n    // Linear search (since cached index failed)\n    for (let i = 0; i < nodes.length - 1; i++) {\n      if (value >= nodes[i].x && value < nodes[i + 1].x) {\n        segmentIndex = i;\n        break;\n      }\n    }\n  }\n  state.lastSegmentIndex = segmentIndex;\n\n  const p0 = nodes[segmentIndex];\n  const p1 = nodes[segmentIndex + 1];\n  const segment = segments[segmentIndex];\n\n  // Normalized position in segment (0..1)\n  const t = (value - p0.x) / (p1.x - p0.x);\n\n  // Apply shaping\n  let shapedT = t;\n  if (segment && segment.curve) {\n    const type = segment.curve.type || 'linear';\n    const curveVal = segment.curve.value || 0;\n\n    if (type === 'linear') {\n      shapedT = t;\n    } else if (type === 'exponential') {\n      const exponent = Math.pow(10, -(curveVal ?? 0));\n      // Clamp t to prevent NaN for negative t (though t should be 0..1)\n      const safeT = Math.max(0, t);\n      shapedT = Math.pow(safeT, exponent);\n      // Implementation for other curve types can be added here if needed\n      // Current implementations: exponential, linear, step, sin, quad, points\n    }\n  }\n\n  // Linear interpolation on shaped time\n  const result = p0.y + (p1.y - p0.y) * shapedT;\n\n  return { result };\n};\n\ninterface CurveEnvUIConfig {\n  config?: GraphWidgetConfig; // Root level (canonical)\n  curveData?: GraphWidgetConfig; // Alias/Legacy\n  values?: {\n    config?: GraphWidgetConfig;\n    value?: number;\n    [key: string]: any;\n  };\n}\n\ntype CurveEnvCompiledConfig = {\n  config: typeof AnyType; // Complex object structure\n};\n\nexport const curve_env = defineNode({\n  id: 'curve.env',\n  version: '1.0.0',\n  displayName: 'Curve Envelope',\n  metadata: {\n    category: 'Curve',\n    keywords: ['envelope', 'automation', 'ramp'],\n    description: 'User-editable curve envelope'\n  },\n  inputs: {\n    value: { type: NumberType, description: 'Input value (0-1)', defaultValue: 0 }\n  },\n  outputs: {\n    result: { type: NumberType, description: 'Output value' }\n  },\n  config: {\n    config: { kind: 'atomic', type: 'any', defaultValue: {} }\n  },\n  inspectInputs: true,\n  createState: (): CurveEnvState => ({\n    lastSegmentIndex: 0\n  }),\n  autoBroadcast: true,\n  compileConfig: (uiConfig: CurveEnvUIConfig) => {\n    // Prefer root-level 'config' or 'curveData', fallback to values\n    const sourceConfig = uiConfig.config ?? uiConfig.curveData ?? uiConfig.values?.config;\n\n    return {\n      config: sourceConfig ?? {\n        domain: [0, 1],\n        range: [0, 1],\n        envelopeNodes: [\n          { id: 'n1', x: 0, y: 0 },\n          { id: 'n2', x: 1, y: 1 }\n        ],\n        segments: [\n          { id: 's1', weight: 1, curve: { type: 'linear' } }\n        ]\n      }\n    };\n  },\n  execute: executeCurveEnv\n});\n\nregisterNode(curve_env);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { NumberType, StringType } from \"../../structor/type-helpers\";\nimport { StructorType } from \"../../structor/structor\";\n\ninterface CurveCropUIConfig {\n  mode?: string;\n  values?: Record<string, any>;\n}\n\n// Runtime Configuration Schema\ntype CurveCropCompiledConfig = {\n  mode: typeof StringType;\n};\n\nconst curveCropInputs = {\n  value: { type: NumberType, defaultValue: 0 },\n  start: { type: NumberType, defaultValue: 0 },\n  end: { type: NumberType, defaultValue: 1, optional: true },\n  length: { type: NumberType, defaultValue: 1, optional: true }\n};\n\nexport const curve_crop = defineNode({\n  id: 'curve.crop',\n  version: '1.0.0',\n  displayName: 'Curve Crop',\n  metadata: {\n    category: 'Curve',\n    keywords: ['crop', 'slice', 'remap', 'linear'],\n    description: 'Linear mapping from 0-1 to start-end range.'\n  },\n  config: {\n    mode: { kind: 'atomic', type: 'string', defaultValue: 'start-end' }\n  },\n  // Dynamic inputs based on mode\n  computeForwardPorts: (inputTypes, uiConfig, context) => {\n    // Mode is at root level config (set by inspector or compileConfig)\n    const mode = uiConfig.mode || 'start-end';\n\n    const fields: Record<string, StructorType> = {\n      value: { ...NumberType, description: 'Input value (0-1)', defaultValue: 0 },\n      start: { ...NumberType, description: 'Output at 0', defaultValue: 0 }\n    };\n\n    if (mode === 'start-length') {\n      fields['length'] = { ...NumberType, description: 'Length of crop', defaultValue: 1 };\n    } else {\n      // Default: start-end\n      fields['end'] = { ...NumberType, description: 'Output at 1', defaultValue: 1 };\n    }\n\n    return {\n      inputs: { kind: 'record', fields },\n      outputs: { kind: 'record', fields: { result: NumberType } }\n    };\n  },\n  // Static inputs definition required for autoBroadcast to work\n  inputs: curveCropInputs,\n  outputs: { result: { type: NumberType } }, // Handled by computeForwardPorts, but kept for metadata\n\n  // UI Configuration for Inspector\n  // @ts-ignore\n  ui: {\n    inspector: {\n      fields: [\n        {\n          type: 'tab-bar',\n          label: 'Mode',\n          path: 'mode',\n          options: [\n            { label: 'Start / End', value: 'start-end' },\n            { label: 'Start / Length', value: 'start-length' }\n          ]\n        }\n      ]\n    }\n  },\n\n  compileConfig: (uiConfig: CurveCropUIConfig) => {\n    // Return Flat Data Structure (handled by GraphExecutor normalization and valid for ComputeForwardPorts)\n    const mode = uiConfig.mode || 'start-end';\n    return {\n      mode: mode\n    };\n  },\n\n  autoBroadcast: true,\n  inspectInputs: true,\n  execute: (inputs, config, context) => {\n    // config corresponds to the return type of compileConfig\n    const mode = config.mode || 'start-end';\n\n    const start = inputs.start ?? 0;\n    const val = inputs.value ?? 0;\n    let end: number;\n\n    if (mode === 'start-length') {\n      const length = inputs.length ?? 1;\n      end = start + length;\n    } else {\n      end = inputs.end ?? 1;\n    }\n\n    // Enforce end >= start\n    if (end < start) end = start;\n\n    // Crop (Remap val from [start, end] to [0, 1])\n    let result = 0;\n    const range = end - start;\n\n    if (range < 0.000001) {\n      // Range is effectively zero. Step function?\n      // If val >= start, 1, else 0? Or just 0?\n      // Let's assume standard step behavior at start.\n      result = val >= start ? 1 : 0;\n    } else {\n      // (val - start) / (end - start)\n      const t = (val - start) / range;\n      // Clamp result to 0-1\n      result = Math.max(0, Math.min(1, t));\n    }\n\n    // Pass resolved 'end' to UI so it can render correctly without knowing the mode logic\n    // Actually, UI needs to know if it's connected or not to fallback.\n    // But passing 'end' explicitly helps the UI visualization be consistent.\n    return {\n      outputs: { result },\n      ui: { start, end }\n    };\n  },\n  shouldRecompileOnConfigChange: (uiConfig) => {\n    // Recompile if mode changes to update ports.\n    // While this might recompile on slider drags (if they are part of the same config object),\n    // it is necessary for structural correctness when mode changes.\n    return true;\n  }\n});\n\nregisterNode(curve_crop);\n","import { defineType } from \"./type-helpers\";\n\nexport const numberType = defineType({ kind: \"atomic\", type: \"number\", defaultValue: 0 } as const);\nexport const stringType = defineType({ kind: \"atomic\", type: \"string\" } as const);\nexport const booleanType = defineType({ kind: \"atomic\", type: \"boolean\" } as const);\nexport const anyType = defineType({ kind: \"atomic\", type: \"any\" } as const);\n\nexport const timeBaseEnum = defineType({\n  kind: \"atomic\",\n  type: \"string\",\n  options: [\"time\", \"beats\"],\n  defaultValue: \"time\"\n} as const);\n\nexport const midiEventType = defineType({\n  kind: \"record\",\n  fields: {\n    type: stringType,\n    channel: numberType,\n    deviceId: { ...stringType, optional: true },\n    time: { ...numberType, optional: true },\n    // Union fields\n    note: { ...numberType, optional: true },\n    velocity: { ...numberType, optional: true },\n    cc: { ...numberType, optional: true },\n    value: { ...numberType, optional: true }\n  },\n  hint: 'midi'\n} as const);\n\nexport const midiStreamType = defineType({\n  kind: \"array\",\n  size: \"dynamic\",\n  element: midiEventType,\n  hint: 'midi-stream'\n} as const);\n\nexport const float2Type = defineType({\n  kind: \"array\",\n  element: numberType,\n  size: 2,\n  hint: \"float2\"\n} as const);\n\nexport const float3Type = defineType({\n  kind: \"array\",\n  element: numberType,\n  size: 3,\n  hint: \"float3\"\n} as const);\n\nexport const float4Type = defineType({\n  kind: \"array\",\n  element: numberType,\n  size: 4,\n  hint: \"float4\"\n} as const);\n\n\n// Note & Sequence Types (moved from nicepattern)\n\nexport const noteStructorType = defineType({\n  kind: \"record\",\n  fields: {\n    note: numberType,\n    velocity: numberType,\n  },\n  untagged: [],\n} as const);\n\nexport const noteEventStructorType = defineType({\n  kind: \"record\",\n  fields: {\n    onNote: { ...noteStructorType, optional: true },\n    offNote: { ...noteStructorType, optional: true },\n    hold: booleanType,\n  },\n  untagged: [],\n} as const);\n\nexport const stepStructorType = defineType({\n  kind: \"record\",\n  fields: {\n    noteIndex: anyType, // Can be number | null\n    velocity: numberType,\n    hold: booleanType,\n  },\n  untagged: [],\n} as const);\n\nexport const sequenceStructorType = defineType({\n  kind: \"array\",\n  size: \"dynamic\",\n  element: stepStructorType,\n  hint: 'step-sequence'\n} as const);\n\nexport type UIConfigStructorType = 'float' | 'float2' | 'float3' | 'float4' | 'midi-stream' | 'string' | 'any';\n","import { defineNode, registerNode } from '../../structor/node-helpers';\nimport { NodeCategory } from '../../structor/structor';\nimport { numberType } from '../../structor/std-types';\n\nexport const debugScopeNode = defineNode({\n  id: 'debug.scope',\n  version: '1.0.0',\n  displayName: 'Scope',\n  metadata: {\n    category: NodeCategory.Debug,\n    keywords: ['debug', 'scope', 'chart', 'visualize'],\n    description: 'Visualizes input values over time.'\n  },\n  inputs: {\n    value: { type: numberType, suppressLabel: true, alwaysShowInputEditor: true }\n  },\n  outputs: {\n    value: numberType\n  },\n  config: {},\n  inspectInputs: true,\n  execute: (inputs: { value: number }) => {\n    return { value: inputs.value };\n  },\n  compileConfig: (uiConfig) => ({})\n});\n\nregisterNode(debugScopeNode);\n","import { registerNode } from '../../structor/node-helpers';\nimport { debugScopeNode } from './nodes';\n\nregisterNode(debugScopeNode);\n","import { ExecutionGraph, NodeId } from \"./expr-types\";\n\n// ==========================================\n// 3. The Executor (Runs the JSON Graph)\n// ==========================================\n\nexport class ExpressionExecutor {\n  execute(graph: ExecutionGraph, inputs: Record<string, any>): any {\n    if (!graph.rootId) return null;\n\n    const cache = new Map<NodeId, any>();\n\n    const resolve = (id: NodeId): any => {\n      if (cache.has(id)) return cache.get(id);\n\n      const node = graph.nodes[id];\n      if (!node) throw new Error(`Missing node ${id}`);\n\n      // Recursive resolution of dependencies\n      const args = node.inputs.map(inputId => resolve(inputId));\n\n      let result: any;\n      switch (node.op) {\n        case 'const':\n          result = node.params.value;\n          break;\n        case 'input':\n          // Looks for value in inputs dictionary, or fallback to global (like Math)\n          result = inputs[node.params.key] !== undefined\n            ? inputs[node.params.key]\n            : (globalThis as any)[node.params.key];\n          break;\n        case 'add': result = args[0] + args[1]; break;\n        case 'sub': result = args[0] - args[1]; break;\n        case 'mul': result = args[0] * args[1]; break;\n        case 'div': result = args[0] / args[1]; break;\n        case 'prop':\n          if (args[0] === undefined || args[0] === null) throw new Error(`Cannot access property '${node.params.key}' of undefined`);\n          result = args[0][node.params.key];\n          break;\n        case 'struct':\n          // Reassemble object { key: value }\n          result = {};\n          node.params.keys.forEach((key: string, idx: number) => {\n            result[key] = args[idx];\n          });\n          break;\n        default:\n          throw new Error(`Unknown op: ${node.op}`);\n      }\n\n      cache.set(id, result);\n      return result;\n    };\n\n    return resolve(graph.rootId);\n  }\n}\n","import { defineNode, registerNode, InspectorFieldDef } from \"../../structor/node-helpers\";\nimport { AnyType, NumberType, StringType } from \"../../structor/type-helpers\";\n// Use the executor-only import for the worker bundle\nimport { ExpressionExecutor } from \"./expr-executor\";\nimport type { ExecutionGraph } from \"./expr-types\";\nimport { NodeCategory, StructorType } from \"../../structor/structor\";\nimport { anyType, numberType } from \"../../structor/std-types\";\n\n// Import Type for Compiler (but not the value)\nimport type { GraphCompiler } from \"./expr-compiler\";\n\n// Singleton instances\nlet compilerWrapper: { compiler: GraphCompiler } | null = null;\nconst executor = new ExpressionExecutor();\n\n// Cache for compiled graphs\nconst graphCache = new Map<string, ExecutionGraph>();\n\nfunction getCompiledGraph(code: string): ExecutionGraph {\n  if (graphCache.has(code)) {\n    return graphCache.get(code)!;\n  }\n\n  // If compiler is not loaded, we can't compile new code.\n  // Ideally this should not happen if loadCompileDeps is called correctly.\n  if (!compilerWrapper) {\n    console.warn(\"Expression Compiler not loaded yet. Returning empty graph.\");\n    return { nodes: {}, rootId: null };\n  }\n\n  try {\n    const graph = compilerWrapper.compiler.compile(code);\n    graphCache.set(code, graph);\n    return graph;\n  } catch (e) {\n    console.error(\"Compilation failed:\", e);\n    return { nodes: {}, rootId: null };\n  }\n}\n\nconst ExpressionFields: InspectorFieldDef[] = [\n  { type: 'string', label: 'Expression', path: 'code', placeholder: 'e.g. sin(time) * 0.5' }\n];\n\nexport const expressionNode = defineNode({\n  id: \"logic.expression\",\n  version: \"1.0.0\",\n  displayName: \"Expression\",\n  metadata: {\n    category: NodeCategory.Logic,\n    keywords: ['expression', 'math', 'script', 'code'],\n    description: 'Evaluates a mathematical expression.'\n  },\n  inputs: {}, // Inputs are dynamic\n  config: {\n    code: StringType,\n    graph: AnyType // Preserved for execution\n  },\n  outputs: {\n    result: AnyType\n  },\n  autoBroadcast: false, // We handle raw inputs\n  ui: { inspector: { fields: ExpressionFields } },\n\n  // Lazy Load the heavy compiler (TypeScript)\n  loadCompileDeps: async () => {\n    if (!compilerWrapper) {\n      // Dynamic import of the compilation logic (which imports typescript)\n      const module = await import('./expr-compiler');\n      compilerWrapper = { compiler: new module.GraphCompiler() };\n    }\n  },\n\n  compileConfig: (uiConfig: { code?: string }) => {\n    const code = uiConfig.code || '';\n    // Compile code to graph\n    const graph = getCompiledGraph(code);\n    return {\n      code: code,\n      // Embed the graph in the config so the executor has it without recompiling\n      graph: graph as any\n    };\n  },\n  computeForwardPorts: (inputTypes, uiConfig) => {\n    const code = uiConfig.code || '';\n    const graph = getCompiledGraph(code);\n\n    // Find all input nodes\n    const inputNames = new Set<string>();\n    for (const node of Object.values(graph.nodes)) {\n      if (node.op === 'input') {\n        inputNames.add(node.params.key);\n      }\n    }\n\n    const inputs: Array<[string, StructorType]> = Array.from(inputNames).map(name =>\n      [name, {\n        ...numberType, // Assume numbers for math expressions\n        description: `Variable ${name}`\n      }]);\n\n    return {\n      inputs: { kind: 'record', fields: Object.fromEntries(inputs) },\n      outputs: { kind: 'record', fields: { result: { ...anyType, description: 'Result' } } }\n    };\n  },\n  execute: (inputs, config, context) => {\n    // The executor worker receives the Compiled config.\n    // So config.graph should be present.\n    const graph = config.graph;\n\n    if (!graph || !graph.rootId) {\n      // Fallback or empty\n      return { result: 0 };\n    }\n\n    // Prepare inputs\n    const exprInputs: Record<string, any> = { ...(inputs as any) };\n\n    try {\n      const result = executor.execute(graph, exprInputs.fields || exprInputs); // Handle both wrapped and raw?\n      return { result: result };\n    } catch (e) {\n      console.error(\"Execution failed:\", e);\n      return { result: null };\n    }\n  },\n\n});\n\nregisterNode(expressionNode);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { numberType } from \"../../structor/std-types\";\n\ninterface SawtoothState {\n  phase: number;\n}\n\nexport const sawtooth = defineNode({\n  id: \"gen.sawtooth\",\n  version: \"1.0.0\",\n  displayName: \"Sawtooth\",\n  metadata: {\n    category: 'Oscillator',\n    keywords: ['oscillator', 'sawtooth', 'ramp', 'lfo', 'generator'],\n    description: 'Generates a linear sawtooth wave (0.0 to 1.0) at the given frequency.'\n  },\n  inputs: {\n    freq: {\n      type: numberType,\n      defaultValue: 1.0,\n      range: [0, 60],\n      description: 'Frequency in Hz'\n    }\n  },\n  outputs: { out: numberType },\n  autoBroadcast: true,\n  isRealtime: () => true,\n  createState: (): SawtoothState => ({\n    phase: 0\n  }),\n  execute: (inputs, config, context, state) => {\n    const freq = inputs.freq;\n    const dt = context.clock.dt;\n\n    if (freq >= 60.0 - 1e-6) {\n      return { out: Math.random() };\n    }\n\n    // Accumulate phase\n    state.phase += dt * freq;\n    state.phase -= Math.floor(state.phase);\n\n    return { out: state.phase };\n  },\n});\n\nregisterNode(sawtooth);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { numberType, midiStreamType } from \"../../structor/std-types\";\nimport { StringType } from \"../../structor/type-helpers\";\nimport { StructorType } from \"../../structor/structor\";\n\nconst ADSR_PHASE = {\n  IDLE: 0,\n  ATTACK: 1,\n  DECAY: 2,\n  SUSTAIN: 3,\n  RELEASE: 4\n};\n\ninterface AdsrUIConfig {\n  mode?: string;\n  values?: { mode?: string };\n}\n\ntype AdsrCompiledConfig = {\n  mode: typeof StringType;\n};\n\ninterface AdsrState {\n  phase: number;\n  value: number;\n  time: number;\n  activeNotes: number;\n}\n\nexport const adsr = defineNode({\n  id: \"gen.adsr\",\n  version: \"1.0.0\",\n  displayName: \"ADSR\",\n  metadata: {\n    category: 'Envelope',\n    keywords: ['envelope', 'adsr', 'modulation'],\n    description: 'Attack-Decay-Sustain-Release envelope generator triggered by MIDI.'\n  },\n  autoBroadcast: {\n    stream: { combine: { reduce: 'flatten' } }\n  },\n  inputs: {\n    stream: { type: midiStreamType, description: 'MIDI Stream', allowMultiConnection: true },\n    attack: { type: numberType, defaultValue: 0.1, range: [0, 5], description: 'Attack Time (s)' },\n    decay: { type: numberType, defaultValue: 1.0, range: [0, 5], description: 'Decay Time (s)' },\n    sustain: { type: numberType, defaultValue: 0.7, range: [0, 1], description: 'Sustain Level (0-1)' },\n    release: { type: numberType, defaultValue: 1.0, range: [0, 5], description: 'Release Time (s)' }\n  },\n\n  config: {\n    mode: { kind: 'atomic', type: 'string', defaultValue: 'D' }\n  },\n  ui: {\n    inspector: {\n      fields: [\n        {\n          label: 'Mode',\n          path: 'mode',\n          type: 'tab-bar',\n          options: [\n            { label: 'ADSR', value: 'ADSR' },\n            { label: 'ADS', value: 'ADS' },\n            { label: 'D', value: 'D' }\n          ],\n        }\n      ]\n    }\n  },\n  compileConfig: (uiConfig: AdsrUIConfig) => ({\n    mode: uiConfig.mode || uiConfig.values?.mode || 'D'\n  }),\n  computeForwardPorts: (inputTypes, uiConfig) => {\n    // uiConfig is now the result of compileConfig (flat data)\n    const mode = uiConfig.mode || 'D';\n\n    const fields: Record<string, StructorType> = {\n      stream: midiStreamType\n    };\n\n    if (mode === 'ADSR') {\n      fields.attack = numberType;\n      fields.decay = numberType;\n      fields.sustain = numberType;\n      fields.release = numberType;\n    } else if (mode === 'ADS') {\n      fields.attack = numberType;\n      fields.decay = numberType;\n      fields.sustain = numberType;\n      // No release\n    } else if (mode === 'D') {\n      fields.decay = numberType;\n      // No attack, sustain, release\n    }\n\n    return {\n      inputs: { kind: 'record', fields },\n      outputs: { kind: 'record', fields: { value: numberType } }\n    };\n  },\n  outputs: {\n    value: { type: numberType, description: 'Envelope Value (0-1)' }\n  },\n  isRealtime: () => true,\n  shouldRecompileOnConfigChange: (uiConfig) => {\n    return true;\n  },\n  createState: (): AdsrState => ({\n    phase: ADSR_PHASE.IDLE,\n    value: 0.0,\n    time: 0.0,\n    activeNotes: 0\n  }),\n  execute: (inputs, config, context, state) => {\n    const dt = context.clock.dt;\n    // Strict config typing\n    const mode = config.mode || 'D';\n    const stream = inputs.stream;\n\n    let attackTime = 0;\n    let decayTime = 0;\n    let sustainLevel = 0;\n    let releaseTime = 0;\n\n    if (mode === 'D') {\n      attackTime = 0;\n      decayTime = Math.max(0, inputs.decay ?? 0.1);\n      sustainLevel = 0;\n      releaseTime = decayTime;\n    } else if (mode === 'ADS') {\n      attackTime = Math.max(0, inputs.attack ?? 0.1);\n      decayTime = Math.max(0, inputs.decay ?? 0.1);\n      sustainLevel = Math.max(0, Math.min(1, inputs.sustain ?? 0.7));\n      releaseTime = decayTime;\n    } else {\n      // ADSR\n      attackTime = Math.max(0, inputs.attack ?? 0.1);\n      decayTime = Math.max(0, inputs.decay ?? 0.1);\n      sustainLevel = Math.max(0, Math.min(1, inputs.sustain ?? 0.7));\n      releaseTime = Math.max(0, inputs.release ?? 0.5);\n    }\n\n\n    if (Array.isArray(stream)) {\n      for (const e of stream) {\n        if (e.type === 'note_on' && (e.velocity ?? 0) > 0) {\n          state.activeNotes++;\n          if (state.activeNotes === 1) {\n            // Trigger Attack\n            state.phase = ADSR_PHASE.ATTACK;\n            state.value = 0; // Reset value on new trigger? Or continue from current? Usually reset or retrigger.\n            // Standard ADSR often restarts or continues.\n            // Ideally: continue, but for mono Trigger, usually reset if it was off.\n            // If it was releasing, we pick up from there?\n            // \"Legacy\" behavior was reset. Let's stick to simple first unless requested.\n            // Actually, for \"Zero Attack\", we need to know if we just started.\n            state.time = 0;\n\n            // Instant Attack Handling\n            if (attackTime <= 0) {\n              state.value = 1.0;\n              state.phase = ADSR_PHASE.DECAY;\n              state.time = 0;\n\n              // Instant Decay Handling\n              if (decayTime <= 0) {\n                state.value = sustainLevel;\n                state.phase = ADSR_PHASE.SUSTAIN;\n              }\n            }\n          }\n        } else if (e.type === 'note_off' || (e.type === 'note_on' && (e.velocity ?? 0) === 0)) {\n          state.activeNotes = Math.max(0, state.activeNotes - 1);\n        }\n      }\n    }\n\n    // Check for Release transition\n    if (state.activeNotes === 0 && state.phase !== ADSR_PHASE.IDLE && state.phase !== ADSR_PHASE.RELEASE) {\n      state.phase = ADSR_PHASE.RELEASE;\n      state.time = 0;\n    }\n\n    switch (state.phase) {\n      case ADSR_PHASE.IDLE:\n        state.value = 0;\n        state.time = 0;\n        break;\n\n      case ADSR_PHASE.ATTACK:\n        state.time += dt;\n        state.value += (1.0 / Math.max(0.001, attackTime)) * dt;\n        if (state.value >= 1.0) {\n          state.value = 1.0;\n          state.phase = ADSR_PHASE.DECAY;\n          state.time = 0;\n\n          // Handle Instant Decay if we just finished Attack naturally\n          if (decayTime <= 0) {\n            state.value = sustainLevel;\n            state.phase = ADSR_PHASE.SUSTAIN;\n          }\n        }\n        break;\n\n      case ADSR_PHASE.DECAY:\n        state.time += dt;\n        state.value -= ((1.0 - sustainLevel) / Math.max(0.001, decayTime)) * dt;\n        if (state.value <= sustainLevel) {\n          state.value = sustainLevel;\n          state.phase = ADSR_PHASE.SUSTAIN;\n          state.time = 0;\n        }\n        break;\n\n      case ADSR_PHASE.SUSTAIN:\n        state.time += dt;\n        state.value = sustainLevel;\n        break;\n\n      case ADSR_PHASE.RELEASE:\n        state.time += dt;\n        if (releaseTime <= 0) {\n          state.value = 0;\n          state.phase = ADSR_PHASE.IDLE;\n          state.time = 0;\n        } else {\n          state.value -= (1.0 / releaseTime) * dt;\n          if (state.value <= 0) {\n            state.value = 0;\n            state.phase = ADSR_PHASE.IDLE;\n            state.time = 0;\n          }\n        }\n        break;\n    }\n\n    return {\n      outputs: { value: Math.max(0, Math.min(1, state.value)) },\n      // Send current value to UI for visualization (Hero Node)\n      ui: { value: state.value, phase: state.phase, time: state.time }\n    };\n  },\n  inspectInputs: true\n});\n\nregisterNode(adsr);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { numberType, midiStreamType } from \"../../structor/std-types\";\nimport { StringType } from \"../../structor/type-helpers\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\n// Simple LCG PRNG\nfunction lcg(seed: number) {\n  const m = 0x80000000;\n  const a = 1103515245;\n  const c = 12345;\n  let state = seed ? seed : Math.floor(Math.random() * (m - 1));\n\n  return {\n    next: () => {\n      state = (a * state + c) % m;\n      return state / (m - 1);\n    }\n  };\n}\n\ninterface MathRandomUIConfig {\n  mode?: string;\n  seed?: number;\n  values?: { mode?: string; seed?: number };\n}\n\ntype MathRandomCompiledConfig = {\n  mode: typeof StringType;\n  seed: { kind: 'atomic', type: 'number', defaultValue?: number };\n};\n\ninterface MathRandomState {\n  generator: { next: () => number };\n  currentValue: number;\n}\n\nexport const random = defineNode({\n  id: \"math.random\",\n  version: \"1.1.0\",\n  displayName: \"Random\",\n  metadata: {\n    category: 'Math',\n    keywords: ['random', 'stochastic', 'noise', 'seed', 'white'],\n    description: 'Generates a random number (0-1). Supports on-trigger or free-run modes.'\n  },\n  // Used for autoBroadcast compilation mainly\n  inputs: {\n    trigger: { type: midiStreamType, description: 'Trigger Signal', allowMultiConnection: true }\n  },\n  config: {\n    seed: { kind: 'atomic', type: 'number', defaultValue: 12345 },\n    mode: { kind: 'atomic', type: 'string', defaultValue: 'on-trigger' }\n  },\n  outputs: {\n    value: { type: numberType, description: 'Random Value' }\n  },\n  autoBroadcast: {\n    trigger: { combine: { reduce: 'flatten' } }\n  },\n\n  // UI Configuration\n  ui: {\n    inspector: {\n      fields: [\n        {\n          type: 'tab-bar',\n          label: 'Mode',\n          path: 'mode',\n          options: [\n            { label: 'On Trigger', value: 'on-trigger' },\n            { label: 'Free Run', value: 'free-run' }\n          ],\n          default: 'on-trigger'\n        },\n        { type: 'number', label: 'Seed', path: 'seed', default: 12345 }\n      ]\n    }\n  },\n\n  compileConfig: (uiConfig: MathRandomUIConfig) => ({\n    mode: uiConfig.mode || uiConfig.values?.mode || 'on-trigger',\n    seed: uiConfig.seed || uiConfig.values?.seed || 12345\n  }),\n\n  computeForwardPorts: (inputTypes, uiConfig: MathRandomUIConfig) => {\n    // uiConfig is now compiled flat data\n    const mode = uiConfig.mode || 'on-trigger';\n\n    const inputs: any = {};\n\n    if (mode === 'on-trigger') {\n      inputs['trigger'] = { type: midiStreamType, description: 'Trigger Signal', allowMultiConnection: true };\n    }\n\n    return {\n      inputs: { kind: 'record', fields: inputs },\n      outputs: { kind: 'record', fields: { value: numberType } }\n    };\n  },\n\n  isRealtime: (config) => {\n    return (config as any).mode === 'free-run';\n  },\n\n  shouldRecompileOnConfigChange: (config) => {\n    return true; // Recompile on any change\n  },\n\n  createState: (config): MathRandomState => {\n    // config here is compiled data? No, createState receives executed data?\n    // Actually GraphExecutor calls createState with node.config if available.\n    // Wait, GraphExecutor `initializeState` uses `node.config`.\n    // We should rely on normalized config if possible, but state init happens once.\n    // We can re-extract from `config`.\n    const conf = config as any;\n    const seed = conf?.seed || 12345;\n    const generator = lcg(seed);\n    // Pre-warm?\n    return {\n      generator,\n      currentValue: generator.next() // Initial value\n    };\n  },\n  execute: (inputs, config, context, state) => {\n    // strict strictness\n    const mode = config.mode || 'on-trigger';\n    const stream = inputs.trigger as MidiEvent[];\n\n    if (mode === 'free-run') {\n      // Generate new value every frame\n      state.currentValue = state.generator.next();\n    } else if (Array.isArray(stream)) {\n      // mode === 'on-trigger'\n      for (const e of stream) {\n        if (e.type === 'note_on' && (e.velocity ?? 0) > 0) {\n          // Logic: Advance generator on every Note On.\n          // Effectively outputs the last generated value for this frame.\n          state.currentValue = state.generator.next();\n        }\n      }\n    }\n\n    return { value: state.currentValue };\n  }\n});\n\nregisterNode(random);\n","import { defineNode, registerNode, InspectorFieldDef } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType, numberType } from \"../../structor/std-types\";\nimport { NumberType } from \"../../structor/type-helpers\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\nconst MidiInputFields: InspectorFieldDef[] = [\n  { type: 'string', label: 'Device ID', path: 'deviceId', placeholder: 'Optional Device ID' }\n];\n\nconst MidiCcInputFields: InspectorFieldDef[] = [\n  { type: 'number', label: 'Channel', path: 'channel', min: 1, max: 16, step: 1 },\n  { type: 'number', label: 'CC', path: 'cc', min: 0, max: 127, step: 1 },\n  { type: 'string', label: 'Device ID', path: 'deviceId', placeholder: 'Optional Device ID' }\n];\n\n// strict type inference\nexport const midiInputNode = defineNode({\n  id: \"midi.input\",\n  version: \"1.0.0\",\n  displayName: \"MIDI Input\",\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['midi', 'input', 'source'],\n    description: 'Reads raw MIDI messages from a specific device.'\n  },\n  inputs: {},\n  config: {\n    deviceId: { kind: 'atomic', type: 'string', optional: true }\n  },\n  outputs: {\n    stream: midiStreamType\n  },\n  ui: { inspector: { fields: MidiInputFields } },\n  isRealtime: () => true,\n  execute: (inputs, config, context) => {\n    const midiEvents = context.midi?.events as MidiEvent[] | undefined;\n    const deviceId = config.deviceId;\n\n    if (midiEvents && deviceId) {\n      // Filter by device ID\n      const filtered = midiEvents.filter(e => e.deviceId === deviceId);\n      return { stream: filtered };\n    }\n\n    return { stream: midiEvents || [] };\n  },\n  compileConfig: (uiConfig: { deviceId?: string }) => ({\n    deviceId: uiConfig.deviceId\n  }),\n});\n\n// strict type inference\nexport const midiCcInputNode = defineNode({\n  id: \"midi.cc.input\",\n  version: \"1.0.0\",\n  displayName: \"MIDI CC Input\",\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['midi', 'cc', 'input'],\n    description: 'Reads a MIDI CC value directly from the environment.'\n  },\n  inputs: {},\n  config: {\n    channel: numberType,\n    cc: numberType,\n    deviceId: { kind: 'atomic', type: 'string', optional: true }\n  },\n  outputs: {\n    value: numberType\n  },\n  ui: { inspector: { fields: MidiCcInputFields } },\n  isRealtime: () => true,\n  execute: (inputs, config, context) => {\n    const channel = config.channel || 1;\n    const cc = config.cc || 0;\n    const deviceId = config.deviceId;\n\n    const key = `${channel}:${cc}`;\n    const value = context.midi?.values.get(key) ?? 0;\n\n    return { value };\n  },\n  compileConfig: (uiConfig: { channel?: number, cc?: number, deviceId?: string }) => ({\n    channel: uiConfig.channel ?? 1,\n    cc: uiConfig.cc ?? 0,\n    deviceId: uiConfig.deviceId\n  }),\n});\n\nregisterNode(midiInputNode);\nregisterNode(midiCcInputNode);\n","import { defineNode, registerNode, InspectorFieldDef } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType, numberType } from \"../../structor/std-types\";\nimport { NumberType } from \"../../structor/type-helpers\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\ninterface MidiStreamInput {\n  stream: MidiEvent[];\n}\ninterface MidiCcInputs extends MidiStreamInput { }\n\nconst MidiCcFields: InspectorFieldDef[] = [\n  { type: 'number', label: 'Channel', path: 'channel', min: 1, max: 16, step: 1 },\n  { type: 'number', label: 'CC', path: 'cc', min: 0, max: 127, step: 1 }\n];\n\n// strict type inference\nexport const midiCcNode = defineNode({\n  id: \"midi.cc\",\n  version: \"1.0.0\",\n  displayName: \"MIDI CC\",\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['midi', 'cc', 'control change'],\n    description: 'Reads MIDI Control Change messages from a stream.'\n  },\n  inputs: {\n    stream: { type: midiStreamType, allowMultiConnection: true }\n  },\n  autoBroadcast: {\n    stream: { combine: { reduce: 'flatten' } }\n  },\n  config: {\n    channel: numberType,\n    cc: numberType,\n  },\n  outputs: {\n    value: numberType\n  },\n  ui: { inspector: { fields: MidiCcFields } },\n  createState: (): { value: number } => ({ value: 0 }),\n  execute: (inputs, config, context, state) => {\n    // Inputs are strictly typed\n    const channel = config.channel || 1;\n    const targetCc = config.cc || 0;\n\n    const stream = (inputs.stream || []) as MidiEvent[];\n\n    if (stream && Array.isArray(stream)) {\n      for (const event of stream) {\n        if (event.type === 'cc' && event.channel === channel && event.cc === targetCc) {\n          state.value = (event.value ?? 0);\n        }\n      }\n    }\n\n    return { value: state.value };\n  },\n  compileConfig: (uiConfig: { channel?: number, cc?: number }) => ({\n    channel: uiConfig.channel ?? 1,\n    cc: uiConfig.cc ?? 0\n  }),\n});\n\nregisterNode(midiCcNode);\n","import { defineNode, registerNode, InspectorFieldDef } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType, numberType } from \"../../structor/std-types\";\nimport { NumberType } from \"../../structor/type-helpers\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\ninterface MidiStreamInput {\n  stream: MidiEvent[];\n}\ninterface MidiNoteInputs extends MidiStreamInput { }\n\nconst MidiNoteFields: InspectorFieldDef[] = [\n  { type: 'number', label: 'Channel', path: 'channel', min: 1, max: 16, step: 1 },\n  { type: 'number', label: 'Note', path: 'note', min: 0, max: 127, step: 1 }\n];\n\n// strict type inference\nexport const midiNoteNode = defineNode({\n  id: \"midi.note\",\n  version: \"1.0.0\",\n  displayName: \"MIDI Note\",\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['midi', 'note', 'keyboard'],\n    description: 'Reads MIDI Note messages from a stream.'\n  },\n  inputs: {\n    stream: { type: midiStreamType, allowMultiConnection: true }\n  },\n  autoBroadcast: {\n    stream: { combine: { reduce: 'flatten' } }\n  },\n  config: {\n    channel: numberType,\n    note: numberType,\n  },\n  outputs: {\n    note: { kind: 'atomic', type: 'number', optional: true },\n    velocity: numberType,\n    gate: numberType\n  },\n  ui: { inspector: { fields: MidiNoteFields } },\n  createState: (): { velocity: number, gate: number } => ({ velocity: 0, gate: 0 }),\n  execute: (inputs, config, context, state) => {\n    // Inputs are strictly typed\n    const channel = config.channel || 1;\n    const targetNote = config.note || 60;\n\n    const stream = (inputs.stream || []) as MidiEvent[];\n\n    if (stream && Array.isArray(stream)) {\n      for (const event of stream) {\n        if (event.channel === channel) {\n          if (event.type === 'note_on' && event.note === targetNote) {\n            state.velocity = (event.velocity ?? 0);\n            state.gate = 1;\n          } else if (event.type === 'note_off' && event.note === targetNote) {\n            state.gate = 0;\n          }\n        }\n      }\n    }\n\n    return {\n      note: state.gate ? targetNote : null,\n      velocity: state.velocity,\n      gate: state.gate\n    };\n  },\n  compileConfig: (uiConfig: { channel?: number, note?: number }) => ({\n    channel: uiConfig.channel ?? 1,\n    note: uiConfig.note ?? 60\n  }),\n});\n\nregisterNode(midiNoteNode);\n","import { defineNode, registerNode, InspectorFieldDef } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType, numberType } from \"../../structor/std-types\";\nimport { NumberType } from \"../../structor/type-helpers\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\ninterface MidiStreamInput {\n  stream: MidiEvent[];\n}\ninterface MidiToMonoInputs extends MidiStreamInput { }\n\nconst MidiToMonoFields: InspectorFieldDef[] = [\n  { type: 'number', label: 'Channel', path: 'channel', min: 1, max: 16, step: 1 },\n  { type: 'number', label: 'Root Note', path: 'rootNote', min: 0, max: 127, step: 1 },\n  {\n    type: 'select', label: 'Priority', path: 'priority', options: [\n      { label: 'Last Note', value: 'last' },\n      { label: 'Low Note', value: 'low' },\n      { label: 'High Note', value: 'high' }\n    ]\n  }\n];\n\n// strict type inference\nexport const midiToMonoNode = defineNode({\n  id: \"midi.to_mono\",\n  version: \"1.0.0\",\n  displayName: \"MIDI to Mono\",\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['midi', 'mono', 'converter'],\n    description: 'Converts a polyphonic MIDI stream to a monophonic note signal.'\n  },\n  inputs: {\n    stream: { type: midiStreamType, allowMultiConnection: true }\n  },\n  autoBroadcast: {\n    stream: { combine: { reduce: 'flatten' } }\n  },\n  config: {\n    channel: numberType,\n    rootNote: numberType,\n    priority: { kind: 'atomic', type: 'string', optional: true }\n  },\n  outputs: {\n    note: { kind: 'atomic', type: 'number', optional: true },\n    velocity: numberType,\n    gate: numberType,\n    frequency: numberType\n  },\n  ui: { inspector: { fields: MidiToMonoFields } },\n  createState: (): { activeNotes: { note: number, velocity: number }[], gate: number } => ({\n    activeNotes: [],\n    gate: 0\n  }),\n  execute: (inputs, config, context, state) => {\n    // Inputs are strictly typed\n    const channel = config.channel || 1;\n    const rootNote = config.rootNote ?? 60;\n    const stream = (inputs.stream || []) as MidiEvent[];\n\n    if (!state.activeNotes) {\n      state.activeNotes = [];\n    }\n\n    if (stream && Array.isArray(stream)) {\n      for (const event of stream) {\n        if (event.channel === channel) {\n          if (event.type === 'note_on') {\n            // Remove existing instance of this note to move it to top (retrigger)\n            state.activeNotes = state.activeNotes.filter(n => n.note !== event.note);\n            state.activeNotes.push({ note: event.note!, velocity: (event.velocity ?? 0) });\n          } else if (event.type === 'note_off') {\n            state.activeNotes = state.activeNotes.filter(n => n.note !== event.note);\n          }\n        }\n      }\n    }\n\n    const activeNote = state.activeNotes.length > 0 ? state.activeNotes[state.activeNotes.length - 1] : null;\n\n    if (activeNote) {\n      state.gate = 1;\n      const relativeNote = activeNote.note - rootNote;\n      // Simple frequency calculation: 440 * 2^((note - 69) / 12)\n      const frequency = 440 * Math.pow(2, (activeNote.note - 69) / 12);\n\n      return {\n        note: relativeNote,\n        velocity: activeNote.velocity,\n        gate: 1,\n        frequency: frequency\n      };\n    } else {\n      state.gate = 0;\n      return {\n        note: null,\n        velocity: 0,\n        gate: 0,\n        frequency: 0\n      };\n    }\n  },\n  compileConfig: (uiConfig: { channel?: number, rootNote?: number, priority?: string }) => ({\n    channel: uiConfig.channel ?? 1,\n    rootNote: uiConfig.rootNote ?? 60,\n    priority: uiConfig.priority ?? 'last'\n  }),\n});\n\nregisterNode(midiToMonoNode);\n","import { defineNode, registerNode, InspectorFieldDef } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType, numberType } from \"../../structor/std-types\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\ninterface MidiStreamInput {\n  stream: MidiEvent[];\n}\ninterface MidiFilterInputs extends MidiStreamInput {\n  channel?: number;\n  note?: number;\n}\n\nconst MidiNoteFields: InspectorFieldDef[] = [\n  { type: 'number', label: 'Channel', path: 'channel', min: 1, max: 16, step: 1 },\n  { type: 'number', label: 'Note', path: 'note', min: 0, max: 127, step: 1 }\n];\n\n// midi.filter: uses inputs, config is empty\n// strict type inference\nexport const midiFilterNode = defineNode({\n  id: \"midi.filter\",\n  version: \"1.0.0\",\n  displayName: \"MIDI Filter\",\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['midi', 'filter', 'note'],\n    description: 'Filters MIDI events, allowing only specific Note On/Off messages through.'\n  },\n  inputs: {\n    stream: { type: midiStreamType, allowMultiConnection: true },\n    channel: { type: numberType, description: 'MIDI Channel (1-16)', defaultValue: 1 },\n    note: { type: numberType, description: 'Note Number (0-127)', defaultValue: 60 }\n  },\n  config: {},\n  outputs: {\n    stream: midiStreamType\n  },\n  autoBroadcast: {\n    stream: { combine: { reduce: 'flatten' } }\n  },\n  ui: { inspector: { fields: MidiNoteFields } }, // Reuse MidiNoteFields\n  execute: (inputs, config) => {\n    // Virtual Inputs are handled by compileConfig merging into config, OR by direct input injection if strict\n    // But here 'channel' and 'note' are inputs with defaults.\n    // In strict mode, 'inputs' has 'channel' and 'note'.\n    const channel = inputs.channel ?? 1;\n    const targetNote = inputs.note ?? 60;\n    const stream = (inputs.stream || []) as MidiEvent[];\n\n    const filteredStream: MidiEvent[] = [];\n\n    if (stream && Array.isArray(stream)) {\n      for (const event of stream) {\n        if (event.channel === channel) {\n          if (event.type === 'note_on' || event.type === 'note_off') {\n            if (event.note === targetNote) {\n              filteredStream.push(event);\n            }\n          }\n        }\n      }\n    }\n\n    return { stream: filteredStream };\n  },\n  compileConfig: (uiConfig: { channel?: number, note?: number }) => ({\n    // Return values for Virtual Inputs\n    channel: uiConfig.channel ?? 1,\n    note: uiConfig.note ?? 60\n  }),\n});\n\nregisterNode(midiFilterNode);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType, numberType } from \"../../structor/std-types\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\ninterface MidiStreamInput {\n  stream: MidiEvent[];\n}\ninterface MidiPitchInputs extends MidiStreamInput {\n  pitch?: number;\n}\n\n// midi.pitch: uses inputs, config is empty\n// strict type inference\nexport const midiPitchNode = defineNode({\n  id: \"midi.pitch\",\n  version: \"1.0.0\",\n  displayName: \"MIDI Pitch\",\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['midi', 'pitch', 'transpose', 'shift'],\n    description: 'Transposes MIDI Note events by a specified amount.'\n  },\n  inputs: {\n    stream: { type: midiStreamType, allowMultiConnection: true },\n    pitch: { type: numberType, description: 'Pitch shift amount (semitones)', defaultValue: 0, range: [-24, 24] }\n  },\n  config: {},\n  outputs: {\n    stream: midiStreamType\n  },\n  autoBroadcast: {\n    stream: { combine: { reduce: 'flatten' } }\n  },\n  execute: (inputs, config) => {\n    // Inputs drove by generic Logic\n    const shift = (inputs.pitch ?? 0) as number;\n    const stream = inputs.stream || [];\n\n    if (!stream || !Array.isArray(stream)) return { stream: [] };\n\n    const processedStream: MidiEvent[] = stream.map(event => {\n      if (event.type === 'note_on' || event.type === 'note_off') {\n        const newNote = Math.max(0, Math.min(127, Math.floor(event.note + shift)));\n        return { ...event, note: newNote };\n      }\n      return event;\n    });\n\n    return { stream: processedStream };\n  },\n  compileConfig: (uiConfig: { pitch?: number }) => ({\n    pitch: uiConfig.pitch ?? 0\n  }),\n});\n\nregisterNode(midiPitchNode);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType, numberType } from \"../../structor/std-types\";\nimport { NumberType } from \"../../structor/type-helpers\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\ninterface MidiTriggerInputs {\n  trigger: number;\n}\n\n// strict type inference\nexport const midiTriggerNode = defineNode({\n  id: \"midi.trigger\",\n  version: \"1.0.0\",\n  displayName: \"MIDI Trigger\",\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['midi', 'trigger', 'bang', 'button'],\n    description: 'Manually sends a Middle C Note On/Off pair when triggered.'\n  },\n  inputs: {\n    trigger: { type: numberType, description: 'Trigger Signal', suppressInputEditor: true }\n  },\n  config: {\n    pitch: { ...numberType, defaultValue: 60 },\n    velocity: { ...numberType, defaultValue: 1.0, range: [0, 1] },\n    trigger: numberType\n  },\n  outputs: {\n    stream: midiStreamType\n  },\n  createState: (): { lastTrigger: number, initialized: boolean } => ({ lastTrigger: 0, initialized: false }),\n  execute: (inputs, config, context, state) => {\n    // Inputs are strictly typed\n    const pitch = config.pitch || 60;\n    const velocity = config.velocity || 1.0;\n    const trigger = inputs.trigger || 0;\n    const dt = context.clock.dt;\n\n    const stream: MidiEvent[] = [];\n\n    if (!state.initialized) {\n      state.lastTrigger = trigger;\n      state.initialized = true;\n      return { stream };\n    }\n\n    if (trigger > state.lastTrigger) {\n      // Rising Edge: Synchronous Trigger (Note On then Note Off)\n      // Velocity is 0-1 float\n      stream.push({ type: 'note_on', channel: 1, note: pitch, velocity: velocity, deviceId: 'virtual', time: 0 });\n      stream.push({ type: 'note_off', channel: 1, note: pitch, velocity: 0, deviceId: 'virtual', time: 0 });\n      if (context.markSelfDirty) context.markSelfDirty();\n    }\n\n    state.lastTrigger = trigger;\n\n    return { stream };\n  },\n  compileConfig: (uiConfig: { pitch?: number, velocity?: number, trigger?: number }) => ({\n    pitch: uiConfig.pitch ?? 60,\n    velocity: uiConfig.velocity ?? 1.0,\n    trigger: uiConfig.trigger\n  }),\n  ui: {\n    inspector: {\n      fields: [\n        { type: 'button', label: 'Trigger', path: 'trigger', text: 'Bang' },\n        { type: 'number', label: 'Pitch', path: 'pitch', min: 0, max: 127, step: 1, default: 60 },\n        { type: 'number', label: 'Velocity', path: 'velocity', min: 0, max: 1, step: 0.01, default: 1.0 }\n      ]\n    }\n  }\n});\n\nregisterNode(midiTriggerNode);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType } from \"../../structor/std-types\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\ninterface MidiStreamInput {\n  stream: MidiEvent[];\n}\ninterface MidiMergeInputs extends MidiStreamInput { }\n\n// strict type inference\nexport const midiMergeNode = defineNode({\n  id: \"midi.merge\",\n  version: \"1.0.0\",\n  displayName: \"MIDI Merge\",\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['midi', 'merge', 'combine', 'mix'],\n    description: 'Merges multiple MIDI streams into one using auto-broadcast.'\n  },\n  inputs: {\n    stream: { type: midiStreamType, description: 'Input Streams', allowMultiConnection: true }\n  },\n  outputs: {\n    stream: midiStreamType\n  },\n  autoBroadcast: {\n    stream: { combine: { reduce: 'flatten' } }\n  },\n  config: {},\n  execute: (inputs, config, context) => {\n    return { stream: (inputs.stream || []) as MidiEvent[] };\n  },\n  compileConfig: () => ({})\n});\n\nregisterNode(midiMergeNode);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType, numberType } from \"../../structor/std-types\";\nimport { NumberType } from \"../../structor/type-helpers\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\ninterface MidiStreamInput {\n  stream: MidiEvent[];\n}\ninterface MidiSelectInputs extends MidiStreamInput { }\n\n// strict type inference\nexport const midiSelectNode = defineNode({\n  id: \"midi.select\",\n  version: \"1.0.0\",\n  displayName: \"MIDI Select\",\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['midi', 'select', 'router', 'switch', 'demux'],\n    description: 'Routes MIDI events to different ports based on note pitch.'\n  },\n  inputs: {\n    stream: { type: midiStreamType, allowMultiConnection: true }\n  },\n  autoBroadcast: {\n    stream: { combine: { reduce: 'flatten' } }\n  },\n  config: {\n    count: { ...numberType, defaultValue: 4 },\n    root: { ...numberType, defaultValue: 60 },\n    skip: { ...numberType, defaultValue: 1 }\n  },\n  outputs: {},\n  dynamicOutputType: midiStreamType,\n  isRealtime: () => true,\n  computeForwardPorts: (inputTypes, uiConfig: { count?: number, root?: number, skip?: number }, context) => {\n    const count = uiConfig.count || 4;\n    const outputs: any = {};\n\n    for (let i = 0; i < count; i++) {\n      outputs[i.toString()] = { ...midiStreamType, hint: 'midi-stream', description: `Offset ${i}` };\n    }\n    outputs['rem'] = { ...midiStreamType, hint: 'midi-stream', description: 'Remainder' };\n\n    return {\n      inputs: { kind: 'record', fields: { stream: midiStreamType } },\n      outputs: { kind: 'record', fields: outputs }\n    };\n  },\n  shouldRecompileOnConfigChange: (uiConfig) => {\n    return true;\n  },\n  execute: (inputs, config, context) => {\n    const stream = (inputs.stream || []) as MidiEvent[];\n    const count = config.count || 4;\n    const root = config.root || 60;\n    const skip = config.skip || 1;\n\n    const results: Record<string, MidiEvent[]> = {};\n    for (let i = 0; i < count; i++) {\n      results[i.toString()] = [];\n    }\n    results['rem'] = [];\n\n    if (stream && Array.isArray(stream)) {\n      for (const event of stream) {\n        if (event.type === 'note_on' || event.type === 'note_off') {\n          const diff = event.note - root;\n          if (diff >= 0 && (diff % skip) === 0) {\n            const index = diff / skip;\n            if (index >= 0 && index < count) {\n              results[index.toString()].push(event);\n              continue;\n            }\n          }\n          results['rem'].push(event);\n        } else {\n          // Ignore non-note events\n        }\n      }\n    }\n\n    return { ...results };\n  },\n  compileConfig: (uiConfig: { count?: number, root?: number, skip?: number }) => ({\n    count: uiConfig.count ?? 4,\n    root: uiConfig.root ?? 60,\n    skip: uiConfig.skip ?? 1\n  }),\n  ui: {\n    inspector: {\n      fields: [\n        { type: 'number', label: 'Output Count', path: 'count', min: 1, max: 128, step: 1, default: 4 },\n        { type: 'number', label: 'Root Note', path: 'root', min: 0, max: 127, step: 1, default: 60 },\n        { type: 'number', label: 'Skip (Semitones)', path: 'skip', min: 1, max: 24, step: 1, default: 1 }\n      ]\n    }\n  }\n});\n\nregisterNode(midiSelectNode);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType, numberType } from \"../../structor/std-types\";\nimport { AnyType } from \"../../structor/type-helpers\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\ninterface MidiOnChangeInputs {\n  value: any;\n}\ninterface MidiOnChangeConfig {\n  rootNote?: number;\n}\ninterface MidiOnChangeState {\n  lastValue: any;\n}\n\n// using strict inference\nexport const midiOnChangeNode = defineNode({\n  id: \"midi.onchange\",\n  version: \"1.0.0\",\n  displayName: \"MIDI On Change\",\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['midi', 'trigger', 'change', 'delta'],\n    description: 'Triggers a note when input value changes.'\n  },\n  inputs: {\n    value: { type: AnyType, description: \"Input Value\" }\n  },\n  config: {\n    rootNote: { ...numberType, defaultValue: 60 }\n  },\n  outputs: {\n    stream: midiStreamType\n  },\n  ui: {\n    inspector: {\n      fields: [\n        { type: 'number', label: 'Root Note', path: 'rootNote', min: 0, max: 127, step: 1, default: 60 }\n      ]\n    }\n  },\n  isRealtime: () => true,\n  createState: (): MidiOnChangeState => ({ lastValue: undefined }),\n  execute: (inputs, config, context, state) => {\n    // inputs.value is inferred as any (AnyType)\n    const value = inputs.value;\n    // console.log('MidiOnChange Exec:', { value, lastValue: state.lastValue });\n    const root = config.rootNote ?? 60;\n    const stream: MidiEvent[] = [];\n\n    let changed = false;\n    if (typeof value === 'number' && typeof state.lastValue === 'number') {\n      if (Math.abs(value - state.lastValue) > 1e-5) {\n        changed = true;\n      }\n    } else {\n      if (value !== state.lastValue) {\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      // Trigger Note On -> Note Off pair immediately\n      stream.push({ type: 'note_on', note: root, velocity: 1.0, channel: 1, time: 0, deviceId: 'onchange' });\n      stream.push({ type: 'note_off', note: root, velocity: 0, channel: 1, time: 0, deviceId: 'onchange' });\n      state.lastValue = value;\n    } else if (state.lastValue === undefined && value !== undefined) {\n      // Initialize state silently\n      state.lastValue = value;\n    }\n\n    return { stream };\n  },\n  compileConfig: (uiConfig: MidiOnChangeConfig) => ({\n    rootNote: uiConfig.rootNote ?? 60\n  })\n});\n\nregisterNode(midiOnChangeNode);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType, numberType } from \"../../structor/std-types\";\nimport { StructorType } from \"../../structor/structor\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\ninterface MidiOnRangeInputs {\n  value: number;\n  start?: number;\n  end?: number;\n  [key: string]: number | undefined; // w1, w2...\n}\ninterface MidiOnRangeConfig {\n  rootNote?: number;\n  zoneCount?: number;\n  noteSkip?: number;\n}\ninterface MidiOnRangeState {\n  activeZoneIndex: number | null;\n}\n\nconst weightInputs: Record<string, any> = {};\nfor (let i = 1; i <= 16; i++) {\n  weightInputs[`w${i}`] = { type: numberType, defaultValue: 1.0, optional: true, description: `Weight ${i}` };\n}\n\nexport const midiOnRangeNode = defineNode({\n  id: \"midi.onrange\",\n  version: \"1.0.0\",\n  displayName: \"MIDI On Range\",\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['midi', 'trigger', 'range', 'zone'],\n    description: 'Triggers notes based on value position in weighted zones.'\n  },\n  inputs: {\n    value: { type: numberType, description: \"Input Value\" },\n    start: { type: numberType, defaultValue: 0 },\n    end: { type: numberType, defaultValue: 1 },\n    ...weightInputs\n  },\n  config: {\n    rootNote: { ...numberType, defaultValue: 60, description: 'Root Note' },\n    zoneCount: { ...numberType, defaultValue: 1, description: 'Number of Zones' },\n    noteSkip: { ...numberType, defaultValue: 1 }\n  },\n  outputs: {\n    stream: midiStreamType\n  },\n  ui: {\n    inspector: {\n      fields: [\n        { type: 'number', label: 'Root Note', path: 'rootNote', min: 0, max: 127, step: 1, default: 60 },\n        { type: 'number', label: 'Zone Count', path: 'zoneCount', min: 1, max: 16, step: 1, default: 1 },\n        { type: 'number', label: 'Note Skip', path: 'noteSkip', min: 1, max: 12, step: 1, default: 1 }\n      ]\n    }\n  },\n  isRealtime: () => true,\n  createState: (): MidiOnRangeState => ({ activeZoneIndex: null }),\n\n  computeForwardPorts: (inputTypes, uiConfig: MidiOnRangeConfig) => {\n    const zoneCount = uiConfig.zoneCount ?? 1;\n    const fields: Record<string, StructorType> = {\n      value: { ...numberType },\n      start: { ...numberType, defaultValue: 0 },\n      end: { ...numberType, defaultValue: 1 }\n    };\n\n    if (zoneCount > 1) {\n      for (let i = 1; i <= zoneCount; i++) {\n        fields[`w${i}`] = { ...numberType, defaultValue: 1.0, description: `Weight ${i}` };\n      }\n    }\n\n    return {\n      inputs: { kind: 'record', fields },\n      outputs: { kind: 'record', fields: { stream: midiStreamType } }\n    };\n  },\n  shouldRecompileOnConfigChange: () => true,\n\n  execute: (inputs, config, context, state) => {\n    // Inputs are strictly typed (including w1..w16 from weightInputs + any extras)\n    // Dynamic inputs (w1..w16) are in `weightInputs` but `inputs` is inferred from `defineNode`'s `inputs`.\n    // Since `weightInputs` is spread into `inputs`, inference sees them.\n    // console.log('MidiOnRange Exec Inputs:', inputs);\n    const value = inputs.value ?? 0;\n    const start = inputs.start ?? 0;\n    const end = inputs.end ?? 1;\n\n    const root = config.rootNote ?? 60;\n    const count = config.zoneCount ?? 1;\n    const skip = config.noteSkip ?? 1;\n\n    // Normalize range\n    let actualStart = start;\n    let actualEnd = end;\n    if (actualEnd < actualStart) {\n      actualEnd = start;\n      actualStart = end;\n    }\n\n    const stream: MidiEvent[] = [];\n\n    // Check if in range\n    if (value >= actualStart && value <= actualEnd) {\n      // Inside Range. Determine Zone.\n      let targetZone = 0;\n\n      if (count > 1) {\n        const weights: number[] = [];\n        let totalWeight = 0;\n        for (let i = 1; i <= count; i++) {\n          const rawW = inputs[`w${i}` as keyof MidiOnRangeInputs];\n          let w: any = rawW;\n          if (w && typeof w === 'object' && 'value' in w) {\n            w = w.value;\n          }\n          w = w ?? 1.0;\n          if (typeof w !== 'number') w = 1.0;\n\n          weights.push(w);\n          totalWeight += w;\n        }\n\n        if (totalWeight <= 0) {\n          // Fallback\n          targetZone = 0;\n        } else {\n          const rangeSpan = actualEnd - actualStart;\n          // Normalize value to 0-totalWeight\n          // value = start + (t * span)\n          // t = (value - start) / span\n          const t = (rangeSpan === 0) ? 0 : (value - actualStart) / rangeSpan;\n          const weightPos = t * totalWeight;\n\n          let currentW = 0;\n          for (let i = 0; i < count; i++) {\n            currentW += weights[i];\n            if (weightPos <= currentW) {\n              targetZone = i;\n              break;\n            }\n          }\n          // Clamp to last zone if floating point error pushes it slightly over\n          if (targetZone >= count) targetZone = count - 1;\n        }\n      } else {\n        targetZone = 0; // Single zone\n      }\n\n      // State Update Logic\n      if (state.activeZoneIndex === null) {\n        // Entered Range\n        const note = root + (targetZone * skip);\n        stream.push({ type: 'note_on', note, velocity: 1.0, channel: 1, time: 0, deviceId: 'onrange' });\n        state.activeZoneIndex = targetZone;\n      } else if (state.activeZoneIndex !== targetZone) {\n        // Changed Zone\n        const oldNote = root + (state.activeZoneIndex * skip);\n        stream.push({ type: 'note_off', note: oldNote, velocity: 0, channel: 1, time: 0, deviceId: 'onrange' });\n\n        const newNote = root + (targetZone * skip);\n        stream.push({ type: 'note_on', note: newNote, velocity: 1.0, channel: 1, time: 0, deviceId: 'onrange' });\n        state.activeZoneIndex = targetZone;\n      }\n\n    } else {\n      // Outside Range\n      if (state.activeZoneIndex !== null) {\n        // Exited\n        const oldNote = root + (state.activeZoneIndex * skip);\n        stream.push({ type: 'note_off', note: oldNote, velocity: 0, channel: 1, time: 0, deviceId: 'onrange' });\n        state.activeZoneIndex = null;\n      }\n    }\n\n    return { stream };\n  },\n  compileConfig: (uiConfig: MidiOnRangeConfig) => ({\n    rootNote: uiConfig.rootNote ?? 60,\n    zoneCount: uiConfig.zoneCount ?? 1,\n    noteSkip: uiConfig.noteSkip ?? 1\n  })\n});\n\nregisterNode(midiOnRangeNode);\n","\nimport { InspectorFieldDef } from \"../structor/node-helpers\";\n\nexport const TimeBaseModeField: InspectorFieldDef = {\n  type: 'tab-bar',\n  label: 'Mode',\n  path: 'mode',\n  options: [\n    { label: 'Time', value: 'time' },\n    { label: 'Beats', value: 'beats' }\n  ],\n  default: 'time'\n};\n\nexport const BeatDenomField: InspectorFieldDef = {\n  type: 'tab-bar',\n  label: 'Beat Denom',\n  path: 'beatDenom',\n  options: [\n    { label: '1/64', value: 0.015625 },\n    { label: '1/32', value: 0.03125 },\n    { label: '1/16', value: 0.0625 },\n    { label: '1/8', value: 0.125 },\n    { label: '1/4', value: 0.25 },\n    { label: '1/2', value: 0.5 },\n    { label: '1/1', value: 1.0 },\n  ],\n  default: 0.25 // Quarter note default\n};\n","import { defineNode, registerNode, InspectorFieldDef } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType, numberType, timeBaseEnum } from \"../../structor/std-types\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\ninterface PendingEvent {\n  event: MidiEvent;\n  releaseTime: number; // Absolute time or Beat\n}\n\ninterface MidiDelayState {\n  queue: PendingEvent[];\n}\n\nimport { TimeBaseModeField } from \"../shared-inspector-fields\";\n\nconst MidiDelayFields: InspectorFieldDef[] = [\n  TimeBaseModeField\n];\n\nexport const midiDelayNode = defineNode({\n  id: \"midi.delay\",\n  version: \"1.0.0\",\n  displayName: \"MIDI Delay\",\n  metadata: {\n    category: NodeCategory.Utility,\n    keywords: ['midi', 'delay', 'time', 'beats'],\n    description: 'Delays MIDI events by a specified duration.'\n  },\n  inputs: {\n    stream: { type: midiStreamType, allowMultiConnection: true },\n    duration: { ...numberType, defaultValue: 0.25 }\n  },\n  config: {\n    mode: { ...timeBaseEnum, defaultValue: 'time' }\n  },\n  autoBroadcast: {\n    stream: { combine: { reduce: 'flatten' } }\n  },\n  outputs: {\n    stream: midiStreamType\n  },\n  ui: {\n    inspector: { fields: MidiDelayFields }\n  },\n  isRealtime: () => true, // Always run to check queue\n  createState: (): MidiDelayState => ({ queue: [] }),\n  execute: (inputs, config, context, state) => {\n    const stream = (inputs.stream || []) as MidiEvent[];\n    const duration = inputs.duration || 0;\n    const mode = config.mode || 'time';\n\n    // Current Time Base\n    let now = 0;\n    if (mode === 'beats') {\n      now = context.clock.beat;\n    } else {\n      now = context.time || 0;\n    }\n\n    // Defensive initialization\n    if (!state.queue) {\n      state.queue = [];\n    }\n\n    // 1. Enqueue new events\n    if (stream && Array.isArray(stream)) {\n      for (const event of stream) {\n        state.queue.push({\n          event,\n          releaseTime: now + duration\n        });\n      }\n    }\n\n    // 2. Process Queue\n    const outputStream: MidiEvent[] = [];\n    const remainingQueue: PendingEvent[] = [];\n\n    for (const item of state.queue) {\n      if (item.releaseTime <= now) {\n        outputStream.push(item.event);\n      } else {\n        remainingQueue.push(item);\n      }\n    }\n\n    state.queue = remainingQueue;\n\n    return { stream: outputStream };\n  },\n  compileConfig: (uiConfig: { mode?: string }) => ({\n    mode: uiConfig.mode ?? 'time'\n  })\n});\n\nregisterNode(midiDelayNode);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType, numberType } from \"../../structor/std-types\";\nimport { MidiEvent } from \"../../io/midi/types\";\n\n// strict type inference\nexport const midiIsTriggerNode = defineNode({\n  id: \"midi.istrigger\",\n  version: \"1.0.0\",\n  displayName: \"MIDI Is Trigger\",\n  metadata: {\n    category: NodeCategory.Logic,\n    keywords: ['midi', 'check', 'trigger', 'gate'],\n    description: 'Outputs 1 if the stream contains any Note On event, 0 otherwise.'\n  },\n  inputs: {\n    stream: { type: midiStreamType, allowMultiConnection: true }\n  },\n  autoBroadcast: {\n    stream: { combine: { reduce: 'flatten' } }\n  },\n  outputs: {\n    result: numberType\n  },\n  createState: () => ({}),\n  execute: (inputs, config, context, state) => {\n    const stream = (inputs.stream || []) as MidiEvent[];\n    let hasNoteOn = 0;\n\n    if (stream && Array.isArray(stream)) {\n      for (const event of stream) {\n        if (event.type === 'note_on') {\n          hasNoteOn = 1;\n          break;\n        }\n      }\n    }\n\n    return { result: hasNoteOn };\n  }\n});\n\nregisterNode(midiIsTriggerNode);\n","\nimport { defineNode, registerNode, InspectorFieldDef } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { midiStreamType, numberType, timeBaseEnum } from \"../../structor/std-types\";\nimport { MidiEvent } from \"../../io/midi/types\";\nimport { TimeBaseModeField, BeatDenomField } from \"../shared-inspector-fields\";\n\ninterface MetronomeState {\n  lastTriggerTime: number; // Absolute time or Beat\n  noteActive: boolean;\n}\n\nconst MetronomeFields: InspectorFieldDef[] = [\n  TimeBaseModeField,\n  BeatDenomField,\n  {\n    type: 'number',\n    label: 'Note',\n    path: 'note',\n    min: 0,\n    max: 127,\n    default: 60\n  }\n];\n\nexport const midiMetronomeNode = defineNode({\n  id: \"midi.metronome\",\n  version: \"1.0.0\",\n  displayName: \"Metronome\",\n  metadata: {\n    category: NodeCategory.Utility,\n    keywords: ['midi', 'metronome', 'clock', 'beat', 'trigger'],\n    description: 'Generates MIDI note events at regular intervals.'\n  },\n  inputs: {\n    duration: { ...numberType, defaultValue: 1.0, description: 'Interval duration (seconds or beats)', min: 0.0, max: 4.0 }\n  },\n  config: {\n    mode: { ...timeBaseEnum, defaultValue: 'time' },\n    beatDenom: { ...numberType, defaultValue: 0.25 },\n    note: { ...numberType, defaultValue: 60 }\n  },\n  outputs: {\n    stream: midiStreamType\n  },\n  ui: {\n    inspector: { fields: MetronomeFields }\n  },\n  isRealtime: () => true,\n  createState: (): MetronomeState => ({ lastTriggerTime: -99999, noteActive: false }),\n  execute: (inputs, config, context, state) => {\n    const durationInput = inputs.duration || 1.0;\n    const mode = config.mode || 'time';\n    const beatDenom = config.beatDenom || 0.25;\n    const noteNumber = config.note || 60;\n\n    let now = 0;\n    let interval = durationInput;\n\n    if (mode === 'beats') {\n      now = context.clock.beat;\n      // Quantize interval. `durationInput` is in multiples of `beatDenom`.\n      const steps = Math.round(durationInput);\n      interval = steps * beatDenom * 4; // Beat number (context.clock.beat) assumes 4 beats per bar\n\n      if (interval <= 0) interval = beatDenom; // Prevent infinite loop / zero interval\n    } else {\n      now = context.time || 0;\n    }\n\n    const outputStream: MidiEvent[] = [];\n\n    // Initialize state\n    if (state.lastTriggerTime === -99999) {\n      state.lastTriggerTime = now;\n      return { stream: [] };\n    }\n\n    const prev = state.lastTriggerTime;\n\n    // Calculate expected trigger points between prev and now.\n    // Range: (prev, now]\n    // Trigger points are k * interval.\n\n    const startStep = Math.floor(prev / interval);\n    const endStep = Math.floor(now / interval);\n\n    // If endStep > startStep, we crossed one or more boundaries.\n    const triggers = endStep - startStep;\n\n    for (let i = 1; i <= triggers; i++) {\n      const triggerTime = (startStep + i) * interval;\n\n      // Note On\n      outputStream.push({\n        type: 'note_on',\n        deviceId: 'metronome',\n        channel: 1,\n        note: noteNumber,\n        velocity: 1.0,\n        time: 0 // Immediate execution relative to block\n      });\n\n      // Note Off (immediately after)\n      outputStream.push({\n        type: 'note_off',\n        deviceId: 'metronome',\n        channel: 1,\n        note: noteNumber,\n        velocity: 0,\n        time: 0\n      });\n    }\n\n    state.lastTriggerTime = now;\n\n    return { stream: outputStream };\n  },\n  compileConfig: (uiConfig: any) => ({\n    mode: uiConfig.mode ?? 'time',\n    beatDenom: uiConfig.beatDenom ?? 0.25,\n    note: uiConfig.note ?? 60\n  })\n});\n\nregisterNode(midiMetronomeNode);\n","\nimport { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { NodeCategory } from \"../../structor/structor\";\nimport { numberType } from \"../../structor/std-types\";\n\n// --- Time Node ---\nexport const timeNode = defineNode({\n  id: \"time.time\",\n  version: \"1.0.0\",\n  displayName: \"Time\",\n  metadata: {\n    category: NodeCategory.Utility,\n    keywords: ['time', 'seconds', 'clock'],\n    description: 'Outputs the current execution time in seconds.'\n  },\n  inputs: {},\n  outputs: {\n    time: numberType,\n    delta: numberType\n  },\n  isRealtime: () => true,\n  execute: (inputs, config, context) => {\n    return {\n      time: context.time || 0,\n      delta: context.clock.dt || 0\n    };\n  }\n});\n\n// --- Beat Node ---\nexport const beatNode = defineNode({\n  id: \"time.beat\",\n  version: \"1.0.0\",\n  displayName: \"Beat\",\n  metadata: {\n    category: NodeCategory.Utility,\n    keywords: ['beat', 'bar', 'clock', 'tempo'],\n    description: 'Outputs the current beat number.'\n  },\n  inputs: {},\n  outputs: {\n    beat: numberType,\n    delta: numberType\n  },\n  isRealtime: () => true,\n  createState: () => ({ lastBeat: -1 }),\n  execute: (inputs, config, context, state) => {\n    const currentBeat = context.clock.beat || 0;\n\n    let delta = 0;\n    if (state.lastBeat >= 0) {\n      delta = currentBeat - state.lastBeat;\n    }\n    state.lastBeat = currentBeat;\n\n    return {\n      beat: currentBeat,\n      delta: delta\n    };\n  }\n});\n\n// Register\nregisterNode(timeNode);\nregisterNode(beatNode);\n","import { defineType } from \"../../structor/type-helpers\";\nimport { sequenceStructorType } from \"../../structor/std-types\";\n\nexport const manySequencesType = defineType({\n  kind: \"array\",\n  size: \"dynamic\", // Technically Array<Sequence>\n  element: sequenceStructorType\n});\n\nexport const layerOutputStructorType = defineType({ kind: \"atomic\", type: \"number\" });\n","import { defineNode, registerNode, InspectorFieldDef } from \"../../structor/node-helpers\";\nimport { NumberType } from \"../../structor/type-helpers\";\nimport { numberType, sequenceStructorType } from \"../../structor/std-types\";\nimport { Step } from \"./envelope-generator\";\n\nconst SEQUENCE_LENGTH = 16;\n\nconst RhythmicFields: InspectorFieldDef[] = [\n  { type: 'number', label: 'Target Note', path: 'targetNote' }\n];\n\nexport const rhythmicGenerator = defineNode({\n  id: \"nicepattern.rhythmic_generator\",\n  version: \"1.0.0\",\n  displayName: \"Rhythmic Generator\",\n  metadata: {\n    category: 'NicePattern',\n    keywords: ['rhythm', 'generator', 'sequence', 'euclidean'],\n    description: 'Generates a rhythmic sequence based on density.'\n  },\n  config: { targetNote: numberType },\n  inputs: { density: { ...numberType, defaultValue: 0.5 } },\n  outputs: { seq_out: sequenceStructorType },\n  ui: { inspector: { fields: RhythmicFields } },\n  execute: (inputs, config, context) => {\n    const targetNote = config.targetNote || 60;\n    const density = inputs.density ?? 0.5;\n\n    const sequence: Step[] = [];\n    const numEvents = Math.round(density * SEQUENCE_LENGTH);\n    for (let i = 0; i < SEQUENCE_LENGTH; i++) {\n      if ((i * numEvents) % SEQUENCE_LENGTH < numEvents) {\n        sequence.push({ noteIndex: targetNote, velocity: 1.0, hold: false });\n      } else {\n        sequence.push({ noteIndex: null, velocity: 0, hold: false });\n      }\n    }\n    return { seq_out: sequence };\n  },\n  compileConfig: (uiConfig: { targetNote?: number }) => ({\n    targetNote: uiConfig.targetNote ?? 60\n  }),\n});\n\nregisterNode(rhythmicGenerator);\n","export class SeededRandom {\n  private state: number;\n\n  constructor(seed: number) {\n    this.state = seed;\n  }\n\n  // Mulberry32 algorithm\n  next(): number {\n    let t = (this.state += 0x6D2B79F5);\n    t = Math.imul(t ^ (t >>> 15), t | 1);\n    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n  }\n\n  nextRange(min: number, max: number): number {\n    return Math.floor(this.next() * (max - min + 1)) + min;\n  }\n}\n","import { defineNode, registerNode, InspectorFieldDef } from \"../../structor/node-helpers\";\nimport { NumberType } from \"../../structor/type-helpers\";\nimport { numberType, sequenceStructorType } from \"../../structor/std-types\";\nimport { SeededRandom } from \"./utils\";\nimport { Step } from \"./envelope-generator\";\n\nconst SEQUENCE_LENGTH = 16;\n\nconst ChaosFields: InspectorFieldDef[] = [\n  { type: 'number', label: 'Min Note', path: 'minNote' },\n  { type: 'number', label: 'Max Note', path: 'maxNote' },\n  { type: 'number', label: 'Seed', path: 'seed' }\n];\n\nexport const chaosGenerator = defineNode({\n  id: \"nicepattern.chaos_generator\",\n  version: \"1.0.0\",\n  displayName: \"Chaos Generator\",\n  metadata: {\n    category: 'NicePattern',\n    keywords: ['chaos', 'random', 'generator', 'sequence', 'stochastic'],\n    description: 'Generates a random sequence of notes.'\n  },\n  config: { minNote: numberType, maxNote: numberType, seed: numberType },\n  inputs: { density: { ...numberType, defaultValue: 0.5 } },\n  outputs: { seq_out: sequenceStructorType },\n  ui: { inspector: { fields: ChaosFields } },\n  execute: (inputs, config, context) => {\n    // using strict inference\n    const { minNote, maxNote, seed } = config;\n    const density = inputs.density ?? 0.5;\n    const rng = new SeededRandom(seed ?? 12345); // Default seed if not provided\n\n    const sequence: Step[] = [];\n    for (let i = 0; i < SEQUENCE_LENGTH; i++) {\n      if (rng.next() < density) {\n        const note = rng.nextRange(minNote || 60, maxNote || 60);\n        sequence.push({ noteIndex: note, velocity: rng.next() * 0.5 + 0.5, hold: false });\n      } else {\n        sequence.push({ noteIndex: null, velocity: 0, hold: false });\n      }\n    }\n    return { seq_out: sequence };\n  },\n  compileConfig: (uiConfig: { minNote?: number, maxNote?: number, seed?: number }) => ({\n    minNote: uiConfig.minNote ?? 60,\n    maxNote: uiConfig.maxNote ?? 60,\n    seed: uiConfig.seed ?? 12345,\n  }),\n});\n\nregisterNode(chaosGenerator);\n","import { Step, Sequence } from \"./envelope-generator\";\n\nexport interface LayerConfig {\n  targetNoteIndex?: number;\n}\n\nexport abstract class AbstractLayer {\n  protected output: number = 0;\n  protected lastActive: boolean = false;\n\n  constructor(protected config: LayerConfig) { }\n\n  public update(step: Step, dt: number, isNewStep: boolean): void {\n    const isEvent = step.noteIndex !== null && step.noteIndex !== undefined;\n    let isActive = isEvent;\n\n    if (isActive) {\n      let isReleased = false;\n      if (this.lastActive) {\n        // Only retrigger if it's a new step and hold is false\n        if (isNewStep && !step.hold) {\n          this.onRelease();\n          isReleased = true;\n        }\n      } else {\n        isReleased = true;\n      }\n      if (isReleased) {\n        // Trigger on any note. Pass noteIndex for pitch-aware layers.\n        this.onTrigger(step.velocity, step.noteIndex);\n      }\n    } else {\n      // Empty step - release if active\n      if (this.lastActive) {\n        this.onRelease();\n      }\n    }\n\n    this.process(isActive, step, dt);\n    this.lastActive = isActive;\n  }\n\n  // New: Called when the timeline jumps significantly (seek/loop)\n  public forceRelease(): void {\n    this.onRelease();\n    this.lastActive = false;\n    // Optionally reset internal LFO phases or envelopes instantly\n    this.output = 0;\n  }\n\n  public getValue(): number { return this.output; }\n\n  public abstract previewSequence(sequence: Sequence, prevLayerOutput: number[]): number[];\n\n  protected abstract onTrigger(velocity: number, noteIndex?: number | null): void;\n  protected abstract onRelease(): void;\n  protected abstract process(isActive: boolean, step: Step, dt: number): void;\n}\n\n","import { AbstractLayer, LayerConfig } from \"./abstract-layer\";\nimport { Step, Sequence } from \"./envelope-generator\";\n\nexport class GateLayer extends AbstractLayer {\n  protected onTrigger(vel: number, noteIndex?: number | null) { this.output = vel; }\n  protected onRelease() { this.output = 0; }\n  protected process(isActive: boolean) {\n    // Hard gate, output stays high if active\n    if (isActive && this.output === 0) this.output = 1.0;\n  }\n  public previewSequence(sequence: Sequence, prevLayerOutput: number[]): number[] {\n    return sequence.map(step => {\n      const isActive = (step.noteIndex !== null && step.noteIndex !== undefined);\n      return isActive ? step.velocity : 0;\n    });\n  }\n}\n\nexport class ExponentialLayer extends AbstractLayer {\n  private decayRate: number = 0.96;\n\n  constructor(config: LayerConfig, decay: number = 0.96) {\n    super(config);\n    this.decayRate = decay;\n  }\n\n  protected onTrigger(vel: number, noteIndex?: number | null) {\n    // Snap up\n    this.output = vel;\n  }\n  protected onRelease() {\n    // Instant cut per requirements\n    this.output = 0;\n  }\n  protected process(isActive: boolean, step: Step) {\n    if (isActive) {\n      // Decay while holding\n      this.output *= this.decayRate;\n      // Sustain floor logic could go here\n    }\n  }\n\n  public previewSequence(sequence: Sequence, prevLayerOutput: number[]): number[] {\n    const results: number[] = [];\n    let output = 0;\n    let lastActive = false;\n\n    for (const step of sequence) {\n      const isActive = (step.noteIndex !== null && step.noteIndex !== undefined);\n\n      if (isActive && !lastActive) { // onTrigger\n        output = step.velocity;\n      } else if (!isActive && lastActive) { // onRelease\n        output = 0;\n      }\n\n      // process\n      if (isActive) {\n        output *= this.decayRate;\n      }\n\n      results.push(output);\n      lastActive = isActive;\n    }\n    return results;\n  }\n}\n\nexport class PWMLayer extends AbstractLayer {\n  private phase: number = 0;\n  private duty: number = 0.5;\n  private freq: number = 0.2;\n\n  protected onTrigger(vel: number, noteIndex?: number | null) {\n    this.duty = 0.5; // Reset duty\n  }\n  protected onRelease() {\n    // Natural decay for this layer per prototype\n  }\n  protected process(isActive: boolean, step: Step, dt: number) {\n    // Always decay value for this specific layer type\n    if (!isActive) {\n      this.output *= 0.85;\n      return;\n    }\n\n    // Logic\n    this.duty *= 0.98;\n    this.phase += this.freq;\n    if (this.phase > 1.0) this.phase -= 1.0;\n\n    this.output = (this.phase < this.duty) ? 1.0 : 0.0;\n  }\n\n  public previewSequence(sequence: Sequence, prevLayerOutput: number[]): number[] {\n    const results: number[] = [];\n    let output = 0;\n    let phase = 0;\n    let duty = 0.5;\n    let lastActive = false;\n\n    for (const step of sequence) {\n      const isActive = (step.noteIndex !== null && step.noteIndex !== undefined);\n\n      // onTrigger\n      if (isActive && !lastActive) {\n        duty = 0.5;\n      }\n      // onRelease is empty\n\n      // process\n      if (!isActive) {\n        output *= 0.85;\n      } else {\n        duty *= 0.98;\n        phase += this.freq;\n        if (phase > 1.0) phase -= 1.0;\n        output = (phase < duty) ? 1.0 : 0.0;\n      }\n\n      results.push(output);\n      lastActive = isActive;\n    }\n    return results;\n  }\n}\n\nexport class NoiseLayer extends AbstractLayer {\n  protected onTrigger(vel: number, noteIndex?: number | null) { }\n  protected onRelease() { this.output *= 0.85; }\n  protected process(isActive: boolean) {\n    if (isActive) {\n      this.output = Math.random();\n    } else {\n      this.output *= 0.85;\n    }\n  }\n\n  public previewSequence(sequence: Sequence, prevLayerOutput: number[]): number[] {\n    const results: number[] = [];\n    let output = 0;\n    let lastActive = false;\n\n    const mulberry32 = (a: number) => {\n      return () => {\n        a |= 0; a = (a + 0x6D2B79F5) | 0;\n        var t = Math.imul(a ^ a >>> 15, 1 | a);\n        t = (t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t;\n        return ((t ^ t >>> 14) >>> 0) / 4294967296;\n      }\n    }\n    const random = mulberry32(12345); // Fixed seed for reproducibility\n\n    for (const step of sequence) {\n      const isActive = (step.noteIndex !== null && step.noteIndex !== undefined);\n\n      // onRelease\n      if (!isActive && lastActive) {\n        output *= 0.85;\n      }\n\n      // process\n      if (isActive) {\n        output = random();\n      } else {\n        output *= 0.85;\n      }\n\n      results.push(output);\n      lastActive = isActive;\n    }\n    return results;\n  }\n}\n\n// --- Audio Layer ---\n\nexport class ToneSynthLayer extends AbstractLayer {\n  private ctx?: AudioContext;\n  private osc: OscillatorNode | null = null;\n  private gain: GainNode | null = null;\n  private filter: BiquadFilterNode | null = null;\n  private frequency: number;\n\n  constructor(config: LayerConfig, audioContext?: AudioContext, frequency?: number) {\n    super(config);\n    this.ctx = audioContext;\n    this.frequency = frequency ?? 440.0;\n  }\n\n  get audioContext() { return this.ctx; }\n  set audioContext(context: AudioContext | undefined) { this.ctx = context; }\n\n  // Audio layers handle output differently (audio graph),\n  // but we can use 'output' for monitoring amplitude if we want.\n\n  // Helper to prevent \"non-finite\" errors in AudioParams\n  private safeParam(param: AudioParam, value: number, time: number) {\n    if (Number.isFinite(value) && Number.isFinite(time)) {\n        try {\n            param.setValueAtTime(value, time);\n        } catch(e) { /* ignore */ }\n    }\n  }\n\n  private initVoice(time: number, velocity: number) {\n    if (!this.ctx || this.ctx.state === 'suspended') return;\n\n    // Disconnect old if exists (simple monophonic cleanup)\n    this.cleanup();\n\n    this.osc = this.ctx.createOscillator();\n    this.gain = this.ctx.createGain();\n    this.filter = this.ctx.createBiquadFilter();\n\n    // Config\n    // Use calculated frequency if available, else default\n    const freq = (Number.isFinite(this.frequency) && this.frequency > 0) ? this.frequency : 440;\n    this.safeParam(this.osc.frequency, freq, time);\n\n    this.filter.type = 'lowpass';\n    const filterFreq = 800 + (velocity * 2000);\n    this.safeParam(this.filter.frequency, filterFreq, time);\n\n    // Envelope\n    this.safeParam(this.gain.gain, 0, time);\n    try {\n        this.gain.gain.linearRampToValueAtTime(velocity, time + 0.005);\n        this.gain.gain.setTargetAtTime(0, time + 0.005, 0.1); // Decay\n    } catch(e) {}\n\n    // Graph\n    this.osc.connect(this.filter);\n    this.filter.connect(this.gain);\n    this.gain.connect(this.ctx.destination); // Or a master bus passed in constructor\n\n    this.osc.start(time);\n  }\n\n  /*\n   * Retires the previous voice by fading it out quickly rather than cutting it hard.\n   * This prevents clicks when retriggering notes while the previous one is still ringing.\n   */\n  private retirePreviousVoice(time: number) {\n    if (!this.osc || !this.gain || !this.filter) return;\n\n    // If context is suspended, we can't schedule/fade perfectly,\n    // but we should still detach to clean up our references.\n    // However, scheduling on a suspended context is generally allowed but won't process until resume.\n    // If strict suspension check is needed, we could return, but that leaks the voice ref if we init new one.\n    // Given initVoice guards against suspended, this might be moot, but let's be safe.\n\n    const oldOsc = this.osc;\n    const oldGain = this.gain;\n    const oldFilter = this.filter;\n\n    // Detach from class state immediately so new voice can take over\n    this.osc = null;\n    this.gain = null;\n    this.filter = null;\n\n    try {\n      // 5ms rapid fade out for the old voice\n      const fadeTime = 0.005;\n\n      // Cancel any pending changes (e.g. long release tails)\n      try {\n        (oldGain.gain as any).cancelAndHoldAtTime(time);\n      } catch (e) {\n        oldGain.gain.cancelScheduledValues(time);\n        this.safeParam(oldGain.gain, oldGain.gain.value, time);\n      }\n\n      oldGain.gain.linearRampToValueAtTime(0, time + fadeTime);\n\n      // Stop and disconnect after fade\n      const stopTime = time + fadeTime + 0.01;\n      oldOsc.stop(stopTime);\n\n      // Clean up graph when oscillator stops\n      oldOsc.onended = () => {\n        oldOsc.disconnect();\n        oldFilter.disconnect();\n        oldGain.disconnect();\n        (oldOsc as any).dispose?.();\n        (oldFilter as any).dispose?.();\n        (oldGain as any).dispose?.();\n      };\n\n    } catch (e) {\n      // Emergency cleanup if scheduling fails\n        oldOsc.disconnect();\n        oldFilter.disconnect();\n        oldGain.disconnect();\n    }\n  }\n\n  private cleanup() {\n      // Legacy cleanup if needed externally (e.g. node destroy), immediate kill\n      this.retirePreviousVoice(this.ctx?.currentTime ?? 0);\n  }\n\n  protected onTrigger(velocity: number, noteIndex?: number | null) {\n    // If suspended, do not trigger (initVoice handles it, but good to check early)\n    if (this.ctx?.state === 'suspended') return;\n\n    // Monophonic synth logic\n    // If holding, we might just pitch slide, but for this specific \"Clicky\" requirement:\n    // We do trigger a new pluck on new note, but handle holds in process\n\n    // Calculate frequency from noteIndex if provided\n    if (noteIndex !== null && noteIndex !== undefined) {\n      // MIDI Note to Frequency: 440 * 2^((note - 69) / 12)\n      const f = 440 * Math.pow(2, (noteIndex - 69) / 12);\n      if (Number.isFinite(f)) this.frequency = f;\n    }\n\n    this.initVoice(this.ctx?.currentTime ?? 0.0, velocity);\n  }\n\n  protected onRelease() {\n    // If suspended, nothing to release\n    if (this.ctx?.state === 'suspended') return;\n\n    if (this.gain) {\n      // 5ms fade out\n      const currentTime = this.ctx?.currentTime ?? 0.0;\n      try {\n        // Modern browsers support cancelAndHoldAtTime which prevents jumps\n        (this.gain.gain as any).cancelAndHoldAtTime(currentTime);\n      } catch (e) {\n        // Fallback\n        this.gain.gain.cancelScheduledValues(currentTime);\n        this.safeParam(this.gain.gain, this.gain.gain.value, currentTime);\n      }\n      try {\n        this.gain.gain.linearRampToValueAtTime(0, currentTime + 0.005);\n      } catch(e) {}\n\n      // Stop oscillator after fade out to save resources\n      // We can schedule it.\n      if (this.osc) {\n          try {\n             this.osc.stop(currentTime + 0.010); // Stop slightly after fade\n          } catch(e) {}\n      }\n    }\n  }\n\n  protected process(isActive: boolean, step: Step) {\n    if (isActive && step.hold && this.osc) {\n      // Logic for sustaining note if needed\n      // Currently our initVoice creates a one-shot envelope,\n      // but we could modify `gain` here to sustain.\n    }\n  }\n\n  public previewSequence(sequence: Sequence, prevLayerOutput: number[]): number[] {\n    const results: number[] = [];\n    let lastActive = false;\n    for (const step of sequence) {\n      const isActive = (step.noteIndex !== null && step.noteIndex !== undefined);\n      if (isActive && !lastActive) {\n        results.push(step.velocity);\n      } else {\n        results.push(0);\n      }\n      lastActive = isActive;\n    }\n    return results;\n  }\n}\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { midiStreamType } from \"../../structor/std-types\";\nimport { MidiEvent } from \"../../io/midi/types\";\nimport { Step } from \"./envelope-generator\";\nimport {\n  GateLayer,\n  ExponentialLayer,\n  PWMLayer,\n  NoiseLayer,\n} from \"./layers\";\nimport { AbstractLayer, LayerConfig } from \"./abstract-layer\";\nimport { layerOutputStructorType } from \"./nice-types\";\n\ninterface LayerState {\n  layer: AbstractLayer;\n  lastActive: boolean;\n  activeVelocity: number;\n  activeNote: number | null;\n}\n\nexport function createLayerNode(\n  id: string,\n  displayName: string,\n  LayerClass: new (config: LayerConfig) => AbstractLayer\n) {\n  return defineNode({\n    id,\n    version: \"1.0.0\",\n    displayName,\n    metadata: {\n      category: 'NicePattern',\n      keywords: ['layer', 'effect', 'modifier'],\n      description: `Layer node: ${displayName}`\n    },\n    config: {}, // Removed targetNote\n    inputs: {\n      midi_in: { type: midiStreamType, description: \"Input MIDI stream\", allowMultiConnection: true },\n      prev_layer: { type: layerOutputStructorType, description: \"Previous layer output\" }\n    },\n    outputs: { out: layerOutputStructorType },\n    autoBroadcast: {\n      midi_in: { combine: { reduce: 'flatten' } }\n    },\n    ui: { inspector: { fields: [] } }, // Removed LayerFields (targetNote)\n    isRealtime: () => true,\n    createState: (config, context): LayerState => {\n      return {\n        layer: new LayerClass({}),\n        lastActive: false,\n        activeVelocity: 0,\n        activeNote: null as number | null\n      };\n    },\n    execute: (inputs, config, context, state) => {\n      const activeLayer = state.layer as AbstractLayer;\n      // Flattening handled by autoBroadcast.midi_in.combine.reduce = 'flatten'\n      const stream = (inputs.midi_in || []) as MidiEvent[];\n\n      // Process MIDI stream\n      for (const event of stream) {\n        if (event.type === 'note_on') {\n          // Trigger on ANY note, track it as active\n          state.lastActive = true;\n          state.activeVelocity = event.velocity;\n          state.activeNote = event.note;\n        } else if (event.type === 'note_off') {\n          // Only release if the Off event matches our current active note\n          if (state.activeNote === event.note) {\n            state.lastActive = false;\n            state.activeNote = null;\n          }\n        }\n      }\n\n      const syntheticStep: Step = {\n        noteIndex: state.lastActive ? (state.activeNote ?? 60) : null,\n        velocity: state.activeVelocity,\n        hold: false, // We don't easily track hold from stream without more state\n      };\n\n      // We assume isNewStep is true if we processed any relevant events?\n      // Or we rely on the layer's internal logic.\n      // The original code passed 'isNewStep' if the event object changed reference.\n      // Here, we should probably pass true if we received a Note On.\n      const hasNoteOn = stream.some((e: MidiEvent) => e.type === 'note_on');\n\n      activeLayer.update(syntheticStep, context.clock.dt, hasNoteOn);\n      const result = activeLayer.getValue();\n\n      return { out: result };\n    },\n    compileConfig: (uiConfig) => ({}),\n  });\n}\n\nexport const gateLayer = createLayerNode(\"nicepattern.gate_layer\", \"Gate Layer\", GateLayer);\nexport const expLayer = createLayerNode(\"nicepattern.exp_layer\", \"Exponential Layer\", ExponentialLayer);\nexport const pwmLayer = createLayerNode(\"nicepattern.pwm_layer\", \"PWM Layer\", PWMLayer);\nexport const noiseLayer = createLayerNode(\"nicepattern.noise_layer\", \"Noise Layer\", NoiseLayer);\n\nregisterNode(gateLayer);\nregisterNode(expLayer);\nregisterNode(pwmLayer);\nregisterNode(noiseLayer);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { midiStreamType } from \"../../structor/std-types\";\nimport { MidiEvent } from \"../../io/midi/types\";\nimport { Step } from \"./envelope-generator\";\nimport { ToneSynthLayer } from \"./layers\";\nimport { layerOutputStructorType } from \"./nice-types\";\n\ninterface ToneSynthState {\n  layer: ToneSynthLayer;\n  lastActive: boolean;\n  lastActiveNote: number | null;\n  activeVelocity: number;\n  contextId: string;\n}\n\nexport const toneSynthLayer = defineNode({\n  id: \"nicepattern.tone_synth_layer\",\n  version: \"1.0.0\",\n  displayName: \"Tone Synth Layer\",\n  metadata: {\n    category: 'NicePattern',\n    keywords: ['synth', 'audio', 'sound', 'tone'],\n    description: 'Simple synthesizer layer using Tone.js.'\n  },\n  config: {}, // Removed targetNote\n  inputs: {\n    midi_in: { type: midiStreamType, description: \"Input MIDI stream\", allowMultiConnection: true },\n    prev_layer: { type: layerOutputStructorType, description: \"Previous layer output\" }\n  },\n  outputs: { out: layerOutputStructorType },\n  autoBroadcast: {\n    midi_in: { combine: { reduce: 'flatten' } }\n  },\n  ui: { inspector: { fields: [] } }, // Removed LayerFields\n  isRealtime: () => true,\n  createState: (config, context): ToneSynthState => {\n    return {\n      layer: new ToneSynthLayer({}),\n      lastActive: false,\n      lastActiveNote: null as number | null,\n      activeVelocity: 0,\n      contextId: ''\n    };\n  },\n  execute: (inputs, config, context, state) => {\n    // Check for Audio Context Reset/Invalidation\n    const audioContext = context.audio?.context;\n    // Ensure layer exists (resilience against state corruption or bad init)\n    if (!state.layer) {\n      state.layer = new ToneSynthLayer({});\n    }\n\n    if (audioContext && state.contextId !== audioContext.contextId) {\n      state.layer = new ToneSynthLayer({});\n      state.contextId = audioContext.contextId;\n    }\n\n    const activeLayer = state.layer;\n    // Flattening handled by autoBroadcast\n    const stream = (inputs.midi_in || []) as MidiEvent[];\n\n    let hasNoteOn = false;\n\n    // Process MIDI stream\n    for (const event of stream) {\n      if (event.type === 'note_on') {\n        // Trigger on ANY note\n        state.lastActive = true;\n        state.lastActiveNote = event.note;\n        state.activeVelocity = event.velocity;\n        hasNoteOn = true;\n      } else if (event.type === 'note_off') {\n        // Release only if matching\n        if (state.lastActiveNote === event.note) {\n          state.lastActive = false;\n          state.lastActiveNote = null;\n        }\n      }\n    }\n\n    const syntheticStep: Step = {\n      noteIndex: state.lastActive ? state.lastActiveNote : null,\n      velocity: state.activeVelocity,\n      hold: false,\n    };\n\n    // Use the provided audio context from execution context\n    if (!activeLayer.audioContext) {\n      if (context.audio?.context) {\n        activeLayer.audioContext = context.audio.context;\n      } else if (typeof window !== 'undefined') {\n        activeLayer.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n      }\n    }\n\n    activeLayer.update(syntheticStep, context.clock.dt, hasNoteOn);\n    const result = activeLayer.getValue();\n\n    return { out: result };\n  },\n  compileConfig: (uiConfig) => ({}),\n});\n\nregisterNode(toneSynthLayer);\n","import {\n  MidiEvent\n} from \"../../io/midi/types\";\nimport {\n  defineNode,\n  registerNode,\n  InspectorFieldDef\n} from \"../../structor/node-helpers\";\nimport {\n  numberType,\n  midiStreamType,\n  float4Type\n} from \"../../structor/std-types\";\nimport { defineType, NumberType } from \"../../structor/type-helpers\";\nimport { SeededRandom } from \"./utils\";\n\n// --- Logic Helpers ---\n\nfunction generateHadamard(n: number): number[][] {\n  if (n === 1) return [[0]];\n  const h = generateHadamard(n / 2);\n  const out: number[][] = [];\n  for (let i = 0; i < h.length; i++) out.push([...h[i], ...h[i]]);\n  for (let i = 0; i < h.length; i++) out.push([...h[i], ...h[i].map(b => 1 - b)]);\n  return out;\n}\n\nfunction getComplexity(row: number[]): number {\n  let t = 0;\n  for (let i = 0; i < row.length - 1; i++) if (row[i] !== row[i + 1]) t++;\n  return t;\n}\n\nexport function generateCodes(resolution: number, seed: number): number[][] {\n  // 1. Generate Raw Hadamard (Size 8)\n  const rawCodes = generateHadamard(8).sort((a, b) => getComplexity(a) - getComplexity(b));\n  // Force index 0 to be all ON (as per prototype)\n  rawCodes[0] = [1, 1, 1, 1, 1, 1, 1, 1];\n\n  // 2. Permute Columns based on seed\n  const colMap = [0, 1, 2, 3, 4, 5, 6, 7];\n  const rng = new SeededRandom(seed);\n\n  // Fisher-Yates shuffle for columns\n  for (let i = colMap.length - 1; i > 0; i--) {\n    const j = rng.nextRange(0, i);\n    [colMap[i], colMap[j]] = [colMap[j], colMap[i]];\n  }\n\n  // 3. Select Subset based on resolution\n  const count = Math.max(2, Math.min(8, resolution));\n  const subset = rawCodes.slice(0, count);\n\n  // 4. Map columns\n  return subset.map(code => {\n    const newCode = new Array(8);\n    for (let i = 0; i < 8; i++) newCode[i] = code[colMap[i]];\n    return newCode;\n  });\n}\n\n// --- Node Definition ---\n\nexport const OrthomodFields: InspectorFieldDef[] = [\n  { type: 'number', label: 'Seed', path: 'seed', step: 1 }\n];\n\ninterface OrthomodState {\n  linearEnv: number;\n  gateOpen: boolean;\n  active: boolean;\n  codes: number[][];\n  lastSeed: number;\n  lastResolution: number;\n  currentEffectiveCurve: number;\n  phase: number;\n}\n\nexport const orthomod = defineNode({\n  id: \"nicepattern.orthomod\",\n  version: \"1.0.0\",\n  displayName: \"Orthomod\",\n  metadata: {\n    category: 'NicePattern',\n    keywords: ['envelope', 'modulation', 'orthogonal', 'hadamard'],\n    description: 'Orthogonal code-based envelope generator.'\n  },\n  config: {\n    seed: numberType\n  },\n  inputs: {\n    midi_in: { type: midiStreamType, description: \"Trigger Input\", allowMultiConnection: true },\n    decay: { type: numberType, defaultValue: 1.2, description: \"Decay Time (s)\", range: [0.0, 4.0], step: 0.01 },\n    curve: { type: numberType, defaultValue: 1.5, description: \"Response Curve\", range: [0.1, 4.0], step: 0.1 },\n    relcurve: { type: numberType, defaultValue: 12.0, description: \"Release Curve\", range: [0.1, 20.0], step: 0.1 },\n    resolution: { type: numberType, defaultValue: 8, range: [2, 8], step: 1, description: \"Codebook Size\" },\n    manual_phase: {\n      type: numberType,\n      defaultValue: -1,\n      description: \"Manual Phase Override (0-1)\",\n      suppressInputEditor: true\n    }\n  },\n  outputs: {\n    env: { type: numberType, description: \"Envelope Output (0-1)\" },\n    vec: { type: float4Type, description: \"Channel Values [c1, c2, c3, c4]\" },\n    ch1: { type: numberType, description: \"Channel 1\" },\n    ch2: { type: numberType, description: \"Channel 2\" },\n    ch3: { type: numberType, description: \"Channel 3\" },\n    ch4: { type: numberType, description: \"Channel 4\" }\n  },\n  autoBroadcast: {\n    midi_in: { combine: { reduce: 'flatten' } }\n  },\n  ui: {\n    inspector: { fields: OrthomodFields },\n  },\n  isRealtime: () => true,\n  createState: (): OrthomodState => ({\n    linearEnv: 0.0,\n    gateOpen: false,\n    active: false,\n    codes: [],\n    lastSeed: -1,\n    lastResolution: -1,\n    currentEffectiveCurve: 1.5,\n    phase: 0.0\n  }),\n  execute: (inputs, config, context, state) => {\n    const dt = context.clock.dt;\n    state.phase += dt; // Accumulate time in seconds\n    const now = state.phase;\n\n\n    // Inputs - Sanitize with Safe Defaults to prevent NaNs\n    // Be very aggressive about defaults.\n    const decayRaw = inputs.decay;\n    const decay = (typeof decayRaw === 'number' && Number.isFinite(decayRaw)) ? Math.max(0.001, decayRaw) : 1.2;\n\n    const curveRaw = inputs.curve;\n    const sustainCurve = (typeof curveRaw === 'number' && Number.isFinite(curveRaw)) ? Math.max(0.001, curveRaw) : 1.5;\n\n    const relCurveRaw = inputs.relcurve;\n    const releaseCurve = (typeof relCurveRaw === 'number' && Number.isFinite(relCurveRaw)) ? Math.max(0.1, relCurveRaw) : 12.0;\n\n    const resRaw = inputs.resolution;\n    const resolution = (typeof resRaw === 'number' && Number.isFinite(resRaw)) ? Math.floor(Math.max(2, Math.min(8, resRaw))) : 8;\n\n    const seed = config.seed ?? 12345;\n\n    // Manual Phase: allow -1, clamp 0-1\n    const phaseRaw = inputs.manual_phase;\n    const manualPhase = (typeof phaseRaw === 'number' && Number.isFinite(phaseRaw)) ? phaseRaw : -1.0;\n\n    // 1. Rebuild Codes if needed\n    if (seed !== state.lastSeed || resolution !== state.lastResolution) {\n      state.codes = generateCodes(resolution, seed);\n      state.lastSeed = seed;\n      state.lastResolution = resolution;\n    }\n\n    // 2. MIDI Triggers\n    const stream = (inputs.midi_in || []).flat() as any[];\n    for (const e of stream) {\n      if (e.type === 'note_on') {\n        state.linearEnv = 1.0;\n        state.gateOpen = true;\n        state.active = true;\n        // Curve is handled in frame update\n      } else if (e.type === 'note_off') {\n        state.gateOpen = false;\n        // Release phase triggers fast curve in frame update\n      }\n    }\n\n    // 3. Envelope Logic\n    // If manual phase is active, use it\n    let currentEnv = 0;\n\n    if (manualPhase >= 0) {\n      state.linearEnv = Math.max(0, Math.min(1, manualPhase));\n      state.active = true; // Force active\n      state.currentEffectiveCurve = 1.0; // Linear for manual\n    } else {\n      if (state.active) {\n        state.linearEnv -= dt / Math.max(0.01, decay);\n        if (state.linearEnv <= 0) {\n          state.linearEnv = 0;\n          state.active = false;\n        }\n      }\n\n      // Dynamic Curve Logic\n      if (!state.gateOpen && state.active) {\n        // Fast Release (controlled by relcurve)\n        state.currentEffectiveCurve = releaseCurve;\n      } else {\n        // Sustain / Attack / Idle\n        state.currentEffectiveCurve = sustainCurve;\n      }\n    }\n\n    // Curve\n    // Protect Math.pow against (0, negative) or (negative, fractional)\n    const base = Math.max(0, state.linearEnv);\n    const exponent = state.currentEffectiveCurve;\n    currentEnv = Math.pow(base, exponent);\n\n    if (Number.isNaN(currentEnv)) currentEnv = 0;\n\n    // 4. Map to Codes\n    // Prototype: \"let pos = 1.0 - STATE.curEnv\"\n    // So Env=1.0 -> Pos=0 (Index 0). Env=0.0 -> Pos=1 (Index Max)\n    // Prototype Index 0 is ALL ON. So Start of Env = ALL ON.\n    let pos = 1.0 - currentEnv;\n    pos = Math.max(0, Math.min(0.999, pos));\n\n    const count = state.codes.length;\n    const idx = Math.floor(pos * count);\n    const code = state.codes[idx] || state.codes[0]; // Fallback\n\n    // 5. Modulators\n    // Prototype: sqr = (t*rate)%1 > 0.5. sin = abs(sin(t...))\n    const rate = 15; // Hz. Use 15Hz (60/4) to align with 60Hz update and ensure peaks are hit visually.\n    const sqr = (now * rate) % 1.0 > 0.5 ? 1 : 0;\n    const sin = Math.abs(Math.sin(now * rate * Math.PI * 2));\n\n    // 6. Channel Outputs\n    const channels = [0, 0, 0, 0];\n    const rawChannels = [0, 0, 0, 0];\n\n    if (state.active) {\n      for (let ch = 0; ch < 4; ch++) {\n        const b1 = code[ch * 2] || 0;\n        const b2 = code[ch * 2 + 1] || 0;\n\n        let val = 0;\n        if (b1 === 0 && b2 === 0) val = 0; // OFF\n        else if (b1 === 1 && b2 === 1) val = 1; // ON\n        else if (b1 === 1 && b2 === 0) val = sqr; // SQR\n        else if (b1 === 0 && b2 === 1) val = sin; // SIN\n\n        rawChannels[ch] = val; // Store raw value\n        channels[ch] = val * currentEnv; // Store modulated value\n\n        if (Number.isNaN(channels[ch])) channels[ch] = 0;\n      }\n    }\n\n    const safeNum = (n: number) => Number.isFinite(n) ? n : 0;\n\n    return {\n      outputs: {\n        env: safeNum(currentEnv),\n        vec: channels.map(safeNum),\n        ch1: safeNum(channels[0]),\n        ch2: safeNum(channels[1]),\n        ch3: safeNum(channels[2]),\n        ch4: safeNum(channels[3]),\n      },\n      ui: {\n        codes: state.codes, // Pass the generated codes!\n        env: safeNum(currentEnv),\n        vec: channels.map(safeNum),\n        rawVec: state.active ? rawChannels.map(safeNum) : [0, 0, 0, 0], // Unmodulated values\n        activeCodeIndex: idx, // Current code index\n        gate: state.gateOpen ? 1 : 0\n      }\n    };\n  },\n  compileConfig: (uiConfig: { seed?: number }) => ({\n    seed: uiConfig?.seed ?? 12345\n  })\n});\n\nregisterNode(orthomod);\n","\nimport { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport { numberType, float4Type } from \"../../structor/std-types\";\nimport { VirtualAudioContext, VirtualOscillatorNode, VirtualGainNode } from \"../../audio/virtual-audio\";\n\ninterface Tone4State {\n  initialized: boolean;\n  contextId?: string;\n  masterGain: VirtualGainNode | null;\n  voices: {\n    osc: VirtualOscillatorNode;\n    gain: VirtualGainNode;\n    freqRatio: number;\n    wave: string;\n  }[];\n  lastRoot: number;\n}\n\nexport const createTone4State = (): Tone4State => ({\n  initialized: false,\n  contextId: '',\n  masterGain: null,\n  voices: [],\n  lastRoot: -1\n});\n\nexport const tone4 = defineNode({\n  id: \"nicepattern.tone4\",\n  version: \"1.0.0\",\n  displayName: \"Tone 4\",\n  metadata: {\n    category: 'NicePattern',\n    keywords: ['synth', 'additive', 'oscillator', 'audio'],\n    description: '4-voice additive synth driven by vector input.'\n  },\n  inputs: {\n    vec: { type: float4Type, description: \"Modulation Vector [c1, c2, c3, c4]\" },\n    root: { type: numberType, defaultValue: 60, description: \"Root Note (MIDI)\", range: [0, 127] },\n    gain: { type: numberType, defaultValue: 0.5, description: \"Master Volume\" }\n  },\n  outputs: {}, // Audio output is internal/side-effect\n  isRealtime: () => true,\n  createState: createTone4State,\n  execute: (inputs, config, context, state: Tone4State) => {\n    const audio = context.audio?.context;\n    if (!audio || audio.state === 'suspended') return {}; // No audio context or suspended, do nothing\n\n    const now = audio.currentTime;\n\n    // Initialize Audio Graph\n    // Check if initialized AND if context matches (in case of reset)\n    if (!state.initialized || state.contextId !== audio.contextId) {\n      // Create Master\n      state.masterGain = audio.createGain();\n      state?.masterGain?.connect(audio.destination);\n\n      // Create Voices\n      // Prototype: [73.42, 110.00, 146.83, 220.00]\n      // Ratios approx: 1.0, 1.5, 2.0, 3.0\n      const ratios = [1.0, 1.5, 2.0, 3.0];\n      const waves = ['square', 'sawtooth', 'triangle', 'sine'];\n\n      state.voices = ratios.map((ratio, i) => {\n        const osc = audio.createOscillator();\n        const gain = audio.createGain();\n\n        osc.type = waves[i];\n        osc.connect(gain);\n        gain.connect(state.masterGain!);\n        osc.start(now);\n        gain.gain.setValueAtTime(0, now); // Start silent\n\n        return { osc, gain, freqRatio: ratio, wave: waves[i] };\n      });\n\n      state.initialized = true;\n      state.contextId = audio.contextId;\n      state.lastRoot = -1; // Force frequency update\n    }\n\n    // Update Master Volume\n    const masterVol = Math.max(0, Math.min(1, inputs.gain ?? 0.5));\n    if (state.masterGain) {\n      state.masterGain.gain.setTargetAtTime(masterVol, now, 0.05);\n    }\n\n    // Update Frequencies (if changed)\n    const rootRaw = inputs.root;\n    // Quantize root to integer MIDI note (0-127), default to 69 (A4 = 440Hz)\n    // Range is clamped to [0, 127]\n    const midiNote = (typeof rootRaw === 'number' && Number.isFinite(rootRaw))\n      ? Math.floor(Math.max(0, Math.min(127, rootRaw)))\n      : 69;\n\n    // Convert MIDI to Frequency\n    // f = 440 * 2^((d - 69) / 12)\n    const rootFreq = 440 * Math.pow(2, (midiNote - 69) / 12);\n\n    if (Math.abs(rootFreq - state.lastRoot) > 0.01) {\n      state.voices.forEach(v => {\n        if (state.lastRoot === -1) {\n          // First update: Snap immediately to avoid startup sweep (440Hz -> Target)\n          v.osc.frequency.setValueAtTime(rootFreq * v.freqRatio, now);\n        } else {\n          // Subsequent updates: Glide\n          v.osc.frequency.setTargetAtTime(rootFreq * v.freqRatio, now, 0.05);\n        }\n      });\n      state.lastRoot = rootFreq;\n    }\n\n    // Update Voice Gains from Vector\n    const vecRaw = inputs.vec;\n    const vec = (Array.isArray(vecRaw) && vecRaw.length === 4) ? vecRaw : [0, 0, 0, 0];\n\n    state.voices.forEach((v, i) => {\n      const val = Math.max(0, Math.min(1, vec[i] ?? 0));\n      // Use smoothing to avoid clicks\n      v.gain.gain.setTargetAtTime(val, now, 0.02);\n    });\n\n    return {};\n  }\n});\n\nregisterNode(tone4);\n","import { defineNode, registerNode, InspectorFieldDef } from \"../../structor/node-helpers\";\nimport { numberType, booleanType, float4Type, midiEventType, midiStreamType } from \"../../structor/std-types\";\nimport { NumberType } from \"../../structor/type-helpers\";\nimport { SeededRandom } from \"./utils\";\n\n// --- Physics Constants & Types ---\n\nconst PRE_CONFIG = {\n    gravity: 800,\n    magnetEpsilon: 50,\n    physicsRate: 120,\n    solverSteps: 16,\n    sphereCount: 16,\n    magnetRange: 800,\n    height: 600 // Simulation height (arbitrary units, matching canvas pixels roughly)\n};\n\nclass Sphere {\n    id: number;\n    radius: number;\n    mass: number;\n    restLength: number;\n    x: number;\n    y: number;\n    vx: number;\n    vy: number;\n    isLatched: boolean;\n    tensionRatio: number;\n    currentSpringForce: number;\n    currentMagForce: number;\n\n    constructor(id: number, w: number, h: number, idx: number, count: number, rng: SeededRandom) {\n        this.id = id;\n        this.radius = 6 + rng.next() * 8;\n        this.mass = this.radius;\n        this.restLength = 20 + Math.pow(rng.next(), 2) * 150;\n\n        const pad = w * 0.1;\n        const avail = w - (pad * 2);\n        this.x = pad + (avail / (count - 1)) * idx;\n        this.y = h - this.restLength;\n        this.vx = 0;\n        this.vy = 0;\n        this.isLatched = false;\n        this.tensionRatio = 0;\n        this.currentSpringForce = 0;\n        this.currentMagForce = 0;\n    }\n\n    update(dt: number, h: number, plateY: number, magnetOn: boolean, params: { gravity: number, springK: number, magnetStrength: number, damping: number }) {\n        this.currentMagForce = 0;\n        this.currentSpringForce = 0;\n        this.tensionRatio = 0;\n\n        const targetY = h - this.restLength;\n        const springForce = (targetY - this.y) * params.springK;\n        const gravityForce = params.gravity * this.mass;\n        const totalDownForce = gravityForce + springForce;\n        this.currentSpringForce = Math.max(0, totalDownForce);\n\n        // Helper: getMagneticForce\n        const getMagneticForce = (dist: number) => {\n            if (dist >= PRE_CONFIG.magnetRange) return 0;\n            const decay = PRE_CONFIG.magnetEpsilon / (dist * dist + PRE_CONFIG.magnetEpsilon);\n            return params.magnetStrength * decay;\n        };\n\n        const holdForce = getMagneticForce(0);\n\n        if (magnetOn) {\n            const distToPlate = this.y - this.radius - plateY;\n            if (this.isLatched || distToPlate <= 2.0) {\n                if (holdForce > totalDownForce) {\n                    this.isLatched = true;\n                    this.y = plateY + this.radius;\n                    this.vy = 0;\n                    this.currentMagForce = holdForce;\n                    this.tensionRatio = Math.max(0, Math.min(1, totalDownForce / holdForce));\n                    return;\n                } else {\n                    this.isLatched = false;\n                }\n            }\n        } else {\n            this.isLatched = false;\n        }\n\n        let force = totalDownForce;\n        if (magnetOn && !this.isLatched) {\n            const dist = Math.max(0, this.y - this.radius - plateY);\n            const magForce = -getMagneticForce(dist);\n            this.currentMagForce = Math.abs(magForce);\n            force += magForce;\n        }\n\n        this.vy += (force / this.mass) * dt;\n        this.vy *= params.damping;\n        this.y += this.vy * dt;\n\n        if (this.y + this.radius > h) {\n            this.y = h - this.radius;\n            this.vy *= -0.5;\n        }\n        if (this.y - this.radius < plateY) {\n            this.y = plateY + this.radius;\n            if (!magnetOn) {\n                this.vy *= -0.6;\n                // Bounce assist during attack? (from logic: if(STATE.phase === 'ATTACK') this.vy += 400;)\n                // We don't have direct access to phase here easily unless passed.\n                // Porting strictly: logic used STATE.phase === 'ATTACK'.\n                // Let's assume we pass a 'bounce' flag or similar?\n                // Or just omit strict attack bounce for now.\n            } else {\n                if (this.vy < 0) this.vy = 0;\n            }\n        }\n    }\n}\n\ninterface MagnetoState {\n    spheres: Sphere[];\n    plateY: number;\n    phase: 'IDLE' | 'ATTACK' | 'DECAY' | 'SUSTAIN' | 'RELEASE' | 'MANUAL';\n    sustainProgress: number;\n    accumulator: number;\n    lastGate: boolean;\n    isTouchingSim: boolean;\n    touchY: number;\n    currentSeed?: number;\n}\n\n// --- Node Definition ---\n\nexport const MagnetoFields: InspectorFieldDef[] = [\n    { type: 'number', label: 'Seed', path: 'seed', step: 1, min: 0, max: 999999 }\n];\n\nexport const magneto = defineNode({\n    id: \"nicepattern.magneto\",\n    version: \"1.0.0\",\n    displayName: \"Magneto\",\n    metadata: {\n        category: 'NicePattern',\n        keywords: ['envelope', 'physics', 'magnet', 'modulator'],\n        description: 'Physics-based magnetic envelope generator.'\n    },\n    config: {\n        seed: { ...numberType, defaultValue: 1337 }\n    },\n    inputs: {\n        midi_in: { type: midiStreamType, description: \"Trigger Input\", allowMultiConnection: true },\n        attack: { type: numberType, defaultValue: 0.2, range: [0.01, 2.0], step: 0.01, description: \"Attack Time (s)\" },\n        decay: { type: numberType, defaultValue: 0.25, range: [0.01, 2.0], step: 0.01, description: \"Decay Time (s)\" },\n        sustain: { type: numberType, defaultValue: 0.6, range: [0.0, 1.0], step: 0.01, description: \"Sustain Level (0-1)\" },\n        release: { type: numberType, defaultValue: 0.3, range: [0.01, 5.0], step: 0.01, description: \"Release Time (s)\" },\n        peak: { type: numberType, defaultValue: 0.9, range: [0.1, 1.0], step: 0.01, description: \"Peak Level (0-1, inverted)\" },\n\n        // Physics\n        mag_flux: { type: numberType, defaultValue: 2000000, range: [100000, 4000000], step: 10000, description: \"Magnet Strength\" },\n        spring_k: { type: numberType, defaultValue: 25000, range: [1000, 50000], step: 100, description: \"Spring Stiffness\" },\n        damping: { type: numberType, defaultValue: 0.999, range: [0.900, 1.000], step: 0.001, description: \"Damping Factor\" }\n    },\n    outputs: {\n        env: { type: numberType, description: \"Envelope Output (Tension)\" },\n        vec: float4Type, // [Tension, Ext, Spring, Mag]\n        ch1: { type: numberType, description: \"Channel 1 (Tension)\" },\n        ch2: { type: numberType, description: \"Channel 2 (Extension)\" },\n        ch3: { type: numberType, description: \"Channel 3 (Spring Force)\" },\n        ch4: { type: numberType, description: \"Channel 4 (Mag Force)\" }\n    },\n    autoBroadcast: {\n        midi_in: { combine: { reduce: 'flatten' } }\n    },\n    ui: {\n        inspector: { fields: MagnetoFields },\n    },\n    isRealtime: () => true,\n    createState: (): MagnetoState => {\n        const spheres: Sphere[] = [];\n        const cw = 600; // Virtual width\n        const ch = PRE_CONFIG.height;\n        const rng = new SeededRandom(1337);\n        for (let i = 0; i < PRE_CONFIG.sphereCount; i++) {\n            spheres.push(new Sphere(i, cw, ch, i, PRE_CONFIG.sphereCount, rng));\n        }\n        return {\n            spheres,\n            plateY: 40, // Open Y\n            phase: 'IDLE',\n            sustainProgress: 0,\n            accumulator: 0,\n            lastGate: false,\n            isTouchingSim: false,\n            touchY: 0\n        };\n    },\n    onMessage: (state: MagnetoState, message: any) => {\n        if (message.type === 'manual_interaction') {\n            state.isTouchingSim = message.active;\n            if (typeof message.y === 'number') {\n                state.touchY = message.y;\n            }\n        }\n    },\n    execute: (inputs, config, context, state) => {\n        const dt = context.clock.dt;\n\n        // Inputs - Parse MIDI\n        const stream = (inputs.midi_in || []) as any[];\n        let gate = state.lastGate; // Persist gate state\n\n        for (const e of stream) {\n            if (e.type === 'note_on') {\n                gate = true;\n            } else if (e.type === 'note_off') {\n                gate = false;\n            }\n        }\n\n        const attack = Math.max(0.005, inputs.attack ?? 0.2);\n        const decay = Math.max(0.005, inputs.decay ?? 0.25);\n        const sustain = inputs.sustain ?? 0.6;\n        const release = Math.max(0.005, inputs.release ?? 0.3);\n        const peak = inputs.peak ?? 0.9;\n        // Get Seed from Config, default to 1337 if undefined\n        const seed = config.seed ?? 1337;\n\n        const magStr = inputs.mag_flux ?? 2000000;\n        const kp = inputs.spring_k ?? 25000;\n        const damp = inputs.damping ?? 0.999;\n\n        // Initialize or Regenerate Spheres if seed changes\n        if (state.currentSeed !== seed || state.spheres.length === 0) {\n            state.currentSeed = seed;\n            const rng = new SeededRandom(seed);\n            state.spheres = [];\n            const cw = 600; // Virtual width\n            const ch = PRE_CONFIG.height;\n            for (let i = 0; i < PRE_CONFIG.sphereCount; i++) {\n                state.spheres.push(new Sphere(i, cw, ch, i, PRE_CONFIG.sphereCount, rng));\n            }\n        }\n\n        // Layout Targets (simulating h * 0.95 vs h * 0.1)\n        const h = PRE_CONFIG.height;\n        const deep = h * 0.95;\n        const shallow = h * 0.1;\n\n        const plateOpenY = 40;\n        const plateClosedY = shallow + (peak * (deep - shallow));\n        const plateSustainY = shallow + (sustain * (deep - shallow));\n\n        // Speeds (ported from updatePhysics in HTML)\n        // Clamped to 1.0 to prevent overshoot/explosion\n        const speedAttack = Math.min(1.0, 0.05 / Math.max(0.001, attack));\n        const speedDecay = Math.min(1.0, 0.02 / Math.max(0.001, decay));\n        const speedRelease = Math.min(1.0, 0.02 / Math.max(0.001, release));\n\n\n        // Phase Logic\n        if (gate && !state.lastGate) {\n            // Gate On\n            state.phase = 'ATTACK';\n            state.sustainProgress = 0;\n        } else if (!gate && state.lastGate) {\n            // Gate Off\n            state.phase = 'RELEASE';\n            state.sustainProgress = 0;\n        }\n        state.lastGate = gate;\n\n\n        // Physics Loop (Fixed Timestep)\n        state.accumulator += dt;\n        const FIXED_STEP = 1 / PRE_CONFIG.physicsRate;\n\n        let magnetActive = false;\n\n        // Limit max steps to prevent freeze on lag\n        let steps = 0;\n        while (state.accumulator >= FIXED_STEP && steps < 5) {\n            state.accumulator -= FIXED_STEP;\n            steps++;\n\n            let targetY = plateOpenY;\n            let speed = speedRelease;\n\n            if (state.isTouchingSim) {\n                state.phase = 'MANUAL';\n                magnetActive = true;\n                targetY = state.touchY;\n                // Clamp targetY to layout bounds\n                targetY = Math.max(plateOpenY, Math.min(deep, targetY));\n                speed = speedAttack; // High speed for responsiveness\n                state.sustainProgress = 0;\n\n            } else if (gate) {\n                if (state.phase === 'IDLE' || state.phase === 'RELEASE' || state.phase === 'MANUAL') {\n                    // If coming from manual, resume? Or reset?\n                    // Logic for resuming sequence if manual ends while gate is on?\n                    // Just go to ATTACK for simplicity or infer phase?\n                    // Let's rely on standard flow.\n                    // If we were manual and gate is held, where do we go?\n                    // Maybe sustain?\n                    if (state.phase === 'MANUAL') {\n                        // Resume at sustain if close?\n                        state.phase = 'ATTACK'; // Retrigger attack?\n                    } else {\n                        state.phase = 'ATTACK';\n                        state.sustainProgress = 0;\n                    }\n                }\n\n                if (state.phase === 'ATTACK') {\n                    targetY = plateClosedY;\n                    speed = speedAttack;\n                    if (Math.abs(state.plateY - plateClosedY) < 10) state.phase = 'DECAY';\n                } else if (state.phase === 'DECAY') {\n                    targetY = plateSustainY;\n                    speed = speedDecay;\n                    if (Math.abs(state.plateY - plateSustainY) < 5) state.phase = 'SUSTAIN';\n                } else if (state.phase === 'SUSTAIN') {\n                    targetY = plateSustainY;\n                    speed = 0.1; // Slow drift? HTML: 0.1\n                    state.sustainProgress += (1.0 - state.sustainProgress) * 2.0 * FIXED_STEP;\n                }\n                magnetActive = true;\n            } else {\n                // Release\n                state.phase = 'RELEASE';\n                targetY = plateOpenY;\n                speed = speedRelease;\n\n                // Ensure we snap to open if close enough\n                if (Math.abs(state.plateY - plateOpenY) < 15) {\n                    magnetActive = false;\n                    state.phase = 'IDLE';\n                    // Optionally snap plateY?\n                    // state.plateY = plateOpenY;\n                } else {\n                    magnetActive = true;\n                }\n            }\n\n            const diff = targetY - state.plateY;\n            // Apply speed but ensure we don't overshoot excessively\n            state.plateY += diff * speed;\n\n            // Solver\n            const solverDt = FIXED_STEP / PRE_CONFIG.solverSteps;\n            const params = { gravity: PRE_CONFIG.gravity, springK: kp, magnetStrength: magStr, damping: damp };\n\n            for (let i = 0; i < PRE_CONFIG.solverSteps; i++) {\n                state.spheres.forEach(s => {\n                    s.update(solverDt, h, state.plateY, magnetActive, params);\n                });\n            }\n        }\n        // Dump extra accumulator if too much lag\n        if (state.accumulator > FIXED_STEP) state.accumulator = 0;\n\n        // Calculate Metrics (Audio Output)\n\n        let sumTension = 0, sumExt = 0, sumFS = 0, sumFM = 0, latchedCount = 0;\n\n        state.spheres.forEach(s => {\n            if (s.isLatched) { latchedCount++; sumTension += s.tensionRatio; }\n            const ext = Math.max(0, (h - s.restLength) - s.y);\n            sumExt += ext;\n            sumFS += s.currentSpringForce;\n            sumFM += s.currentMagForce;\n        });\n\n        const metricTension = latchedCount > 0 ? (sumTension / latchedCount) : 0;\n        const metricExt = Math.min(1.0, sumExt / (h * PRE_CONFIG.sphereCount * 0.4));\n\n        const maxSpringF = PRE_CONFIG.sphereCount * kp * h * 0.3;\n        const maxMagF = PRE_CONFIG.sphereCount * magStr;\n\n        const metricFS = Math.min(1.0, sumFS / maxSpringF);\n        const metricFM = Math.min(1.0, sumFM / maxMagF);\n\n        // Prepare Output\n        const vec = [metricTension, metricExt, metricFS, metricFM];\n\n        // UI Output (for Hero Node)\n        const uiData = {\n            plateY: state.plateY,\n            phase: state.phase,\n            sustainProgress: state.sustainProgress,\n            spheres: state.spheres.map(s => ({\n                x: s.x, y: s.y, r: s.radius,\n                l: s.isLatched, t: s.tensionRatio\n            })),\n            adsr: { attack, decay, sustain, release, peak },\n            seed: seed // Added seed to UI data\n        };\n\n        return {\n            outputs: {\n                env: metricTension,\n                vec: vec,\n                ch1: metricTension,\n                ch2: metricExt,\n                ch3: metricFS,\n                ch4: metricFM\n            },\n            ui: uiData\n        };\n    },\n    compileConfig: (uiConfig: { seed?: number }) => ({\n        seed: uiConfig?.seed ?? 1337\n    })\n});\n\nregisterNode(magneto);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport {\n  midiStreamType,\n  sequenceStructorType,\n} from \"../../structor/std-types\";\nimport { MidiEvent } from \"../../io/midi/types\";\nimport { Step } from \"./types\";\n\nconst SEQUENCE_LENGTH = 16;\n\n/**\n * seq.tomidi (formerly nicepattern.pattern)\n * Combines multiple sequences into a MIDI stream.\n */\ninterface SeqToMidiInputs {\n  seq_in: Step[][]; // Array of Sequences (from multi-connection)\n}\n\ninterface SeqToMidiState {\n  sequenceStates: Map<number, {\n    lastStepIndex: number;\n    lastNoteIndex: number | null;\n    lastHold: boolean;\n    activeNotes: Map<number, number>;\n  }>;\n}\n\n// explicit 'any' generic removed - using strict inference\nexport const tomidi = defineNode({\n  id: \"seq.tomidi\",\n  version: \"1.0.0\",\n  displayName: \"To MIDI\",\n  metadata: {\n    category: 'Sequence',\n    keywords: ['pattern', 'sequencer', 'combiner', 'event', 'midi'],\n    description: 'Converts sequence(s) into a MIDI stream.'\n  },\n  config: {},\n  inputs: {\n    seq_in: {\n      type: sequenceStructorType,\n      description: \"Input sequence(s)\",\n      allowMultiConnection: true\n    }\n  },\n  outputs: { midi_out: midiStreamType },\n  autoBroadcast: true,\n  reshape: 'none',\n  isRealtime: () => true,\n  createState: (): SeqToMidiState => ({\n    sequenceStates: new Map()\n  }),\n  execute: (inputs, config, context, state) => {\n    // Inputs are strictly typed now!\n    // inputs.seq_in is inferred as Step[][] because sequenceStructorType is array of Step\n    // Updated definition means seqs is correctly inferred as Step[][]\n    const rawSeqs = (inputs.seq_in || []) as any[];\n\n    // Normalize inputs: Handle potential double-wrapping (Step[][][] -> Step[][])\n    let seqs = rawSeqs;\n    if (seqs.length === 1 && Array.isArray(seqs[0]) && seqs[0].length > 0 && Array.isArray(seqs[0][0])) {\n      seqs = seqs[0];\n    }\n\n    const stream: MidiEvent[] = [];\n    const stepsPerBeat = 4;\n    const absoluteStep = Math.floor(context.clock.beat * stepsPerBeat);\n    const currentStepIndex = ((absoluteStep % SEQUENCE_LENGTH) + SEQUENCE_LENGTH) % SEQUENCE_LENGTH;\n\n    // Process all sequences (both current inputs and previously active ones)\n    const seqIndices = new Set<number>();\n    seqs.forEach((_, i) => seqIndices.add(i));\n    state.sequenceStates.forEach((_, i) => seqIndices.add(i));\n\n    for (const seqIndex of seqIndices) {\n      const seq = seqs[seqIndex]; // Step[] | undefined\n\n      // Initialize state for this sequence if missing\n      if (!state.sequenceStates.has(seqIndex)) {\n        state.sequenceStates.set(seqIndex, {\n          lastStepIndex: -1,\n          lastNoteIndex: null,\n          lastHold: false,\n          activeNotes: new Map<number, number>()\n        });\n      }\n      const seqState = state.sequenceStates.get(seqIndex)!;\n\n      // If seq is gone and no active note, cleanup\n      if (!seq && seqState.lastNoteIndex === null) {\n        state.sequenceStates.delete(seqIndex);\n        continue;\n      }\n\n      let currentStep: { noteIndex: number | null, velocity: number, hold: boolean } = { noteIndex: null, velocity: 0, hold: false };\n\n      if (seq && seq[currentStepIndex]) {\n        currentStep = seq[currentStepIndex];\n      }\n\n      // Check if we need to update\n      if (currentStepIndex !== seqState.lastStepIndex || !seq || currentStep.noteIndex !== seqState.lastNoteIndex) {\n\n        const lastNoteIndex = seqState.lastNoteIndex;\n        const lastHold = seqState.lastHold;\n\n        const isNoteActive = currentStep.noteIndex !== null && currentStep.noteIndex !== undefined;\n        const isSameNote = isNoteActive && currentStep.noteIndex === lastNoteIndex;\n\n        const shouldRelease = (lastNoteIndex !== null) && (!isSameNote || !lastHold);\n        const shouldTrigger = isNoteActive && (!isSameNote || !lastHold);\n\n        if (shouldRelease && lastNoteIndex !== null) {\n          stream.push({\n            type: 'note_off',\n            note: lastNoteIndex,\n            velocity: 0,\n            channel: 1,\n            deviceId: 'tomidi',\n            time: 0\n          });\n          seqState.activeNotes.delete(lastNoteIndex);\n          seqState.lastNoteIndex = null;\n          seqState.lastHold = false;\n        }\n\n        if (shouldTrigger && currentStep.noteIndex !== null) {\n          stream.push({\n            type: 'note_on',\n            note: currentStep.noteIndex,\n            velocity: currentStep.velocity,\n            channel: 1,\n            deviceId: 'tomidi',\n            time: 0\n          });\n          seqState.activeNotes.set(currentStep.noteIndex, currentStep.velocity);\n          seqState.lastNoteIndex = currentStep.noteIndex;\n          seqState.lastHold = currentStep.hold;\n        } else if (isSameNote && lastHold) {\n          seqState.lastHold = currentStep.hold;\n        }\n\n        seqState.lastStepIndex = currentStepIndex;\n      }\n    }\n\n    return { midi_out: stream };\n  },\n});\n\nregisterNode(tomidi);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport {\n  sequenceStructorType,\n  numberType,\n} from \"../../structor/std-types\";\nimport { Step } from \"./types\";\n\n/**\n * seq.sequencer\n * Hero Node - Step Sequencer Source\n */\ninterface SeqSequencerUIConfig {\n  values?: {\n    sequence?: Step[];\n  };\n}\n\ntype SeqSequencerCompiledConfig = {\n  sequence: Step[];\n};\n\ninterface SequencerState {\n  currentStepIndex: number;\n}\n\nexport const sequencer = defineNode({\n  id: \"seq.sequencer\",\n  version: \"1.0.0\",\n  displayName: \"Sequencer\",\n  metadata: {\n    category: 'Sequence',\n    keywords: ['sequencer', 'step', 'pattern'],\n    description: '16-step sequencer.'\n  },\n  config: {\n    sequence: {\n      kind: 'array',\n      size: 16,\n      element: { kind: 'record', fields: { noteIndex: numberType, velocity: numberType, hold: { kind: 'atomic', type: 'boolean' } } }\n    }\n  },\n  inputs: {},\n  outputs: { seq_out: sequenceStructorType },\n  ui: {\n    // Body renderer registered in ui-registration.ts\n  },\n\n  compileConfig: (uiConfig: SeqSequencerUIConfig) => {\n    // Default sequence: 16 empty steps\n    const defaultSeq = Array(16).fill({ noteIndex: null, velocity: 0, hold: false });\n    return {\n      sequence: uiConfig?.values?.sequence ?? defaultSeq\n    };\n  },\n\n  createState: (): SequencerState => ({\n    currentStepIndex: 0\n  }),\n\n  // Not realtime anymore, purely static configuration unless updated\n  isRealtime: () => false,\n\n  execute: (inputs, config, context, state) => {\n    // We are NOT realtime, so we rely on invalidation/config updates.\n    // However, GraphExecutor calls execute at least once during init loop if dirty.\n\n    // config.sequence is the Array Record of current Pattern\n    const defaultSeq = Array(16).fill({ noteIndex: null, velocity: 0, hold: false });\n    const sequenceRaw = config.sequence || defaultSeq;\n\n    // GraphExecutor/definePrimitiveNode expects raw values. It performs the Structor marshalling.\n    // If we return { fields: ... }, toStructor will look for properties on the fields wrapper and fail.\n    // So we just return the raw sequence (or a mapped version if we needed to transform it).\n    // The sequenceRaw from config is already in the correct shape { noteIndex, velocity, hold }.\n\n    return {\n      outputs: { seq_out: sequenceRaw },\n      ui: {\n        currentStepIndex: state.currentStepIndex\n      }\n    };\n  }\n});\n\nregisterNode(sequencer);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport {\n  midiStreamType,\n  sequenceStructorType,\n  numberType,\n} from \"../../structor/std-types\";\nimport { MidiEvent } from \"../../io/midi/types\";\nimport { Step } from \"./types\";\n\ninterface SeqOneShotInputs {\n  seq_in: Step[];\n  trigger: MidiEvent[];\n  duration: number;\n}\n\ninterface SeqOneShotState {\n  isPlaying: boolean;\n  startTime: number;\n  lastStepIndex: number;\n  lastNoteIndex: number | null;\n  lastHold: boolean;\n  activeNotes: Map<number, number>;\n}\n\nexport const oneshot = defineNode({\n  id: \"seq.oneshot\",\n  version: \"1.0.0\",\n  displayName: \"One Shot\",\n  metadata: {\n    category: 'Sequence',\n    keywords: ['player', 'trigger', 'oneshot', 'envelope'],\n    description: 'Plays a sequence once upon trigger.'\n  },\n  config: {},\n  autoBroadcast: {\n    seq_in: { combine: { reduce: 'first' } },\n    trigger: { combine: { reduce: 'flatten' } }\n  },\n  reshape: 'none',\n  inputs: {\n    seq_in: { type: sequenceStructorType, description: \"Input sequence\" },\n    trigger: { type: midiStreamType, description: \"Trigger\", allowMultiConnection: true },\n    duration: { type: numberType, defaultValue: 4.0, description: \"Duration (s)\" }\n  },\n  outputs: { midi_out: midiStreamType },\n  isRealtime: () => true,\n  createState: (): SeqOneShotState => ({\n    isPlaying: false,\n    startTime: 0,\n    lastStepIndex: -1,\n    lastNoteIndex: null,\n    lastHold: false,\n    activeNotes: new Map()\n  }),\n  execute: (inputs, config, context, state) => {\n    // Process Trigger (Polyphonic aware)\n    // Flattening handled by autoBroadcast.trigger.combine.reduce = 'flatten'\n    const allEvents = (inputs.trigger || []) as MidiEvent[];\n    let triggered = false;\n\n    for (const e of allEvents) {\n      if (e && e.type === 'note_on' && e.velocity > 0) {\n        triggered = true;\n        break;\n      }\n    }\n\n\n    // Use audio time (seconds) for duration-based playback\n    const currentTime = context.audio?.context?.currentTime ?? 0;\n\n    if (triggered) {\n      state.isPlaying = true;\n      state.startTime = currentTime;\n    }\n\n    const seq = inputs.seq_in || [];\n\n    const stream: MidiEvent[] = [];\n\n    if (!state.isPlaying || !seq || seq.length === 0) {\n      if (state.lastNoteIndex !== null) {\n        stream.push({ type: 'note_off', note: state.lastNoteIndex, velocity: 0, channel: 1, time: 0, deviceId: 'oneshot' });\n        state.lastNoteIndex = null;\n        state.lastHold = false;\n      }\n      if (state.activeNotes.size > 0) {\n        state.activeNotes.clear();\n      }\n      return { midi_out: stream };\n    }\n\n    const duration = Math.max(0.001, inputs.duration ?? 4.0);\n    const elapsed = currentTime - state.startTime;\n    const t = elapsed / duration;\n\n    if (t >= 1.0) {\n      state.isPlaying = false;\n      if (state.lastNoteIndex !== null) {\n        stream.push({ type: 'note_off', note: state.lastNoteIndex, velocity: 0, channel: 1, time: 0, deviceId: 'oneshot' });\n        state.lastNoteIndex = null;\n        state.lastHold = false;\n      }\n      return { midi_out: stream };\n    }\n\n    const stepCount = seq.length;\n    const currentStepIndex = Math.floor(t * stepCount);\n\n    let currentStep: Step = { noteIndex: null, velocity: 0, hold: false };\n    if (seq[currentStepIndex]) {\n      currentStep = seq[currentStepIndex];\n    }\n\n    if (currentStepIndex !== state.lastStepIndex || currentStep.noteIndex !== state.lastNoteIndex) {\n      const lastNoteIndex = state.lastNoteIndex;\n      const lastHold = state.lastHold;\n      const isNoteActive = currentStep.noteIndex !== null;\n      const isSameNote = isNoteActive && currentStep.noteIndex === lastNoteIndex;\n\n      const shouldRelease = (lastNoteIndex !== null) && (!isSameNote || !lastHold);\n      const shouldTrigger = isNoteActive && (!isSameNote || !lastHold);\n\n      if (shouldRelease && lastNoteIndex !== null) {\n        stream.push({ type: 'note_off', note: lastNoteIndex, velocity: 0, channel: 1, time: 0, deviceId: 'oneshot' });\n        state.activeNotes.delete(lastNoteIndex);\n        state.lastNoteIndex = null;\n        state.lastHold = false;\n      }\n\n      if (shouldTrigger && currentStep.noteIndex !== null) {\n        stream.push({ type: 'note_on', note: currentStep.noteIndex, velocity: currentStep.velocity, channel: 1, time: 0, deviceId: 'oneshot' });\n        state.activeNotes.set(currentStep.noteIndex, currentStep.velocity);\n        state.lastNoteIndex = currentStep.noteIndex;\n        state.lastHold = currentStep.hold;\n      } else if (isSameNote && lastHold) {\n        state.lastHold = currentStep.hold;\n      }\n      state.lastStepIndex = currentStepIndex;\n    }\n\n    return { midi_out: stream };\n  }\n});\n\n\ninterface SeqScanInputs {\n  seq_in: Step[];\n  pos: number;\n}\n\ninterface SeqScanState {\n  lastStepIndex: number;\n  lastNoteIndex: number | null;\n  lastHold: boolean;\n  activeNotes: Map<number, number>;\n}\n\nexport const scan = defineNode({\n  id: \"seq.scan\",\n  version: \"1.0.0\",\n  displayName: \"Scan Sequence\",\n  metadata: {\n    category: 'Sequence',\n    keywords: ['player', 'scan', 'scrub'],\n    description: 'Plays a sequence by scanning through positions.'\n  },\n  config: {},\n  autoBroadcast: {\n    seq_in: { combine: { reduce: 'first' } }\n  },\n  reshape: 'none',\n  inputs: {\n    seq_in: { type: sequenceStructorType, description: \"Input sequence\" },\n    pos: { type: numberType, defaultValue: 0, description: \"Position (0-1)\" }\n  },\n  outputs: { midi_out: midiStreamType },\n  isRealtime: () => true,\n  createState: (): SeqScanState => ({\n    lastStepIndex: -1,\n    lastNoteIndex: null,\n    lastHold: false,\n    activeNotes: new Map()\n  }),\n  execute: (inputs, config, context, state) => {\n    // strict\n    const seq = (inputs.seq_in || []) as Step[];\n    const pos = inputs.pos ?? 0;\n    const stream: MidiEvent[] = [];\n\n    if (!seq || seq.length === 0 || pos >= 1.0 || pos < 0) {\n      if (state.lastNoteIndex !== null) {\n        stream.push({ type: 'note_off', note: state.lastNoteIndex, velocity: 0, channel: 1, time: 0, deviceId: 'scan' });\n        state.lastNoteIndex = null;\n        state.lastHold = false;\n      }\n      return { midi_out: stream };\n    }\n\n    const stepCount = seq.length;\n    const currentStepIndex = Math.floor(pos * stepCount);\n\n    let currentStep: Step = { noteIndex: null, velocity: 0, hold: false };\n    if (seq[currentStepIndex]) {\n      currentStep = seq[currentStepIndex];\n    }\n\n    if (currentStepIndex !== state.lastStepIndex || currentStep.noteIndex !== state.lastNoteIndex) {\n      const lastNoteIndex = state.lastNoteIndex;\n      const lastHold = state.lastHold;\n      const isNoteActive = currentStep.noteIndex !== null;\n      const isSameNote = isNoteActive && currentStep.noteIndex === lastNoteIndex;\n\n      const shouldRelease = (lastNoteIndex !== null) && (!isSameNote || !lastHold);\n      const shouldTrigger = isNoteActive && (!isSameNote || !lastHold);\n\n      if (shouldRelease && lastNoteIndex !== null) {\n        stream.push({ type: 'note_off', note: lastNoteIndex, velocity: 0, channel: 1, time: 0, deviceId: 'scan' });\n        state.lastNoteIndex = null;\n        state.lastHold = false;\n      }\n\n      if (shouldTrigger && currentStep.noteIndex !== null) {\n        stream.push({ type: 'note_on', note: currentStep.noteIndex, velocity: currentStep.velocity, channel: 1, time: 0, deviceId: 'scan' });\n        state.lastNoteIndex = currentStep.noteIndex;\n        state.lastHold = currentStep.hold;\n      } else if (isSameNote && lastHold) {\n        state.lastHold = currentStep.hold;\n      }\n      state.lastStepIndex = currentStepIndex;\n    }\n\n    return { midi_out: stream };\n  }\n});\n\nregisterNode(oneshot);\nregisterNode(scan);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport {\n  sequenceStructorType,\n  numberType,\n} from \"../../structor/std-types\";\nimport { StringType } from \"../../structor/type-helpers\";\nimport { StructorType } from \"../../structor/structor\";\nimport { Step } from \"./types\";\n\ninterface SeqCropInputs {\n  seq_in: Step[];\n  trigger: any[]; // Ignored, just signature match\n  duration: number;\n  start?: number;\n  end?: number; // For start-end mode\n  length?: number; // For start-length mode\n}\n\ninterface SeqFillInputs {\n  count?: number;\n  start?: number;\n  end?: number;\n  length?: number;\n}\n\ninterface SeqCropUIConfig {\n  mode?: string;\n  values?: Record<string, any>;\n}\n\ninterface SeqFillUIConfig {\n  mode?: string;\n  count?: number;\n  values?: Record<string, any>;\n}\n\nexport const crop = defineNode({\n  id: \"seq.crop\",\n  version: \"1.0.0\",\n  displayName: \"Crop Sequence\",\n  metadata: {\n    category: 'Sequence',\n    keywords: ['modifier', 'crop', 'slice'],\n    description: 'Mutes steps outside the specified range.'\n  },\n  config: {\n    mode: { kind: 'atomic', type: 'string', defaultValue: 'start-end' }\n  },\n  autoBroadcast: {\n    seq_in: { combine: { reduce: 'first' } }\n  },\n  inputs: {\n    seq_in: { type: sequenceStructorType, description: \"Input sequence\" },\n    start: { type: numberType, defaultValue: 0 },\n    end: { type: numberType, defaultValue: 1, optional: true },\n    length: { type: numberType, defaultValue: 1, optional: true }\n  },\n  outputs: { seq_out: sequenceStructorType },\n  ui: {\n    inspector: {\n      fields: [\n        {\n          type: 'tab-bar', label: 'Mode', path: 'mode',\n          options: [{ label: 'Start / End', value: 'start-end' }, { label: 'Start / Length', value: 'start-length' }]\n        }\n      ]\n    }\n  },\n  computeForwardPorts: (inputTypes, uiConfig) => {\n    // Access mode from top-level config (merged by GraphExecutor)\n    const mode = uiConfig.mode || 'start-end';\n\n    const fields: Record<string, StructorType> = {\n      seq_in: sequenceStructorType,\n      start: { ...numberType, defaultValue: 0 }\n    };\n    if (mode === 'start-length') {\n      fields['length'] = { ...numberType, defaultValue: 1 };\n    } else {\n      fields['end'] = { ...numberType, defaultValue: 1 };\n    }\n    return { inputs: { kind: 'record', fields }, outputs: { kind: 'record', fields: { seq_out: sequenceStructorType } } };\n  },\n\n  shouldRecompileOnConfigChange: () => true,\n  compileConfig: (uiConfig: SeqCropUIConfig) => ({\n    // Return Flat Data Structure\n    mode: uiConfig.mode || 'start-end'\n  }),\n\n  execute: (inputs, config) => {\n    // Inputs are strictly typed\n    const seq = inputs.seq_in || [];\n\n    // Correctly inferred config\n    const mode = config.mode || 'start-end';\n\n    // Deep clone is safer\n    const outSeq = seq.map(s => ({ ...s }));\n\n    const start = inputs.start ?? 0;\n    let end = 1;\n\n    if (mode === 'start-length') {\n      const length = inputs.length ?? 1;\n      end = start + length;\n    } else {\n      end = inputs.end ?? 1;\n    }\n    if (end < start) end = start;\n\n    const len = outSeq.length;\n    for (let i = 0; i < len; i++) {\n      const pos = i / len;\n      // Inclusive range? pos >= start && pos < end\n      if (pos < start || pos >= end) {\n        outSeq[i].noteIndex = null;\n        outSeq[i].velocity = 0;\n        outSeq[i].hold = false;\n      }\n    }\n\n    return { seq_out: outSeq };\n  }\n});\n\nexport const fill = defineNode({\n  id: \"seq.fill\",\n  version: \"1.0.0\",\n  displayName: \"Fill Sequence\",\n  metadata: {\n    category: 'Sequence',\n    keywords: ['generator', 'fill', 'range'],\n    description: 'Generates a sequence where steps inside the specified range are ON.'\n  },\n  config: {\n    mode: { kind: 'atomic', type: 'string', defaultValue: 'start-length' },\n    count: { ...numberType, defaultValue: 16 }\n  },\n  inputs: {\n    start: { type: numberType, defaultValue: 0 },\n    end: { type: numberType, defaultValue: 1, optional: true },\n    length: { type: numberType, defaultValue: 0.5, optional: true }\n  },\n  outputs: { seq_out: sequenceStructorType },\n  ui: {\n    inspector: {\n      fields: [\n        {\n          type: 'tab-bar', label: 'Mode', path: 'mode',\n          options: [{ label: 'Start / End', value: 'start-end' }, { label: 'Start / Length', value: 'start-length' }],\n          default: 'start-length'\n        },\n        { type: 'number', label: 'Step Count', path: 'count', min: 1, max: 128, step: 1, default: 16 }\n      ]\n    }\n  },\n  computeForwardPorts: (inputTypes, uiConfig) => {\n    const mode = uiConfig.mode || 'start-length';\n    const fields: Record<string, StructorType> = {\n      start: { ...numberType, defaultValue: 0 }\n    };\n    if (mode === 'start-length') {\n      fields['length'] = { ...numberType, defaultValue: 0.5 };\n    } else {\n      fields['end'] = { ...numberType, defaultValue: 1 };\n    }\n    return { inputs: { kind: 'record', fields }, outputs: { kind: 'record', fields: { seq_out: sequenceStructorType } } };\n  },\n\n  shouldRecompileOnConfigChange: () => true,\n  compileConfig: (uiConfig: SeqFillUIConfig) => ({\n    mode: uiConfig.mode || 'start-length',\n    count: uiConfig.count ?? 16\n  }),\n\n  execute: (inputs, config) => {\n    // Inputs are strictly typed\n    const count = config.count ?? 16;\n    const mode = config.mode || 'start-length';\n\n    // Initialize sequence\n    const outSeq: Step[] = [];\n    for (let i = 0; i < count; i++) {\n      outSeq.push({ noteIndex: null, velocity: 0, hold: false });\n    }\n\n    const startVal = inputs.start ?? 0;\n\n    if (mode === 'start-length') {\n      const lengthVal = inputs.length ?? 0.5;\n      // Integer-based logic: Fixed number of ON steps\n      const numOn = Math.round(lengthVal * count);\n      const startIndex = Math.floor(startVal * count);\n\n      for (let i = 0; i < numOn; i++) {\n        // No wrapping: Truncate at end\n        const idx = startIndex + i;\n\n        if (idx >= 0 && idx < count) {\n          outSeq[idx] = { noteIndex: 60, velocity: 1, hold: false };\n        }\n      }\n    } else {\n      // Start-End Mode: Standard Range Logic (Inclusive-Exclusive)\n      const endVal = inputs.end ?? 1;\n      // Handle wrapping for start > end ? Or simple clamp/min?\n      // Basic implementation: Linear range.\n      let actualStart = startVal;\n      let actualEnd = endVal;\n      if (actualEnd < actualStart) actualEnd = actualStart; // Clamp\n\n      for (let i = 0; i < count; i++) {\n        const pos = i / count;\n        if (pos >= actualStart && pos < actualEnd) {\n          outSeq[i] = { noteIndex: 60, velocity: 1, hold: false };\n        }\n      }\n    }\n\n    return { seq_out: outSeq };\n  }\n});\n\nregisterNode(crop);\nregisterNode(fill);\n","import { defineNode, registerNode } from \"../../structor/node-helpers\";\nimport {\n  sequenceStructorType,\n  numberType,\n} from \"../../structor/std-types\";\nimport { Step } from \"./types\";\n\ninterface SeqBinaryOpInputs {\n  inputs: Step[][]; // Collection of sequences\n}\n\ninterface SeqNegateInputs {\n  seq_in: Step[];\n}\n\nconst EmptyStep: Step = { noteIndex: null, velocity: 0, hold: false };\nconst isActive = (s: Step) => s.noteIndex !== null && s.noteIndex !== undefined;\n\nconst createBinaryOpNode = (\n  id: string,\n  displayName: string,\n  description: string,\n  op: (a: Step, b: Step) => Step\n) => defineNode({\n  id: `seq.${id}`,\n  version: \"1.0.0\",\n  displayName,\n  metadata: { category: 'Sequence', keywords: ['logic', id, 'binary'], description },\n  config: {},\n  inputs: {\n    inputs: {\n      type: sequenceStructorType,\n      description: \"Sequences\",\n      allowMultiConnection: true\n    }\n  },\n  outputs: { seq_out: sequenceStructorType },\n  execute: (inputs) => {\n    // strict inference\n    const seqs = (inputs.inputs || []) as Step[][];\n    if (seqs.length === 0) return { seq_out: [] };\n\n    // Find max length for wrapping\n    let len = 0;\n    seqs.forEach(s => len = Math.max(len, s.length));\n    if (len === 0) return { seq_out: [] };\n\n    const outSeq: Step[] = [];\n\n    for (let i = 0; i < len; i++) {\n      // Start with Empty/Inactive accumulator\n      let acc: Step = { ...EmptyStep };\n\n      const firstSeq = seqs[0];\n      if (firstSeq.length > 0) {\n        acc = { ...firstSeq[i % firstSeq.length] };\n      } else {\n        acc = { ...EmptyStep };\n      }\n\n      for (let j = 1; j < seqs.length; j++) {\n        const seq = seqs[j];\n        const stepB = (seq.length > 0) ? seq[i % seq.length] : EmptyStep;\n        acc = op(acc, stepB);\n      }\n\n      outSeq.push(acc);\n    }\n\n    return { seq_out: outSeq };\n  }\n});\n\nexport const xor = createBinaryOpNode(\n  'xor', 'Sequence XOR', 'XORs multiple sequences.',\n  (a, b) => {\n    const aActive = isActive(a);\n    const bActive = isActive(b);\n    return (aActive !== bActive) ? (bActive ? b : a) : { ...EmptyStep };\n  }\n);\n\nexport const sub = createBinaryOpNode(\n  'sub', 'Sequence Subtract', 'Subtracts subsequent sequences from the first.',\n  (a, b) => isActive(b) ? { ...EmptyStep } : a\n);\n\nexport const and = createBinaryOpNode(\n  'and', 'Sequence AND', 'Output active only if both inputs active.',\n  (a, b) => (isActive(a) && isActive(b)) ? b : { ...EmptyStep }\n);\n\nexport const or = createBinaryOpNode(\n  'or', 'Sequence OR', 'Output active if any input active.',\n  (a, b) => isActive(b) ? b : a\n);\n\n// strict\nexport const negate = defineNode({\n  id: \"seq.negate\",\n  version: \"1.0.0\",\n  displayName: \"Sequence Negate\",\n  metadata: { category: 'Sequence', keywords: ['logic', 'not', 'invert'], description: 'Inverts sequence activity.' },\n  config: {},\n  autoBroadcast: {\n    seq_in: { combine: { reduce: 'first' } }\n  },\n  inputs: {\n    seq_in: { type: sequenceStructorType }\n  },\n  outputs: { seq_out: sequenceStructorType },\n  execute: (inputs) => {\n    // strict\n    const seq = (inputs.seq_in || []) as Step[];\n    const outSeq = seq.map((s) => {\n      const step: Step = { ...s };\n\n      if (step.noteIndex !== null) {\n        step.noteIndex = null;\n        step.velocity = 0;\n        step.hold = false;\n      } else {\n        // Toggle ON (default 60, full vel)\n        step.noteIndex = 60;\n        step.velocity = 1;\n        step.hold = false;\n      }\n      return step;\n    });\n\n    return { seq_out: outSeq };\n  }\n});\n\nregisterNode(xor);\nregisterNode(sub);\nregisterNode(and);\nregisterNode(or);\nregisterNode(negate);\n","import { registerNode } from '../node-helpers';\nimport { defineMathNode, definePrimitiveNode } from '../type-helpers';\nimport { NodeCategory } from '../structor';\nimport { numberType } from '../std-types';\n\nexport const primitive_add = defineMathNode(\n  'math.add',\n  { category: NodeCategory.Math, keywords: ['sum', 'plus'], description: 'Adds a and b.' },\n  (a, b) => a + b\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_add,\n  displayName: 'Add',\n  aliases: ['plus', 'sum'],\n  extendedInputs: {\n    a: { type: numberType, description: 'Value A' },\n    b: { type: numberType, description: 'Value B' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Sum' }\n  }\n});\n\nexport const primitive_subtract = defineMathNode(\n  'math.subtract',\n  { category: NodeCategory.Math, keywords: ['minus', 'difference'], description: 'Subtracts b from a.' },\n  (a, b) => a - b\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_subtract,\n  displayName: 'Subtract',\n  aliases: ['minus', 'difference'],\n  extendedInputs: {\n    a: { type: numberType, description: 'Minuend' },\n    b: { type: numberType, description: 'Subtrahend' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Result' }\n  }\n});\n\nexport const primitive_multiply = defineMathNode(\n  'math.multiply',\n  { category: NodeCategory.Math, keywords: ['times', 'product'], description: 'Multiplies a and b.' },\n  (a, b) => a * b\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_multiply,\n  displayName: 'Multiply',\n  aliases: ['times', 'product'],\n  extendedInputs: {\n    a: { type: numberType, description: 'Factor A' },\n    b: { type: numberType, description: 'Factor B' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Product' }\n  }\n});\n\nexport const primitive_divide = defineMathNode(\n  'math.divide',\n  { category: NodeCategory.Math, keywords: ['div', 'quotient'], description: 'Divides a by b.' },\n  (a, b) => a / b\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_divide,\n  displayName: 'Divide',\n  aliases: ['div', 'quotient'],\n  extendedInputs: {\n    a: { type: numberType, description: 'Dividend' },\n    b: { type: numberType, description: 'Divisor' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Quotient' }\n  }\n});\n\nexport const primitive_pow = defineMathNode(\n  'math.pow',\n  { category: NodeCategory.Math, keywords: ['power', 'exponent'], description: 'Raises a to the power of b.' },\n  (a, b) => Math.pow(a, b)\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_pow,\n  displayName: 'Power',\n  extendedInputs: {\n    a: { type: numberType, description: 'Base' },\n    b: { type: numberType, description: 'Exponent' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Result' }\n  }\n});\n\nexport const primitive_min = defineMathNode(\n  'math.min',\n  { category: NodeCategory.Math, keywords: ['minimum', 'smallest'], description: 'Returns the smaller of a and b.' },\n  (a, b) => Math.min(a, b)\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_min,\n  displayName: 'Min',\n  extendedInputs: {\n    a: { type: numberType, description: 'Value A' },\n    b: { type: numberType, description: 'Value B' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Minimum' }\n  }\n});\n\nexport const primitive_max = defineMathNode(\n  'math.max',\n  { category: NodeCategory.Math, keywords: ['maximum', 'largest'], description: 'Returns the larger of a and b.' },\n  (a, b) => Math.max(a, b)\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_max,\n  displayName: 'Max',\n  extendedInputs: {\n    a: { type: numberType, description: 'Value A' },\n    b: { type: numberType, description: 'Value B' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Maximum' }\n  }\n});\n\nexport const primitive_fmod = definePrimitiveNode({\n  id: 'math.fmod',\n  metadata: {\n    category: NodeCategory.Math,\n    keywords: ['modulo', 'remainder'],\n    description: 'Floating point modulo operation.'\n  },\n  inputs: { dividend: numberType, divisor: numberType },\n  outputs: { div: numberType, mod: numberType },\n  autoBroadcast: true,\n  execute: (inputs, config, context) => {\n    const { dividend, divisor } = inputs;\n    const div = Math.floor(dividend / divisor);\n    const mod = dividend % divisor;\n    return { div, mod };\n  }\n});\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_fmod,\n  displayName: 'FMod',\n  extendedInputs: {\n    dividend: { type: numberType, description: 'Dividend' },\n    divisor: { type: numberType, description: 'Divisor', defaultValue: 1, range: [0, 10] }\n  },\n  extendedOutputs: {\n    div: { type: numberType, description: 'The integer division result.' },\n    mod: { type: numberType, description: 'The remainder.' }\n  }\n});\n\n// Logic\n\nexport const primitive_and = defineMathNode(\n  'logic.and',\n  { category: NodeCategory.Logic, keywords: ['boolean', '&&'], description: 'Logical AND (1 if both non-zero, else 0).' },\n  (a, b) => (a !== 0 && b !== 0) ? 1 : 0\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_and,\n  displayName: 'AND',\n  extendedInputs: {\n    a: { type: numberType, description: 'Value A' },\n    b: { type: numberType, description: 'Value B' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Result' }\n  }\n});\n\nexport const primitive_or = defineMathNode(\n  'logic.or',\n  { category: NodeCategory.Logic, keywords: ['boolean', '||'], description: 'Logical OR (1 if either non-zero, else 0).' },\n  (a, b) => (a !== 0 || b !== 0) ? 1 : 0\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_or,\n  displayName: 'OR',\n  extendedInputs: {\n    a: { type: numberType, description: 'Value A' },\n    b: { type: numberType, description: 'Value B' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Result' }\n  }\n});\n\nexport const primitive_xor = defineMathNode(\n  'logic.xor',\n  { category: NodeCategory.Logic, keywords: ['boolean', '^'], description: 'Logical XOR (1 if different truthiness, else 0).' },\n  (a, b) => ((a !== 0) !== (b !== 0)) ? 1 : 0\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_xor,\n  displayName: 'XOR',\n  extendedInputs: {\n    a: { type: numberType, description: 'Value A' },\n    b: { type: numberType, description: 'Value B' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Result' }\n  }\n});\n\nexport const primitive_equals = defineMathNode(\n  'logic.equals',\n  { category: NodeCategory.Logic, keywords: ['==', 'equality'], description: 'Returns 1 if a equals b, else 0.' },\n  (a, b) => (a === b) ? 1 : 0\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_equals,\n  displayName: 'Equals',\n  extendedInputs: {\n    a: { type: numberType, description: 'Value A' },\n    b: { type: numberType, description: 'Value B' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Result' }\n  }\n});\n\nexport const primitive_greater_than = defineMathNode(\n  'logic.greater_than',\n  { category: NodeCategory.Logic, keywords: ['>', 'gt'], description: 'Returns 1 if a > b, else 0.' },\n  (a, b) => (a > b) ? 1 : 0\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_greater_than,\n  displayName: 'Greater Than',\n  extendedInputs: {\n    a: { type: numberType, description: 'Value A' },\n    b: { type: numberType, description: 'Value B' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Result' }\n  }\n});\n\nexport const primitive_less_than = defineMathNode(\n  'logic.less_than',\n  { category: NodeCategory.Logic, keywords: ['<', 'lt'], description: 'Returns 1 if a < b, else 0.' },\n  (a, b) => (a < b) ? 1 : 0\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_less_than,\n  displayName: 'Less Than',\n  extendedInputs: {\n    a: { type: numberType, description: 'Value A' },\n    b: { type: numberType, description: 'Value B' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Result' }\n  }\n});\n","import { registerNode } from '../node-helpers';\nimport { defineMathNode } from '../type-helpers';\nimport { NodeCategory } from '../structor';\nimport { numberType } from '../std-types';\n\nexport const primitive_abs = defineMathNode(\n  'math.abs',\n  { category: NodeCategory.Math, keywords: ['absolute', 'magnitude'], description: 'Returns the absolute value of a.' },\n  (a) => Math.abs(a),\n  'unary'\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_abs,\n  displayName: 'Abs',\n  extendedInputs: { a: { type: numberType, description: 'Value' } },\n  extendedOutputs: { result: { type: numberType, description: 'Absolute Value' } }\n});\n\nexport const primitive_negate = defineMathNode(\n  'math.negate',\n  { category: NodeCategory.Math, keywords: ['negative', 'invert'], description: 'Negates a.' },\n  (a) => -a,\n  'unary'\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_negate,\n  displayName: 'Negate',\n  extendedInputs: { a: { type: numberType, description: 'Value' } },\n  extendedOutputs: { result: { type: numberType, description: 'Negated Value' } }\n});\n\nexport const primitive_ceil = defineMathNode(\n  'math.ceil',\n  { category: NodeCategory.Math, keywords: ['ceiling', 'round up'], description: 'Rounds a up to the nearest integer.' },\n  (a) => Math.ceil(a),\n  'unary'\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_ceil,\n  displayName: 'Ceil',\n  extendedInputs: { a: { type: numberType, description: 'Value' } },\n  extendedOutputs: { result: { type: numberType, description: 'Ceiling' } }\n});\n\nexport const primitive_floor = defineMathNode(\n  'math.floor',\n  { category: NodeCategory.Math, keywords: ['floor', 'round down'], description: 'Rounds a down to the nearest integer.' },\n  (a) => Math.floor(a),\n  'unary'\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_floor,\n  displayName: 'Floor',\n  extendedInputs: { a: { type: numberType, description: 'Value' } },\n  extendedOutputs: { result: { type: numberType, description: 'Floor' } }\n});\n\nexport const primitive_round = defineMathNode(\n  'math.round',\n  { category: NodeCategory.Math, keywords: ['round', 'nearest'], description: 'Rounds a to the nearest integer.' },\n  (a) => Math.round(a),\n  'unary'\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_round,\n  displayName: 'Round',\n  extendedInputs: { a: { type: numberType, description: 'Value' } },\n  extendedOutputs: { result: { type: numberType, description: 'Rounded Value' } }\n});\n\nexport const primitive_sin = defineMathNode(\n  'math.sin',\n  { category: NodeCategory.Math, keywords: ['sine'], description: 'Returns the sine of a (radians).' },\n  (a) => Math.sin(a),\n  'unary'\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_sin,\n  displayName: 'Sin',\n  extendedInputs: { a: { type: numberType, description: 'Value (Radians)' } },\n  extendedOutputs: { result: { type: numberType, description: 'Sine' } }\n});\n\nexport const primitive_cos = defineMathNode(\n  'math.cos',\n  { category: NodeCategory.Math, keywords: ['cosine'], description: 'Returns the cosine of a (radians).' },\n  (a) => Math.cos(a),\n  'unary'\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_cos,\n  displayName: 'Cos',\n  extendedInputs: { a: { type: numberType, description: 'Value (Radians)' } },\n  extendedOutputs: { result: { type: numberType, description: 'Cosine' } }\n});\n\nexport const primitive_tan = defineMathNode(\n  'math.tan',\n  { category: NodeCategory.Math, keywords: ['tangent'], description: 'Returns the tangent of a (radians).' },\n  (a) => Math.tan(a),\n  'unary'\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_tan,\n  displayName: 'Tan',\n  extendedInputs: { a: { type: numberType, description: 'Value (Radians)' } },\n  extendedOutputs: { result: { type: numberType, description: 'Tangent' } }\n});\n\nexport const primitive_sqrt = defineMathNode(\n  'math.sqrt',\n  { category: NodeCategory.Math, keywords: ['square root'], description: 'Returns the square root of a.' },\n  (a) => Math.sqrt(a),\n  'unary'\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_sqrt,\n  displayName: 'Sqrt',\n  extendedInputs: { a: { type: numberType, description: 'Value' } },\n  extendedOutputs: { result: { type: numberType, description: 'Square Root' } }\n});\n\nexport const primitive_not = defineMathNode(\n  'logic.not',\n  { category: NodeCategory.Logic, keywords: ['!', 'invert'], description: 'Logical NOT (1 if zero, 0 if non-zero).' },\n  (a) => (a === 0) ? 1 : 0,\n  'unary'\n);\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_not,\n  displayName: 'NOT',\n  extendedInputs: { a: { type: numberType, description: 'Value' } },\n  extendedOutputs: { result: { type: numberType, description: 'Result' } }\n});\n","import { registerNode } from '../node-helpers';\nimport { definePrimitiveNode } from '../type-helpers';\nimport { NodeCategory, StructorType } from '../structor';\nimport { anyType, numberType } from '../std-types';\n\n// Helper for \"all\" nodes\nconst defineAllNode = (\n  id: string,\n  displayName: string,\n  op: (a: number, b: number) => number,\n  category: NodeCategory = NodeCategory.Math\n) => {\n  const def = definePrimitiveNode({\n    id,\n    metadata: { category, description: `Apply ${id.split('.').pop()} to all inputs.` },\n    // Allow multi-connection to collect multiple inputs into an array\n    inputs: { values: { kind: 'array', element: anyType, size: 'dynamic', allowMultiConnection: true } },\n    outputs: { result: numberType }, // Output is dynamic (scalar or vector)\n    computeForwardPorts: (inputTypes, config, context) => {\n      const valuesInput = inputTypes.fields['values'];\n      let outputType: StructorType = numberType;\n\n      // Check if we have an array of inputs (because of reduce/collect)\n      if (valuesInput && valuesInput.kind === 'array') {\n        // The element of the 'values' array represents the types of the connected cables.\n        const elementType = valuesInput.element;\n\n        if (elementType.kind === 'array') {\n          // Collection of Arrays (e.g. [Array<Number>])\n          outputType = elementType;\n        } else if (elementType.kind === 'record') {\n          // Collection of Records (e.g. [{x,y,z,w}])\n          // Propagate the record type!\n          outputType = elementType;\n        }\n      }\n\n      return {\n        inputs: { kind: 'record', fields: { values: valuesInput } },\n        outputs: { kind: 'record', fields: { result: outputType } }\n      };\n    },\n    execute: (inputs) => {\n      const values = inputs.values as any[];\n      if (!values || values.length === 0) return { result: 0 };\n\n      // Check if first element is array or Record Vector\n      const first = values[0];\n      const firstIsArray = Array.isArray(first);\n      let firstIsRecordVec = false;\n      let vecKeys: string[] = [];\n\n      if (!firstIsArray && typeof first === 'object' && first !== null) {\n        if (typeof first.x === 'number' && typeof first.y === 'number') {\n          firstIsRecordVec = true;\n          vecKeys = ['x', 'y'];\n          if (typeof first.z === 'number') vecKeys.push('z');\n          if (typeof first.w === 'number') vecKeys.push('w');\n        }\n      }\n\n      if (firstIsArray || firstIsRecordVec || typeof first === 'number') {\n        // Vector mode (Scalar is treated as 1D vector)\n        const length = firstIsArray ? first.length : (firstIsRecordVec ? vecKeys.length : 1);\n        const result = new Array(length);\n\n        for (let i = 0; i < length; i++) {\n          // Extract accumulator (first value)\n          let val = firstIsArray ? first[i] : (firstIsRecordVec ? first[vecKeys[i]] : first);\n\n\n          for (let j = 1; j < values.length; j++) {\n            const rawOperand = values[j];\n            let operand: number;\n\n            // Handle mixed types by broadcasting or extracting\n            if (Array.isArray(rawOperand)) {\n              operand = rawOperand[i] ?? 0; // Fallback? or NaN\n            } else if (typeof rawOperand === 'object' && rawOperand !== null && 'x' in rawOperand) {\n              // Assuming compatible record\n              // The following lines are from the user's instruction.\n              // Note: `config` and `input` are not directly available in this scope\n              // as they are in the `computeForwardPorts` method or a different node's `execute` method.\n              // Inserting them as requested, but they will likely cause runtime errors due to undefined variables.\n              // If the intent was to log something specific to this context, please provide the correct variables.\n              // const fields = (config as StructorRecord)?.fields; // `config` is not defined here\n              // const portName = (fields?.name as string) ?? 'value'; // `fields` is not defined here\n              // console.log(`DEBUG: io.input execute portName=${portName} inputKeys=${Object.keys(input.fields)}`); // `input` is `inputs` here, and `inputs.fields` is not the correct structure.\n\n              // Fallback? If fields is undefined, it means config was raw and uncompiled/unnormalized. fallback?\n              const key = vecKeys[i];\n              operand = (rawOperand as any)[key];\n              if (operand === undefined) operand = 0; // Safe fallback?\n            } else {\n              // Scalar broadcast\n              operand = rawOperand as number;\n            }\n\n            val = op(val, operand);\n          }\n          result[i] = val;\n        }\n\n        if (firstIsRecordVec) {\n          const resRecord: any = {};\n          vecKeys.forEach((k, i) => resRecord[k] = result[i]);\n          return { result: resRecord };\n        } else if (!firstIsArray) {\n          // Scalar input -> Scalar output\n          return { result: result[0] };\n        }\n\n        return { result };\n      } else {\n        // General fallback for mixed types starting with scalar that wasn't caught above?\n        // The implementation above handles scalar first element as length 1 vector loop.\n        // If we reached here, first is weird.\n        return { result: 0 };\n      }\n    }\n  });\n\n  registerNode({\n    version: \"1.0.0\",\n    ...def,\n    displayName,\n    extendedInputs: {\n      values: {\n        type: { kind: 'array', element: numberType, size: 'dynamic' },\n        description: 'Values to process.',\n        suppressInputEditor: true,\n        suppressLabel: true,\n        allowMultiConnection: true\n      }\n    },\n    extendedOutputs: {\n      result: { type: numberType, description: 'Result' }\n    }\n  });\n\n  return def;\n};\n\nexport const primitive_all_add = defineAllNode('math.all.add', 'Sum All', (a, b) => a + b);\n\nexport const primitive_all_subtract = defineAllNode('math.all.subtract', 'Subtract All', (a, b) => a - b);\n\nexport const primitive_all_multiply = defineAllNode('math.all.multiply', 'Multiply All', (a, b) => a * b);\n\nexport const primitive_all_divide = defineAllNode('math.all.divide', 'Divide All', (a, b) => a / b);\n\nexport const primitive_all_pow = defineAllNode('math.all.pow', 'Power All', (a, b) => Math.pow(a, b));\n\nexport const primitive_all_min = defineAllNode('math.all.min', 'Min All', (a, b) => Math.min(a, b));\n\nexport const primitive_all_max = defineAllNode('math.all.max', 'Max All', (a, b) => Math.max(a, b));\n\nexport const primitive_all_and = defineAllNode('logic.all.and', 'AND All', (a, b) => (a && b ? 1 : 0), NodeCategory.Logic);\n\nexport const primitive_all_or = defineAllNode('logic.all.or', 'OR All', (a, b) => (a || b ? 1 : 0), NodeCategory.Logic);\n\nexport const primitive_all_xor = defineAllNode('logic.all.xor', 'XOR All', (a, b) => ((!!a !== !!b) ? 1 : 0), NodeCategory.Logic);\n\nexport const primitive_all_equals = defineAllNode('logic.all.equals', 'Equals All', (a, b) => (a === b ? 1 : 0), NodeCategory.Logic);\n\nexport const primitive_all_greater_than = defineAllNode('logic.all.greater_than', 'Greater Than All', (a, b) => (a > b ? 1 : 0), NodeCategory.Logic);\n\nexport const primitive_all_less_than = defineAllNode('logic.all.less_than', 'Less Than All', (a, b) => (a < b ? 1 : 0), NodeCategory.Logic);\n","import { registerNode } from '../node-helpers';\nimport { definePrimitiveNode } from '../type-helpers';\nimport { NodeCategory } from '../structor';\nimport { numberType } from '../std-types';\n\nexport const primitive_pi = definePrimitiveNode({\n  id: 'math.pi',\n  metadata: { category: NodeCategory.Math, keywords: ['pi', 'constant'], description: 'Returns the value of Pi.' },\n  inputs: {},\n  outputs: { result: numberType },\n  execute: () => ({ result: Math.PI })\n});\nregisterNode({ version: \"1.0.0\",\n  ...primitive_pi,\n  displayName: 'Pi',\n  extendedOutputs: { result: { type: numberType, description: 'Pi' } }\n});\n\nexport const primitive_e = definePrimitiveNode({\n  id: 'math.e',\n  metadata: { category: NodeCategory.Math, keywords: ['e', 'euler', 'constant'], description: 'Returns the value of Euler\\'s number.' },\n  inputs: {},\n  outputs: { result: numberType },\n  execute: () => ({ result: Math.E })\n});\nregisterNode({ version: \"1.0.0\",\n  ...primitive_e,\n  displayName: 'E',\n  extendedOutputs: { result: { type: numberType, description: 'Euler\\'s Number' } }\n});\n","import { registerNode } from '../node-helpers';\nimport { definePrimitiveNode } from '../type-helpers';\nimport { NodeCategory } from '../structor';\nimport { numberType } from '../std-types';\n\nexport const primitive_clamp = definePrimitiveNode({\n  id: 'math.clamp',\n  metadata: {\n    category: NodeCategory.Math,\n    keywords: ['limit', 'range'],\n    description: 'Clamps a value between a minimum and maximum.'\n  },\n  inputs: { value: numberType, min: { ...numberType, defaultValue: 0 }, max: { ...numberType, defaultValue: 1 } },\n  outputs: { result: numberType },\n  autoBroadcast: {\n    value: { combine: 'collect' },\n    min: { combine: 'collect' },\n    max: { combine: 'collect' }\n  },\n  reshape: 'vector',\n  execute: (inputs) => {\n    const { value, min, max } = inputs as { value: number, min: number, max: number };\n    return { result: Math.max(min, Math.min(value, max)) };\n  }\n});\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_clamp,\n  displayName: 'Clamp',\n  extendedInputs: {\n    value: { type: numberType, description: 'Value to clamp.' },\n    min: { type: numberType, description: 'Minimum value.', defaultValue: 0, range: [0, 1] },\n    max: { type: numberType, description: 'Maximum value.', defaultValue: 1, range: [0, 1] }\n  },\n  extendedOutputs: {\n    value: { type: numberType, description: 'The clamped value.' } // Wait, repository output name is 'value'. Definition is 'result'. I must match Definition or update everything.\n    // primitive_clamp definition uses 'result'.\n    // Repository loop used 'value'. This implies a mismatch was present or repository overrides name?\n    // If repository says 'value', then `outputs: [{name: 'value'}]`.\n    // BUT executed returns `{ result: ... }`.\n    // If output port is named 'value', it expects `result.value`.\n    // So the previous code was buggy OR I misread `primitive_clamp`.\n    // Let's check `primitive_clamp` in `primitives.ts`. Line 57: `return { result: ... }`.\n    // Line 48: `outputs: { result: numberType }`.\n    // Repository Line 358: `outputs: [{ name: 'value', ... }]`.\n    // If repository says 'value', it binds to 'value'. The result has 'result'.\n    // This looks like a mismatch.\n    // However, I should stick to `result` to match execution.\n    // Or maybe `definePrimitiveNode` maps keys? No.\n    // I will stick to `result` as per definition, but use description from repository.\n  }\n});\n\n// Checking clamp output name again.\n// Primitives.ts: outputs: { result: numberType }\n// Repository.ts: outputs: [{ name: 'value', ... }]\n// If I register with `extendedOutputs: { value: ... }` then the node will have output 'value'.\n// But `execute` returns `{ result: ... }`.\n// Unlike `defineMathNode` where `displayName` is separate, here `outputs` dictates the ports.\n// If I change output name to 'value', I must change `execute` to return `value`.\n// If I keep 'result', I should change `extendedOutputs` to `result`.\n// I will keep `result` and assume repository was slightly off or I misread.\n// Actually, `math.add` returns `result`. Repository says `result`.\n// `clamp` repository says `value`.\n// If I use `result`, it is safe.\n\nexport const primitive_lerp = definePrimitiveNode({\n  id: 'math.lerp',\n  metadata: { category: NodeCategory.Math, keywords: ['lerp', 'mix', 'interpolate'], description: 'Linear interpolation between a and b.' },\n  inputs: {\n    a: numberType,\n    b: numberType,\n    t: numberType\n  },\n  config: {\n    clamp: { kind: 'atomic', type: 'boolean', optional: true }\n  },\n  outputs: { result: numberType },\n  autoBroadcast: true,\n  execute: (inputs, config) => {\n    // console.log('Lerp execute:', inputs, config);\n    const { a, b, t } = inputs as { a: number, b: number, t: number };\n    const doClamp = config.clamp !== false; // if undefined, it's true. if true, it's true. if false, it's false.\n\n    const val = a + (b - a) * t;\n\n    const result = doClamp\n      ? Math.max(Math.min(val, Math.max(a, b)), Math.min(a, b))\n      : val;\n\n    return { result };\n  }\n});\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_lerp,\n  displayName: 'Lerp',\n  extendedInputs: {\n    a: { type: numberType, description: 'Start Value' },\n    b: { type: numberType, description: 'End Value' },\n    t: { type: numberType, description: 'Interpolant (0-1)' }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Interpolated Value' }\n  },\n  compileConfig: (uiConfig) => ({ fields: { clamp: uiConfig.clamp ?? true }, untagged: [] })\n});\n\nexport const primitive_map = definePrimitiveNode({\n  id: 'math.map',\n  metadata: { category: NodeCategory.Math, keywords: ['map', 'remap', 'range'], description: 'Maps a value from one range to another.' },\n  inputs: {\n    value: numberType,\n    inMin: numberType,\n    inMax: numberType,\n    outMin: numberType,\n    outMax: numberType\n  },\n  outputs: { result: numberType },\n  autoBroadcast: true,\n  execute: (inputs) => {\n    const { value, inMin, inMax, outMin, outMax } = inputs as { value: number, inMin: number, inMax: number, outMin: number, outMax: number };\n    return { result: outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin) };\n  }\n});\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_map,\n  displayName: 'Map',\n  extendedInputs: {\n    value: { type: numberType, description: 'Input Value' },\n    inMin: { type: numberType, description: 'Input Min', defaultValue: 0 },\n    inMax: { type: numberType, description: 'Input Max', defaultValue: 1 },\n    outMin: { type: numberType, description: 'Output Min', defaultValue: 0 },\n    outMax: { type: numberType, description: 'Output Max', defaultValue: 1 }\n  },\n  extendedOutputs: {\n    result: { type: numberType, description: 'Mapped Value' }\n  }\n});\n","import { registerNode } from '../node-helpers';\nimport { definePrimitiveNode, toStructor, fromStructor } from '../type-helpers';\nimport { NodeCategory, StructorType, StructorRecord, Structor, ExecutionContext, PrimitiveNodeDefinition } from '../structor';\nimport { anyType } from '../std-types';\n\n// Helper to infer type from io.input config\nfunction inferTypeFromConfig(config: any): StructorType | undefined {\n  if (!config) return undefined;\n  const typeStr = config.type as string;\n  if (!typeStr || typeStr === 'any') return undefined;\n\n  if (typeStr === 'float') return { kind: 'atomic', type: 'number' };\n  if (typeStr === 'string') return { kind: 'atomic', type: 'string' };\n  if (typeStr.startsWith('float')) {\n    const size = parseInt(typeStr.slice(5));\n    if (!isNaN(size)) {\n      return { kind: 'array', size, element: { kind: 'atomic', type: 'number' } };\n    }\n  }\n  return undefined;\n}\n\nconst inputConfigType = {\n  kind: 'record',\n  fields: {\n    name: { kind: 'atomic', type: 'string' },\n    type: anyType\n  }\n} as const; // Cast as const or ensure type compatibility if needed, but simple object is fine for now if structure matches RecordType\n\nexport const primitive_input: PrimitiveNodeDefinition = {\n  id: 'io.input',\n\n  kind: 'primitive',\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['source', 'in'],\n    description: 'Graph input node.'\n  },\n  configType: inputConfigType as any,\n  ui: {\n    inspector: {\n      fields: [\n        {\n          type: 'structor-type',\n          label: 'Type',\n          path: 'type',\n          default: 'float'\n        },\n        { type: 'string', label: 'Name', path: 'name' }\n      ]\n    }\n  },\n  computeForwardPorts: (inputType, config, context) => {\n    // Identity: Output type is same as input type of 'value' (connected) or inferred from 'type' config\n    let valType = inputType.fields['value'];\n    if (!valType) {\n      const inferred = inferTypeFromConfig(config);\n      if (inferred) {\n        valType = inferred;\n      }\n    }\n\n    if (!valType) valType = { kind: 'atomic', type: 'number' };\n    return {\n      inputs: { kind: 'record', fields: { value: { kind: 'atomic', type: 'number' } } },\n      outputs: { kind: 'record', fields: { 'value': valType } }\n    };\n  },\n  execute: (input: StructorRecord, config: Structor, context: ExecutionContext) => {\n    // We assume config is always Structural (compiled or normalized by Executor)\n    // because compileConfig and configType are defined and registered.\n    const fields = (config as StructorRecord)?.fields;\n    const portName = (fields?.name as string) ?? 'value';\n    // if (portName !== 'value' && !input.fields[portName]) {\n    //   console.log(`DEBUG: io.input MISSING port '${portName}'. Has:`, Object.keys(input.fields));\n    // }\n\n    // Fallback? If fields is undefined, it means config was raw and uncompiled/unnormalized.\n    // This shouldn't happen in standard flow. If it does, we default to 'value'.\n\n    const val = input.fields[portName] !== undefined ? input.fields[portName] : input.fields['value'];\n    return { fields: { 'value': val } };\n  }\n};\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_input,\n  displayName: 'Input',\n  aliases: ['in', 'source'],\n  extendedOutputs: {\n    value: { type: anyType, description: 'The input value.', suppressInputEditor: true, suppressLabel: true }\n  },\n  compileConfig: (config) => {\n    const structor = toStructor(config, inputConfigType as any);\n    // Preserve virtual inputs which are not part of the strict schema but used by executor\n    if ((config as any).values) {\n      (structor as any).values = (config as any).values;\n    }\n    return structor;\n  }\n});\n","import { registerNode } from '../node-helpers';\nimport { definePrimitiveNode } from '../type-helpers';\nimport { NodeCategory, StructorRecord, Structor, ExecutionContext, PrimitiveNodeDefinition } from '../structor';\nimport { anyType } from '../std-types';\n\nexport const primitive_output: PrimitiveNodeDefinition = {\n  id: 'io.output',\n  kind: 'primitive',\n  metadata: {\n    category: NodeCategory.IO,\n    keywords: ['sink', 'out'],\n    description: 'Graph output node.'\n  },\n  computeForwardPorts: (inputType, config, context) => {\n    // Identity: Output type is same as input type of 'val'\n    const valType = inputType.fields['value'] || { kind: 'atomic', type: 'any' };\n    return {\n      inputs: { kind: 'record', fields: { value: valType } },\n      outputs: { kind: 'record', fields: { 'value': valType } }\n    };\n  },\n  execute: (input: StructorRecord, config: Structor, context: ExecutionContext) => {\n    // Identity: Output value is input 'val'\n    const val = input.fields['value'];\n    return { fields: { 'value': val } };\n  }\n};\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_output,\n  displayName: 'Output',\n  aliases: ['out', 'sink'],\n  extendedInputs: {\n    value: { type: anyType, description: 'The output value.', suppressInputEditor: true, suppressLabel: true }\n  },\n  extendedOutputs: {\n    value: { type: anyType, description: 'The graph output value.', suppressInputEditor: true, suppressLabel: true }\n  }\n});\n","import { registerNode } from '../node-helpers';\nimport { definePrimitiveNode } from '../type-helpers';\nimport { NodeCategory, StructorType, AnalysisContext, ExecutionContext } from '../structor';\nimport { GraphState } from '../../builder/state';\n\ninterface SubgraphConfig {\n  subgraphId: string;\n}\n\ninterface SubgraphAnalysisContext extends AnalysisContext {\n  loadedSubgraphs?: Map<string, GraphState>;\n}\n\n// Helper to infer type from io.input config (duplicated from io_input.ts for now to avoid circular deps if shared in primitives)\n// Ideally this moves to a shared helper file.\nfunction inferTypeFromConfig(config: any): StructorType | undefined {\n  if (!config) return undefined;\n  const typeStr = config.type as string;\n  if (!typeStr || typeStr === 'any') return undefined;\n\n  if (typeStr === 'float') return { kind: 'atomic', type: 'number' };\n  if (typeStr === 'string') return { kind: 'atomic', type: 'string' };\n  if (typeStr.startsWith('float')) {\n    const size = parseInt(typeStr.slice(5));\n    if (!isNaN(size)) {\n      return { kind: 'array', size, element: { kind: 'atomic', type: 'number' } };\n    }\n  }\n  return undefined;\n}\n\n// Helper for dynamic port naming (replacing #)\nexport function resolvePortName(name: string, index: number, total: number, kind: 'input' | 'output'): string {\n  if (!name || !name.includes('#')) return name;\n\n  let replacement = '';\n  if (total === 1) {\n    replacement = kind === 'input' ? 'in' : 'out';\n  } else if (total <= 4) {\n    replacement = ['x', 'y', 'z', 'w'][index];\n  } else {\n    replacement = index.toString();\n  }\n\n  return name.replace(/#/g, replacement);\n}\n\nexport const computeSubgraphPorts = (inputType: any, config: any, context: any) => {\n  // Access loadedSubgraphs from context (injected by compiler)\n  const ctx = context as SubgraphAnalysisContext;\n  const loadedSubgraphs = ctx.loadedSubgraphs;\n\n  if (!loadedSubgraphs) {\n    return { inputs: { kind: 'record', fields: {} }, outputs: { kind: 'record', fields: {} } };\n  }\n\n  // FIXME: There's a widespread problem where configs are typed as Structors, but they aren't actually.\n  const subgraphId = (config as any as SubgraphConfig).subgraphId;\n  const subgraph = loadedSubgraphs.get(subgraphId);\n\n  if (subgraph) {\n    const subgraphNodes = Object.values(subgraph.inner.nodes);\n\n    // Compute Inputs from Subgraph Inputs\n    const inputFields: Record<string, StructorType> = {};\n    const inputNodes = subgraphNodes\n      .filter(n => n.config.typeId === 'io.input' || n.config.typeId === 'input')\n      .sort((a, b) => a.y - b.y);\n\n    inputNodes.forEach((n, i) => {\n      let name = (n.config as any).name || 'value';\n      name = resolvePortName(name, i, inputNodes.length, 'input');\n      const inferred = inferTypeFromConfig(n.config);\n      inputFields[name] = inferred || { kind: 'atomic', type: 'any' };\n    });\n\n    // Compute Outputs from Subgraph Outputs\n    const outputFields: Record<string, StructorType> = {};\n    const outputNodes = subgraphNodes\n      .filter(n => n.config.typeId === 'io.output' || n.config.typeId === 'output')\n      .sort((a, b) => a.y - b.y);\n\n    outputNodes.forEach((n, i) => {\n      let name = (n.config as any).name || 'value';\n      name = resolvePortName(name, i, outputNodes.length, 'output');\n      outputFields[name] = { kind: 'atomic', type: 'any' };\n    });\n\n    return {\n      inputs: { kind: 'record', fields: inputFields },\n      outputs: { kind: 'record', fields: outputFields }\n    };\n  }\n\n  return { inputs: { kind: 'record', fields: {} }, outputs: { kind: 'record', fields: {} } };\n};\n\nexport const primitive_subgraph = definePrimitiveNode({\n  id: 'core.subgraph',\n  subgraphExpansionTag: 'inline',\n  metadata: {\n    category: NodeCategory.Core,\n    keywords: ['nested', 'graph'],\n    description: 'Executes a nested subgraph.'\n  },\n  config: { subgraphId: { kind: 'atomic', type: 'string' } },\n  inputs: {},\n  outputs: {},\n  ui: {\n    inspector: {\n      fields: [\n        {\n          type: 'string',\n          label: 'Subgraph ID',\n          path: 'subgraphId'\n        }\n      ]\n    }\n  },\n  getDisplayLabel: (config: SubgraphConfig) => {\n    if (config.subgraphId) {\n      const parts = config.subgraphId.split('.');\n      return parts[parts.length - 1];\n    }\n    return undefined;\n  },\n  computeForwardPorts: computeSubgraphPorts as any,\n  execute: (input: any, config: any, context: ExecutionContext) => {\n    // Subgraph execution logic would go here.\n    return { fields: {} };\n  }\n});\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_subgraph,\n  displayName: 'Subgraph',\n  // getDisplayLabel is already in primitive_subgraph but safe to pass again (it comes via spread)\n});\n","import { registerNode } from '../node-helpers';\nimport { definePrimitiveNode } from '../type-helpers';\nimport { NodeCategory, ExecutionContext } from '../structor';\nimport { midiStreamType } from '../std-types';\nimport { computeSubgraphPorts, resolvePortName } from './core_subgraph';\n\n// core.thensubgraph\n// Executes the subgraph when a MIDI Note On event is received.\n// Tag: 'onTrigger'\n\nexport const primitive_thensubgraph = definePrimitiveNode({\n  id: 'core.thensubgraph',\n  subgraphExpansionTag: 'onTrigger',\n  metadata: {\n    category: NodeCategory.Core,\n    keywords: ['nested', 'graph', 'conditional', 'midi', 'trigger'],\n    description: 'Executes a nested subgraph when a MIDI Note On event is received.'\n  },\n  config: { subgraphId: { kind: 'atomic', type: 'string' } },\n  // Inputs: MIDI Stream + Subgraph Inputs\n  inputs: {\n    midi_in: midiStreamType\n  },\n  outputs: {}, // Subgraph Outputs\n  ui: {\n    inspector: {\n      fields: [\n        { type: 'string', label: 'Subgraph ID', path: 'subgraphId' }\n      ]\n    }\n  },\n  getDisplayLabel: (config: any) => {\n    if (config.subgraphId) {\n      const parts = config.subgraphId.split('.');\n      return `OnNote: ${parts[parts.length - 1]}`;\n    }\n    return 'OnNote';\n  },\n  computeForwardPorts: ((inputType: any, config: any, context: any) => {\n    // Get base subgraph ports\n    const basePorts = computeSubgraphPorts(inputType, config, context);\n\n    // Merge midi_in input\n    const inputs = {\n      ...basePorts.inputs.fields,\n      midi_in: midiStreamType\n    };\n\n    return {\n      inputs: { kind: 'record', fields: inputs },\n      outputs: basePorts.outputs\n    };\n  }) as any,\n  execute: (input: any, config: any, context: ExecutionContext) => {\n    const stream = input.midi_in || [];\n    const events = Array.isArray(stream) ? stream : [];\n\n    // Check for Note On\n    let shouldTrigger = false;\n    for (const event of events) {\n      if (event.type === 'note_on' && (event.velocity ?? 0) > 0) {\n        shouldTrigger = true;\n        break;\n      }\n    }\n\n    if (shouldTrigger && context.executeSubgraph) {\n      context.executeSubgraph('onTrigger');\n    }\n\n    // Return empty fields?\n    // The subgraph execution might update outputs, but those are distinct nodes?\n    // Wait. If the subgraph nodes output data... where does it go?\n    // In `core.subgraph` (inline), inputs/outputs are wired.\n    // In `core.thensubgraph`, inputs/outputs are wired similarly.\n    // BUT the execution order is deferred.\n    // If we execute it NOW (during this node's execute), the output nodes inside the subgraph\n    // will update their state `output`.\n    // And since this node proxies those outputs...\n    // Wait, the \"Outputs\" of the parent node are usually wired to the inner nodes' outputs via `Output Remappings`.\n    // `compiler.ts` handles output remappings.\n    /*\n      outputRemappings[nodeId][outputName] = innerOutputNodeId;\n    */\n    // The Executor, when `getGraphOutput` or `connection` reading happens, resolves remappings using keys?\n    // Actually, strictly speaking, `GraphExecutor` relies on connections.\n    // If `core.thensubgraph` has an output port \"X\", causing a connection from `core.thensubgraph:X`.\n    // The `core.thensubgraph` execution ITSELF returns a value for `X` in `execute` result?\n    // Or does `MidiManager`/Executor handle it?\n\n    // In `core_subgraph.ts`, `execute` returns `{ fields: {} }`.\n    // Yet subgraphs work. Why?\n    // Because the `core.subgraph` node is just a \"wrapper\". The connections go *through* it?\n    // No. Visualizer shows connections to the wrapper.\n    // The *Compiler* generates direct connections from Inner Node Output to Outer Node Output logic?\n    // Let's check `compiler.ts` output logic. (Line 99 in `processGraph` implies filtering).\n\n    // If I check `executor.ts`, `getNodeOutput` doesn't do remapping.\n    // The `compileGraph` returns `inferredTypes` and `virtualInputMappings`, `outputRemappings`.\n    // Does the `Executor` or `Compiler` use `outputRemappings` to rewire connections?\n    // Ah, `compiler.ts` seems to flatten nodes and connections.\n    // But connections to the *Parent Node* need to be redirected to the *Inner Output Node*.\n    // If I did NOT implement that redirection in `compiler.ts` yet, then `core.subgraph` probably doesn't work as expected for Outputs?\n    // Or `core.subgraph` is expected to return the values?\n    // But `execute` returns empty.\n\n    // Re-reading `compiler.ts` snippet I viewed earlier...\n    // I didn't see explicit rewiring logic there. I saw recursive processing.\n    // Wait. If `core.subgraph` is in the graph, and I connect `Sub:Out -> Other:In`.\n    // The `executionOrder` runs `Sub`. `Sub` returns empty. `Other` reads empty.\n    // This implies existing subgraph outputs might NOT work?\n    // OR `compiler.ts` adds connections from Inner Output to Outer's consumers?\n    // I need to verify `compiler.ts` logic for connections involving subgraph boundaries.\n\n    return { fields: {} };\n  }\n});\n\nregisterNode(primitive_thensubgraph as any);\n","import { registerNode } from '../node-helpers';\nimport { definePrimitiveNode } from '../type-helpers';\nimport { NodeCategory } from '../structor';\nimport { anyType, numberType } from '../std-types';\n\nexport const primitive_pack = definePrimitiveNode({\n  id: 'core.pack',\n  metadata: { category: NodeCategory.Core, keywords: ['pack', 'record', 'struct', 'vector'], description: 'Packs inputs into a record or vector.' },\n  config: {\n    targetType: { kind: 'atomic', type: 'string', defaultValue: 'infer' }\n  },\n  inputs: {}, // Dynamic\n  outputs: { result: anyType }, // Dynamic\n\n  // UI Configuration (manually attached for now to avoid circular deps)\n  // @ts-ignore\n  ui: {\n    inspector: {\n      fields: [\n        {\n          type: 'tab-bar',\n          label: 'Target Type',\n          path: 'targetType',\n          options: [\n            { label: 'Infer', value: 'infer' },\n            { label: 'float2', value: 'float2' },\n            { label: 'float3', value: 'float3' },\n            { label: 'float4', value: 'float4' }\n          ]\n        }\n      ]\n    }\n  },\n\n  computeBackwardPorts: (outputReqs, config, context) => {\n    const targetType = (config as any)?.targetType || 'infer';\n    let inferredType: 'float2' | 'float3' | 'float4' | null = null;\n\n    if (targetType === 'infer') {\n      // Look at output requirements on 'result' port\n      const resultReq = outputReqs.fields['result'];\n\n      if (resultReq && resultReq.kind === 'record') {\n        if (resultReq.fields['x'] && resultReq.fields['y'] && resultReq.fields['z'] && resultReq.fields['w']) {\n          inferredType = 'float4';\n        } else if (resultReq.fields['x'] && resultReq.fields['y'] && resultReq.fields['z']) {\n          inferredType = 'float3';\n        } else if (resultReq.fields['x'] && resultReq.fields['y']) {\n          inferredType = 'float2';\n        }\n      }\n    } else {\n      inferredType = targetType as any;\n    }\n\n    const inputReqs: any = { kind: 'record', fields: {} };\n    if (inferredType === 'float4') {\n      inputReqs.fields = { x: numberType, y: numberType, z: numberType, w: numberType };\n    } else if (inferredType === 'float3') {\n      inputReqs.fields = { x: numberType, y: numberType, z: numberType };\n    } else if (inferredType === 'float2') {\n      inputReqs.fields = { x: numberType, y: numberType };\n    }\n\n    return {\n      inputRequirements: inputReqs,\n      backwardMetadata: { inferredType }\n    };\n  },\n\n  computeForwardPorts: (inputs, config, context, meta) => {\n\n    // Defensive read: check both root and fields\n    const rawConfig = config as any;\n    const targetType = rawConfig?.targetType || rawConfig?.fields?.targetType || 'infer';\n\n    // If explicit config is set, usage that. Otherwise use inferred.\n    let type = targetType !== 'infer' ? targetType : (meta?.inferredType || 'float2');\n\n    // Finalize inputs based on type\n    const inputFields: any = {};\n    const outputFields: any = {};\n\n    // If type is not one of the vectors (e.g. unknown inference), fallback to float2?\n    // Or if we have inputs connected?\n    // Let's default to float2 if nothing known.\n    if (!['float2', 'float3', 'float4'].includes(type)) type = 'float2';\n\n\n\n    if (type === 'float4') {\n      inputFields.x = numberType;\n      inputFields.y = numberType;\n      inputFields.z = numberType;\n      inputFields.w = numberType;\n      outputFields.result = {\n        kind: 'array',\n        size: 4,\n        element: numberType,\n        hint: 'float4'\n      };\n    } else if (type === 'float3') {\n      inputFields.x = numberType;\n      inputFields.y = numberType;\n      inputFields.z = numberType;\n      outputFields.result = {\n        kind: 'array',\n        size: 3,\n        element: numberType,\n        hint: 'float3'\n      };\n    } else { // float2\n      inputFields.x = numberType;\n      inputFields.y = numberType;\n      outputFields.result = {\n        kind: 'array',\n        size: 2,\n        element: numberType,\n        hint: 'float2'\n      };\n    }\n\n    return {\n      inputs: { kind: 'record', fields: inputFields },\n      outputs: { kind: 'record', fields: outputFields }\n    };\n  },\n\n  shouldRecompileOnConfigChange: (newConfig, oldConfig) => {\n    return newConfig?.targetType !== oldConfig?.targetType;\n  },\n\n  execute: (inputs, config) => {\n    // pack receives raw inputs because it has dynamic ports and no autoBroadcast\n    // inputs is { fields: { x: val, y: val ... } }\n    const fields = (inputs as any)?.fields || {};\n    let type = (config?.targetType) || 'infer';\n\n    if (type === 'infer') {\n      if (fields.w !== undefined) type = 'float4';\n      else if (fields.z !== undefined) type = 'float3';\n      else if (fields.y !== undefined && fields.x !== undefined) type = 'float2';\n      else type = 'record';\n    }\n\n    if (type === 'float4') {\n      return { result: [fields.x ?? 0, fields.y ?? 0, fields.z ?? 0, fields.w ?? 0] };\n    } else if (type === 'float3') {\n      return { result: [fields.x ?? 0, fields.y ?? 0, fields.z ?? 0] };\n    } else if (type === 'float2') {\n      return { result: [fields.x ?? 0, fields.y ?? 0] };\n    } else {\n      // Generic Record Packing\n      // Must return a StructorRecord structure (without kind, per test expectation)\n      return { result: { fields: fields } };\n    }\n  }\n});\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_pack,\n  displayName: 'Pack',\n  extendedOutputs: {\n    result: { type: anyType, description: 'Record' }\n  }\n});\n","import { registerNode } from '../node-helpers';\nimport { definePrimitiveNode } from '../type-helpers';\nimport { NodeCategory, StructorType, StructorRecord } from '../structor';\nimport { anyType } from '../std-types';\n\nexport const primitive_unpack = definePrimitiveNode({\n  id: 'core.unpack',\n  metadata: { category: NodeCategory.Core, keywords: ['unpack', 'destructure', 'split'], description: 'Unpacks a record or fixed-length vector into outputs.' },\n  config: {},\n  inputs: { record: anyType },\n  // Outputs: Dynamic based on input record type\n  computeForwardPorts: (inputType, config, context) => {\n    // console.log('UNPACK computeForwardPorts (350):', JSON.stringify(inputType, null, 2));\n    const input = inputType.fields['record'];\n\n    // Default outputs empty\n    let outputFields: Record<string, StructorType> = {};\n\n    if (input) {\n      if (input.kind === 'record') {\n        outputFields = input.fields;\n      } else if (input.kind === 'array' && typeof input.size === 'number' && input.size <= 16) {\n        const size = input.size;\n\n        if (size === 2) {\n          outputFields['x'] = input.element;\n          outputFields['y'] = input.element;\n        } else if (size === 3) {\n          outputFields['x'] = input.element;\n          outputFields['y'] = input.element;\n          outputFields['z'] = input.element;\n        } else if (size === 4) {\n          outputFields['x'] = input.element;\n          outputFields['y'] = input.element;\n          outputFields['z'] = input.element;\n          outputFields['w'] = input.element;\n        } else {\n          for (let i = 0; i < size; i++) {\n            outputFields[i.toString()] = input.element;\n          }\n        }\n      }\n    }\n\n    return {\n      inputs: { kind: 'record', fields: { record: input || anyType } },\n      outputs: { kind: 'record', fields: outputFields }\n    };\n  },\n  outputs: {}, // Dynamic outputs\n  dynamicOutputType: anyType,\n  execute: (input) => {\n    // Unwrapped input (from definePrimitiveNode wrapper) has keys matching inputs definition\n    let record = input.record;\n    if (!record) return {};\n\n    // Standardize Input:\n    // GraphExecutor (or any type inputs) might wrap single objects in an array.\n    // If it's a single-element array containing a Record/Object, unwrap it first.\n    if (Array.isArray(record) && record.length === 1 && typeof record[0] === 'object' && record[0] !== null) {\n      const item = record[0];\n      // Check if it's a candidate for unpacking (has keys)\n      if ('x' in item || 'fields' in item || Object.keys(item).length > 0) {\n        record = item;\n      }\n    }\n\n    // PATH 1: Array (Vector [x, y, z...])\n    if (Array.isArray(record)) {\n      const size = record.length;\n      const fields: Record<string, any> = {};\n\n      if (size === 2) {\n        fields['x'] = record[0];\n        fields['y'] = record[1];\n      } else if (size === 3) {\n        fields['x'] = record[0];\n        fields['y'] = record[1];\n        fields['z'] = record[2];\n      } else if (size === 4) {\n        fields['x'] = record[0];\n        fields['y'] = record[1];\n        fields['z'] = record[2];\n        fields['w'] = record[3];\n      } else {\n        for (let i = 0; i < size; i++) {\n          if (i < 16) fields[i.toString()] = record[i];\n        }\n      }\n      return fields;\n    }\n\n    // PATH 2: Record (Structor Record or Plain Object)\n    if (typeof record === 'object' && record !== null) {\n      if ('fields' in record) {\n        // Return fields map directly for wrapping\n        return record.fields;\n      }\n      // Plain object -> return as is for wrapping\n      return record;\n    }\n\n    return {};\n  }\n});\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_unpack,\n  displayName: 'Unpack',\n  extendedInputs: {\n    record: { type: anyType, description: 'Record to unpack' }\n  }\n});\n","import { StructorType } from './structor';\n\nexport type TriggerMode = 'midi' | 'primitive';\n\nexport function detectTriggerMode(inputType: StructorType | undefined): TriggerMode {\n  if (!inputType) return 'primitive'; // Default to primitive if unknown\n\n  // Check if it looks like a MIDI stream\n  // MIDI Stream = Array of Records\n  // We assume anything else is a primitive signal\n  const isMidi = (inputType.kind === 'array' && (inputType as any).element?.kind === 'record');\n  // Note: type-helpers usually uses 'element' for array element type, but check if it's 'elementType' in some variants?\n  // Looking at core_ifthen.ts, it accessed (inputType as any).elementType?\n  // Let's verify standard types. 'ArrayType' interface usually has 'element'.\n  // core_pack.ts:99 uses 'element'.\n  // logic_select.ts checks 'inputType.fields'.\n\n  if (isMidi) return 'midi';\n\n  return 'primitive';\n}\n\nexport function shouldTrigger(input: any, mode: TriggerMode): boolean {\n  if (mode === 'primitive') {\n    // Primitive Mode: Check for Truthy\n    if (Array.isArray(input)) {\n      // If array (from stream or spread), trigger if ANY is truthy\n      for (const val of input) {\n        if (val) return true;\n      }\n      return false;\n    } else {\n      // Scalar\n      return !!input;\n    }\n  } else {\n    // MIDI Mode (Default)\n    const stream = input || [];\n    if (Array.isArray(stream)) {\n      for (const event of stream) {\n        // Check for Note On with velocity > 0\n        if (event && event.type === 'note_on' && (event.velocity ?? 0) > 0) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n","import { registerNode } from '../node-helpers';\nimport { definePrimitiveNode } from '../type-helpers';\nimport { NodeCategory, ExecutionContext, PrimitiveNodeDefinition, StructorType } from '../structor';\nimport { RegionVisibility } from '../repository';\nimport { midiStreamType } from '../std-types';\nimport { detectTriggerMode, shouldTrigger, TriggerMode } from '../trigger-helpers';\nimport type { GridNode } from '../../builder/state';\n\n// core.ifthen\n// Implicitly groups nodes spatially and executes them conditionally.\n// Tag: 'onTrigger'\n\ninterface IfThenConfig {\n  width: number;\n  height: number;\n  regionX?: number;\n  regionY?: number;\n  visibility?: 'auto' | 'show' | 'hide';\n}\n\nexport const primitive_ifthen = definePrimitiveNode({\n  id: 'core.ifthen',\n  subgraphExpansionTag: 'onTrigger',\n  metadata: {\n    category: NodeCategory.Core,\n    keywords: ['group', 'conditional', 'spatial', 'if', 'then'],\n    description: 'Spatially groups nodes and executes them when a MIDI Note On event is received.'\n  },\n  config: {\n    width: { kind: 'atomic', type: 'number', defaultValue: 3 },\n    height: { kind: 'atomic', type: 'number', defaultValue: 3 },\n    regionX: { kind: 'atomic', type: 'number', defaultValue: 0, optional: true },\n    regionY: { kind: 'atomic', type: 'number', defaultValue: 0, optional: true },\n    visibility: { kind: 'atomic', type: 'string', defaultValue: 'auto', optional: true },\n    mode: { kind: 'atomic', type: 'string', defaultValue: 'midi', optional: true }\n  },\n  // Inputs: MIDI Stream (Trigger)\n  inputs: {\n    midi_in: midiStreamType\n  },\n  outputs: {},\n  ui: {\n    inspector: {\n      fields: [\n        { type: 'number', label: 'Width', path: 'width', min: 1, step: 1 },\n        { type: 'number', label: 'Height', path: 'height', min: 1, step: 1 },\n        { type: 'number', label: 'Region X (Offset)', path: 'regionX', step: 1 },\n        { type: 'number', label: 'Region Y (Offset)', path: 'regionY', step: 1 },\n        {\n          type: 'tab-bar', label: 'Visibility', path: 'visibility', options: [\n            { label: 'Auto', value: 'auto' },\n            { label: 'Show', value: 'show' },\n            { label: 'Hide', value: 'hide' }\n          ], default: 'auto'\n        }\n      ]\n    }\n  },\n  getDisplayLabel: () => 'IfThen',\n\n  getRegion: (config) => ({\n    x: config.regionX ?? 0,\n    y: config.regionY ?? 0,\n    width: config.width ?? 1,\n    height: config.height ?? 1,\n    visibility: (config.visibility as RegionVisibility) || RegionVisibility.Show\n  }),\n\n  getChildren: (node: GridNode, allNodes: Record<string, GridNode>) => {\n    const children: string[] = [];\n    const config = node.config as unknown as IfThenConfig;\n\n    // Use regionX/Y logic\n    const rx = config.regionX ?? 0;\n    const ry = config.regionY ?? 0;\n    const w = config.width ?? 1;\n    const h = config.height ?? 1;\n\n    // Bounding Box (in Grid Coords)\n    const x1 = node.x + rx;\n    const y1 = node.y + ry;\n    const x2 = x1 + w;\n    const y2 = y1 + h;\n\n    for (const other of Object.values(allNodes)) {\n      if (other.id === node.id) continue;\n\n      // Check if (other.x, other.y) is inside.\n      if (other.x >= x1 && other.x < x2 && other.y >= y1 && other.y < y2) {\n        children.push(other.id);\n      }\n    }\n    return children;\n  },\n\n  execute: (inputs, config, context) => {\n    const mode = (config as any).mode || 'midi';\n    const input = inputs.midi_in;\n    const shouldTriggerVal = shouldTrigger(input, mode as TriggerMode);\n\n    if (shouldTriggerVal && context.executeSubgraph) {\n      context.executeSubgraph('onTrigger');\n    }\n\n    return { fields: {} };\n  },\n\n  computeForwardPorts: (inputTypes, config, context) => {\n    const inputType = inputTypes.fields.midi_in;\n\n    let mode = 'midi';\n    let finalInputType: StructorType = midiStreamType;\n\n\n    if (inputType) {\n      mode = detectTriggerMode(inputType);\n      if (mode === 'primitive') {\n        finalInputType = inputType; // Adopt the input type (Dynamic Typing)\n      }\n    }\n\n    return {\n      inputs: { kind: 'record', fields: { midi_in: finalInputType } },\n      outputs: { kind: 'record', fields: {} },\n      forwardMetadata: { mode }\n    };\n  },\n\n  compileConfig: (uiConfig: any, metadata: any) => {\n    return {\n      fields: {\n        ...uiConfig,\n        mode: metadata?.mode || 'midi'\n      }\n    };\n  }\n});\n\nregisterNode(primitive_ifthen);\n","import { registerNode } from '../node-helpers';\nimport { PrimitiveNodeDefinition, NodeCategory, StructorType, StructorRecord, Structor, ExecutionContext } from '../structor';\nimport { anyType, numberType } from '../std-types';\n\n// Helper to infer type from value (simple version)\nfunction inferType(value: any): StructorType {\n  if (typeof value === 'number') return numberType;\n  if (typeof value === 'string') return { kind: 'atomic', type: 'string' };\n  if (typeof value === 'boolean') return { kind: 'atomic', type: 'boolean' };\n  if (Array.isArray(value)) {\n    const elType = value.length > 0 ? inferType(value[0]) : anyType;\n    return { kind: 'array', element: elType, size: value.length };\n  }\n  if (typeof value === 'object' && value !== null) {\n    return anyType;\n  }\n  return anyType;\n}\n\nexport const primitive_literal: PrimitiveNodeDefinition = {\n  id: 'data.literal',\n  kind: 'primitive',\n  metadata: {\n    category: NodeCategory.Data,\n    keywords: ['value', 'constant'],\n    description: 'Outputs a constant value.'\n  },\n  configType: { kind: 'atomic', type: 'any' }, // This literal can hold any type of value\n  computeForwardPorts: (inputType, config, context) => {\n    return {\n      inputs: { kind: 'record', fields: {} },\n      outputs: { kind: 'record', fields: { value: inferType(config) } }\n    };\n  },\n  execute: (input: StructorRecord, config: Structor, context: ExecutionContext) => {\n    // GridNode config is wrapped { typeId, value }. We want the value.\n    // If config is primitive, use it. If object with value, use value.\n    const val = (config && typeof config === 'object' && 'value' in config) ? (config as any).value : config;\n    return { fields: { value: val } };\n  },\n};\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_literal,\n  displayName: 'Literal',\n  extendedOutputs: {\n    value: { type: anyType, description: 'The literal value.' } // Repository uses empty name? lines 611: { name: '', ... }\n    // NOTE: If name is '', then port creation might be weird if definePrimitiveNode uses 'value'.\n    // Step 3042 line 611 says name: ''.\n    // `computeForwardPorts` returns `fields: { value: ... }`.\n    // If I register with extendedOutput name='', it might override.\n    // However, `execute` returns `value`.\n    // If name is empty string, does executor handle it?\n    // I'll stick to 'value' as the key is 'value'. The `name` property in `extendedOutputs` (PortHint) is what's used for ID if not map.\n    // Wait, PortHint `name` IS the ID.\n    // If repository used '', then the logic was likely using index 0?\n    // But `execute` returns key 'value'.\n    // `primitive_literal` in `primitives.ts` has `return { fields: { value: config } }`.\n    // So the port logic expects 'value'.\n    // Repository line 611 `name: ''` might be a UI thing or legacy.\n    // I will use `value` to be safe and consistent with code.\n  },\n  compileConfig: (uiConfig) => uiConfig?.literal?.value ?? 0.0\n});\n","import { registerNode } from '../node-helpers';\nimport { definePrimitiveNode } from '../type-helpers';\nimport { NodeCategory } from '../structor';\nimport { anyType, numberType } from '../std-types';\n\nexport const primitive_hub = definePrimitiveNode({\n  id: 'util.hub',\n  metadata: { category: NodeCategory.Utility, keywords: ['hub', 'reroute'], description: 'Passes input to output.' },\n  inputs: { value: anyType },\n  outputs: { value: anyType },\n  autoBroadcast: true,\n  execute: (inputs) => ({ value: inputs.value })\n});\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_hub,\n  displayName: 'Hub',\n  extendedInputs: {\n    value: { type: anyType, description: 'Input', suppressInputEditor: true, suppressLabel: true }\n  },\n  extendedOutputs: {\n    value: { type: anyType, description: 'Output', suppressLabel: true }\n  }\n});\n\nexport const primitive_float = definePrimitiveNode({\n  id: 'data.float',\n  metadata: { category: NodeCategory.Data, keywords: ['float', 'number', 'slider'], description: 'Float value with slider.' },\n  inputs: { value: numberType },\n  outputs: { value: numberType },\n  autoBroadcast: true,\n  execute: (inputs) => ({ value: inputs.value })\n});\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_float,\n  displayName: 'Float',\n  extendedInputs: {\n    value: { type: numberType, description: 'Value', defaultValue: 0 }\n  },\n  extendedOutputs: {\n    value: { type: numberType, description: 'Value' }\n  },\n  compileConfig: (uiConfig) => ({ values: { value: uiConfig.value ?? 0.0 }, fields: {}, untagged: [] })\n});\n","import { registerNode } from '../node-helpers';\nimport { definePrimitiveNode } from '../type-helpers';\nimport { PrimitiveNodeDefinition, NodeCategory, FunctorType, StructorRecord, Structor, ExecutionContext, Functor } from '../structor';\nimport { anyType } from '../std-types';\n\nexport const primitive_apply: PrimitiveNodeDefinition = {\n  id: 'functional.apply',\n  kind: 'primitive',\n  metadata: {\n    category: NodeCategory.Functional,\n    keywords: ['call', 'invoke'],\n    description: 'Applies a functor to an input value.'\n  },\n  computeForwardPorts: (inputType, config, context) => {\n    const functorType = inputType.fields['functor'] as FunctorType;\n    return {\n      inputs: inputType,\n      outputs: { kind: 'record', fields: { result: functorType ? functorType.output : { kind: 'atomic', type: 'any' } } }\n    };\n  },\n  execute: (input: StructorRecord, config: Structor, context: ExecutionContext) => {\n    const functor = input.fields['functor'] as Functor;\n    const inputValue = input.fields['input'];\n    return { fields: { result: functor(inputValue) } };\n  }\n};\nregisterNode({\n  version: \"1.0.0\",\n  ...primitive_apply,\n  displayName: 'Apply Functor',\n  extendedInputs: {\n    functor: { type: { kind: 'functor', input: anyType, output: anyType }, description: 'The functor to apply.' },\n    value: { type: anyType, description: 'The value to apply the functor to.' }\n  },\n  extendedOutputs: {\n    result: { type: anyType, description: 'The result of the functor application.' }\n  }\n});\n","import { definePrimitiveNode, NumberType, AnyType, typedBroadcast, TypedBroadcastSchema, unifyTypes } from '../type-helpers';\nimport { NodeCategory, StructorType, Structor, StructorRecord } from '../structor';\nimport { numberType } from '../std-types';\nimport { registerNode } from '../node-helpers';\n\n\n\nexport const logic_select = definePrimitiveNode({\n  id: 'logic.select',\n  metadata: {\n    category: NodeCategory.Logic,\n    keywords: ['switch', 'case', 'mux', 'conditional', 'select'],\n    description: 'Selects an output value from multiple inputs based on a control value.'\n  },\n  inputs: {},\n  config: {\n    count: { kind: 'atomic', type: 'number', defaultValue: 2 },\n    mode: { kind: 'atomic', type: 'string', defaultValue: 'value' }, // 'range', 'value', 'zone'\n    base: { kind: 'atomic', type: 'number', defaultValue: 0, optional: true },\n    step: { kind: 'atomic', type: 'number', defaultValue: 1, optional: true },\n    // Thresholds stored in config? Or inputs?\n    // User: \"In zone mode, there will be two additional input ports per switch case. Threshold value...\"\n    // So thresholds are inputs.\n  },\n  outputs: {\n    result: AnyType // Dynamic\n  },\n  // AutoBroadcast is handled manually because inputs are dynamic\n  autoBroadcast: false,\n  // User says: \"The default type for these input ports should be 'float / number'\"\n\n  computeForwardPorts: (inputTypes, config: Structor, context) => {\n    const configObj = (config as StructorRecord).fields;\n    const count = (configObj.count as number) || 2;\n    const mode = (configObj.mode as string) || 'value';\n\n    // Base inputs\n    const inputs: any = {\n      value: numberType\n    };\n\n    const valueTypes: StructorType[] = [];\n\n    for (let i = 0; i < count; i++) {\n      if (mode === 'range') {\n        const portName = `val_${i}`;\n        inputs[portName] = { ...numberType, description: `Case ${i + 1} Value` };\n        if (inputTypes.fields && inputTypes.fields[portName]) valueTypes.push(inputTypes.fields[portName]);\n      } else if (mode === 'value') {\n        inputs[`match_${i}`] = { ...numberType, description: `Case ${i + 1} Match` };\n        inputs[`val_${i}`] = { ...numberType, description: `Case ${i + 1} Value` };\n        if (inputTypes.fields && inputTypes.fields[`val_${i}`]) valueTypes.push(inputTypes.fields[`val_${i}`]);\n      } else if (mode === 'zone') {\n        inputs[`threshold_${i}`] = { ...numberType, description: `Case ${i + 1} Threshold` };\n        inputs[`val_${i}`] = { ...numberType, description: `Case ${i + 1} Value` };\n        if (inputTypes.fields && inputTypes.fields[`val_${i}`]) valueTypes.push(inputTypes.fields[`val_${i}`]);\n      }\n    }\n\n    const outputType = unifyTypes(valueTypes);\n\n    return {\n      inputs: { kind: 'record', fields: inputs },\n      outputs: { kind: 'record', fields: { result: outputType } }\n    };\n  },\n\n  compileConfig: (uiConfig) => {\n    return {\n      fields: {\n        count: uiConfig.count || 2,\n        mode: uiConfig.mode || 'value',\n        base: uiConfig.base || 0,\n        step: uiConfig.step || 1\n      }\n    };\n  },\n\n  shouldRecompileOnConfigChange: (newConfig, oldConfig) => {\n    const n = newConfig as any;\n    const o = oldConfig as any;\n    return n.count !== o?.count || n.mode !== o?.mode;\n  },\n\n  execute: (rawInputs, config, context) => {\n    // Manually reconstruct schema for dynamic inputs\n    // config here is the Unwrapped Structor (InferRecord -> { count: number, ... })\n    const count = config.count ?? 2;\n    const mode = config.mode ?? 'value';\n    const base = config.base ?? 0;\n    const step = config.step ?? 1;\n\n    // Schema for broadcast\n    const schema: TypedBroadcastSchema = {\n      value: { type: numberType }\n    };\n\n    for (let i = 0; i < count; i++) {\n      const valKey = `val_${i}`;\n      schema[valKey] = { type: AnyType }; // Accept any type for values\n\n      if (mode === 'value') {\n        schema[`match_${i}`] = { type: numberType };\n      } else if (mode === 'zone') {\n        schema[`threshold_${i}`] = { type: numberType };\n      }\n    }\n\n    const inputs = typedBroadcast(context, schema, rawInputs as any);\n\n    // Logic implementation\n    const value = inputs.value ?? 0;\n\n    let selectedIndex = -1;\n\n    if (mode === 'range') {\n      // Find closest index\n      // Targets: base, base+step, base+2*step ...\n      // We can solve this analytically: round((value - base) / step)\n      if (step === 0) {\n        selectedIndex = 0;\n      } else {\n        const rawIndex = Math.round((value - base) / step);\n        selectedIndex = Math.max(0, Math.min(count - 1, rawIndex));\n      }\n    } else if (mode === 'value') {\n      const epsilon = 0.0001;\n      for (let i = 0; i < count; i++) {\n        const matchVal = (inputs as any)[`match_${i}`] ?? (i + 1); // Default match?\n        if (Math.abs(value - matchVal) < epsilon) {\n          selectedIndex = i;\n          break;\n        }\n      }\n    } else if (mode === 'zone') {\n      // \"If input value is less than or equal to the first case's threshold\"\n      // Assuming sorted.\n      for (let i = 0; i < count; i++) {\n        const threshold = (inputs as any)[`threshold_${i}`] ?? Infinity;\n        if (value <= threshold) {\n          selectedIndex = i;\n          break;\n        }\n      }\n    }\n\n    let result = 0;\n    if (selectedIndex !== -1) {\n      result = (inputs as any)[`val_${selectedIndex}`] ?? 0;\n    } else {\n      // No match? Fallback? User didn't specify. Last case? 0?\n      // In switch nodes, usually default is needed.\n      // For now, 0 or null? 0 is safer for numbers.\n      result = 0;\n    }\n\n    return { result };\n  }\n});\n\nregisterNode({\n  version: \"1.0.0\",\n  ...logic_select,\n  displayName: 'Select',\n  extendedInputs: {\n    value: { type: numberType, description: 'Control Value' }\n  },\n  extendedOutputs: {\n    result: { type: AnyType, description: 'Selected Value' }\n  },\n  ui: {\n    inspector: {\n      fields: [\n        { type: 'number' as const, label: 'Count', path: 'count', min: 2, max: 32, step: 1, default: 2 },\n        {\n          type: 'tab-bar' as const, label: 'Mode', path: 'mode', default: 'value',\n          options: [\n            { label: 'Value (Match)', value: 'value' },\n            { label: 'Range (Index)', value: 'range' },\n            { label: 'Zone (Threshold)', value: 'zone' }\n          ]\n        },\n        {\n          type: 'number' as const, label: 'Base Index', path: 'base', step: 1, default: 0,\n          visible: (cfg: any) => cfg.mode === 'range'\n        }, // For range mode\n        {\n          type: 'number' as const, label: 'Step Size', path: 'step', step: 1, default: 1,\n          visible: (cfg: any) => cfg.mode === 'range'\n        }   // For range mode\n      ]\n    }\n  }\n});\n","import { definePrimitiveNode, AnyType, unifyTypes } from '../type-helpers';\nimport { NodeCategory, StructorType, Structor, StructorRecord } from '../structor';\nimport { midiStreamType } from '../std-types';\nimport { registerNode } from '../node-helpers';\nimport { detectTriggerMode, shouldTrigger, TriggerMode } from '../trigger-helpers';\n\ninterface LatchState {\n  currentValue: any;\n  initialized: boolean;\n}\n\nexport const logic_latch = definePrimitiveNode({\n  id: 'logic.latch',\n  metadata: {\n    category: NodeCategory.Logic,\n    keywords: ['latch', 'sample', 'hold', 'trigger', 'store'],\n    description: 'Stores and outputs a value when the trigger condition is met.'\n  },\n  config: {\n    initMode: { kind: 'atomic', type: 'string', defaultValue: 'auto' }, // 'auto' | 'manual'\n    mode: { kind: 'atomic', type: 'string', defaultValue: 'midi', optional: true } // trigger mode\n  },\n  inputs: {\n    condition: midiStreamType, // Dynamic\n    value: AnyType,\n    init: AnyType\n  },\n  outputs: {\n    result: AnyType // Dynamic\n  },\n  autoBroadcast: false, // We handle execution logic manually?\n  // Actually, Latch logic is usually valid for scalar/broadcast if condition is also broadcast?\n  // But trigger logic \"shouldTrigger\" is often looking at the stream as a whole.\n  // If we broadcast, we get simple scalar logic.\n  // But detectTriggerMode handles streams.\n  // Let's stick to execute with raw inputs to be safe and consistent with logic.select/core.ifthen.\n\n  createState: () => ({ currentValue: undefined, initialized: false }),\n\n  computeForwardPorts: (inputTypes, config: Structor, context) => {\n    // Lifecycle methods receive the raw stored Structor (Wrapped)\n    const rawConfig = (config as StructorRecord).fields;\n    const initMode = rawConfig.initMode || 'auto';\n\n    // Detect Trigger Mode\n    const conditionType = (inputTypes.fields || inputTypes).condition;\n    const triggerMode = detectTriggerMode(conditionType);\n\n    // Value Type\n    const valueType = (inputTypes.fields || inputTypes).value || AnyType;\n    let initType = (inputTypes.fields || inputTypes).init || AnyType;\n\n    // If auto init, init type is not relevant (hidden), but effectively same as value\n    if (initMode === 'auto') {\n      initType = valueType;\n    }\n\n    const outputType = unifyTypes([valueType, initType]);\n\n    // Construct inputs\n    const inputs: any = {\n      condition: conditionType || midiStreamType,\n      value: valueType\n    };\n\n    if (initMode === 'manual') {\n      inputs.init = initType;\n    }\n\n    return {\n      inputs: { kind: 'record', fields: inputs },\n      outputs: { kind: 'record', fields: { result: outputType } },\n      forwardMetadata: { mode: triggerMode }\n    };\n  },\n\n  compileConfig: (uiConfig: any, metadata: any) => {\n    return {\n      fields: {\n        initMode: uiConfig.initMode || 'auto',\n        mode: metadata?.mode || 'midi'\n      }\n    };\n  },\n\n  shouldRecompileOnConfigChange: (newConfig, oldConfig) => {\n    // Lifecycle methods receive the UI Config (Unwrapped)\n    const n = newConfig as any;\n    const o = oldConfig as any;\n    return n.initMode !== o?.initMode;\n  },\n\n  execute: (inputs: any, config: any, context, state: LatchState) => {\n    // execute receives the Unwrapped/Marshalled config (fromStructor)\n\n    // Inputs: fields.condition, fields.value, fields.init\n    const condition = inputs.condition;\n    const value = inputs.value;\n    const init = inputs.init;\n\n    // Config is already unwrapped\n    const mode = config.mode || 'midi';\n    const initMode = config.initMode || 'auto';\n\n    if (shouldTrigger(condition, mode as TriggerMode)) {\n      state.currentValue = value;\n      state.initialized = true;\n    }\n\n    let result = state.currentValue;\n\n    if (!state.initialized) {\n      if (initMode === 'auto') {\n        result = value; // Pass through if not latched yet?\n        // \"When the node state is new, if the condition is not truthy, then it will store the init value\"\n        // If auto, init value IS value.\n        // But does it store it? \"store the init value\".\n        // Implementation: just output it.\n        // Wait, \"store\" implies it becomes the latched value?\n        // \"It will also take a value input, and an init input... internal value will update whenever condition is truthy... if condition is not truthy, then it will store the init value\"\n        // This phrasing \"if condition is not truthy, it will store init\" implies initialization logic.\n        // Usually Latch initializes to Init input ONCE.\n        // Or does it latch init on first frame?\n        // \"When the node state is new...\" implies initialization step.\n\n        // Logic:\n        // if (!initialized) {\n        //    state.currentValue = initMode === 'auto' ? value : init;\n        //    state.initialized = true;\n        // }\n        // BUT, if shouldTrigger is true, we overwrite it.\n        // Correct order:\n        // 1. If trigger -> update state.\n        // 2. If !initialized -> set state to init (and mark initialized).\n        // Return state.\n\n        // Re-reading: \"When the node state is new, if the condition is not truthy, then it will store the init value\"\n        // Yes.\n      }\n\n      // If not triggered this frame:\n      if (!state.initialized) {\n        state.currentValue = (initMode === 'auto') ? value : init;\n        state.initialized = true;\n        result = state.currentValue;\n      }\n    }\n\n    return { result };\n  }\n});\n\nregisterNode({\n  version: \"1.0.0\",\n  ...logic_latch,\n  inputs: {}, // Override static inputs to ensure RAW execution (like logic.select)\n  displayName: 'Latch',\n  extendedInputs: {\n    condition: { type: midiStreamType, description: 'Trigger' },\n    value: { type: AnyType, description: 'Value to Latch' },\n    init: { type: AnyType, description: 'Initial Value' }\n  },\n  extendedOutputs: {\n    result: { type: AnyType, description: 'Latched Value' }\n  },\n  ui: {\n    inspector: {\n      fields: [\n        {\n          type: 'tab-bar' as const, label: 'Init Mode', path: 'initMode', default: 'auto',\n          options: [\n            { label: 'Auto (Use Value)', value: 'auto' },\n            { label: 'Manual', value: 'manual' }\n          ]\n        }\n      ]\n    }\n  }\n});\n","import { definePrimitiveNode, AnyType, unifyTypes } from '../type-helpers';\nimport { NodeCategory, StructorType, Structor, StructorRecord } from '../structor';\nimport { registerNode } from '../node-helpers';\n\ninterface DelayState {\n  storedValue: any;\n  initialized: boolean;\n}\n\nexport const logic_delay = definePrimitiveNode({\n  id: 'logic.delay',\n  metadata: {\n    category: NodeCategory.Logic, // Or Time? But user called it logic.delay.\n    keywords: ['delay', 'z-1', 'feedback', 'memory', 'prev'],\n    description: 'Outputs the value from the previous frame (z).'\n  },\n  config: {\n    initMode: { kind: 'atomic', type: 'string', defaultValue: 'auto' }, // 'auto' | 'manual'\n  },\n  inputs: {\n    value: AnyType,\n    init: AnyType\n  },\n  outputs: {\n    result: AnyType // Dynamic\n  },\n  autoBroadcast: false, // Manual handling for logic consistency\n  isRealtime: () => true,\n\n  createState: () => ({ storedValue: undefined, initialized: false }),\n\n  computeForwardPorts: (inputTypes, config: Structor, context) => {\n    const rawConfig = (config as StructorRecord).fields;\n\n    const initMode = rawConfig.initMode || 'auto';\n\n    // Value Type\n    const valueType = (inputTypes.fields || inputTypes).value || AnyType;\n    let initType = (inputTypes.fields || inputTypes).init || AnyType;\n\n    // If auto init, init type is not relevant (hidden), but effectively same as value\n    if (initMode === 'auto') {\n      initType = valueType;\n    }\n\n    const outputType = unifyTypes([valueType, initType]);\n\n    // Construct inputs\n    const inputs: any = {\n      value: valueType\n    };\n\n    if (initMode === 'manual') {\n      inputs.init = initType;\n    }\n\n    // Pass through implicit inputs logic for dirty propagation?\n    // No, dirty propagation handles this.\n\n    return {\n      inputs: { kind: 'record', fields: inputs },\n      outputs: { kind: 'record', fields: { result: outputType } }\n    };\n  },\n\n  compileConfig: (uiConfig: any, metadata: any) => {\n    return {\n      fields: {\n        initMode: uiConfig.initMode || 'auto'\n      }\n    };\n  },\n\n  shouldRecompileOnConfigChange: (newConfig, oldConfig) => {\n    const n = newConfig as any;\n    const o = oldConfig as any;\n    return n.initMode !== o?.initMode;\n  },\n\n  cycleBreakingPorts: ['value'],\n\n  execute: (inputs, config, context, state: DelayState) => {\n    // NOTE: In a cycle, 'inputs.value' might be undefined during this phase.\n    const init = inputs.init;\n    const initMode = config.initMode || 'auto';\n\n    let result;\n\n    if (state.initialized) {\n      result = state.storedValue;\n    } else {\n      // First frame\n      // If we are unitialized AND in a cycle, 'value' might be missing.\n      // If auto/value mode, we default to undefined or 0?\n      // Since 'storedValue' is what we output, and it's undefined initially...\n\n      if (initMode === 'auto') {\n        result = inputs.value;\n      } else {\n        result = init;\n      }\n      state.initialized = true;\n    }\n\n    // We do NOT update storedValue here if we are in a cycle break (value is missing).\n    // If we are NOT in a cycle, value is present, so update it logic normal.\n    if (inputs.value !== undefined) {\n      state.storedValue = inputs.value;\n    }\n\n    return { result };\n  },\n\n  consolidate: (inputs, config, context, state: DelayState) => {\n    // This runs if we were part of a broken cycle.\n    // We now have the \"late\" arriving value.\n    if (inputs.value !== undefined) {\n      state.storedValue = inputs.value;\n    }\n    // Also mark initialized\n    state.initialized = true;\n  }\n});\n\nregisterNode({\n  version: \"1.0.0\",\n  ...logic_delay,\n  inputs: {}, // Override static inputs\n  displayName: 'Delay',\n  extendedInputs: {\n    value: { type: AnyType, description: 'Input Value' },\n    init: { type: AnyType, description: 'Initial Value' }\n  },\n  extendedOutputs: {\n    result: { type: AnyType, description: 'Delayed Value' }\n  },\n  ui: {\n    inspector: {\n      fields: [\n        {\n          type: 'tab-bar' as const, label: 'Init Mode', path: 'initMode', default: 'auto',\n          options: [\n            { label: 'Auto (Use Value)', value: 'auto' },\n            { label: 'Manual', value: 'manual' }\n          ]\n        }\n      ]\n    }\n  }\n});\n","import { PrimitiveNodeDefinition } from \"./structor\";\n\n// Import all modules to trigger side-effect registration\nimport * as Binary from './nodes/binary';\nimport * as Unary from './nodes/unary';\nimport * as List from './nodes/list';\nimport * as Constants from './nodes/constants';\nimport * as Utils from './nodes/utils';\nimport * as IOInput from './nodes/io_input';\nimport * as IOOutput from './nodes/io_output';\nimport * as CoreSubgraph from './nodes/core_subgraph';\nimport * as CoreThenSubgraph from './nodes/core_thensubgraph';\nimport * as CorePack from './nodes/core_pack';\nimport * as CoreUnpack from './nodes/core_unpack';\nimport * as CoreIfThen from './nodes/core_ifthen';\nimport * as DataLiteral from './nodes/data_literal';\nimport * as DataHub from './nodes/data_hub';\nimport * as Functional from './nodes/functional';\nimport * as LogicSelect from './nodes/logic_select';\nimport * as LogicLatch from './nodes/logic_latch';\nimport * as LogicDelay from './nodes/logic_delay';\n\n// Re-export all primitives for backward compatibility\nexport * from './nodes/binary';\nexport * from './nodes/unary';\nexport * from './nodes/list';\nexport * from './nodes/constants';\nexport * from './nodes/utils';\nexport * from './nodes/io_input';\nexport * from './nodes/io_output';\nexport * from './nodes/core_subgraph';\nexport * from './nodes/core_thensubgraph';\nexport * from './nodes/core_pack';\nexport * from './nodes/core_unpack';\nexport * from './nodes/core_ifthen';\nexport * from './nodes/data_literal';\nexport * from './nodes/data_hub';\nexport * from './nodes/functional';\nexport * from './nodes/logic_select';\nexport * from './nodes/logic_latch';\nexport * from './nodes/logic_delay';\n\n// Aggregate ALL_PRIMITIVES for tests and legacy registration tools\nconst modules = [\n  Binary, Unary, List, Constants, Utils, IOInput, IOOutput,\n  CoreSubgraph, CoreThenSubgraph, CorePack, CoreUnpack, CoreIfThen, DataLiteral, DataHub, Functional,\n  LogicSelect, LogicLatch, LogicDelay\n];\n\nexport const ALL_PRIMITIVES: PrimitiveNodeDefinition[] = modules.flatMap(mod =>\n  Object.values(mod).filter((exp): exp is PrimitiveNodeDefinition =>\n    typeof exp === 'object' && exp !== null && 'kind' in exp && exp.kind === 'primitive'\n  )\n);","import '../customnodes/registration-worker';\nimport { AppState, GraphState, GridNode } from './state';\nimport { GraphDefinition, NodeInstance, Structor, StructorType, RecordType, AnalysisContext } from '../structor/structor';\nimport { NodeRepository } from '../structor/repository';\nimport { resolvePortName } from '../structor/primitives';\n\n/**\n * Compiles the current AppState into a flat GraphDefinition ready for execution.\n * Recursively flattens subgraphs.\n */\nexport function compileGraph(\n  appState: AppState,\n  loadedSubgraphs: Map<string, GraphState>,\n  nodeRepository: NodeRepository\n): {\n  graph: GraphDefinition,\n  inferredTypes: Record<string, { inputs: StructorType, outputs: StructorType }>,\n  virtualInputMappings: Record<string, Record<string, string>>,\n  outputRemappings: Record<string, Record<string, string>>,\n  nodeMetadata: Record<string, any>\n  idMap: Record<string, string>\n} {\n  const flatNodes: Record<string, NodeInstance> = {};\n  const nodeUiConfigs: Record<string, any> = {}; // Store raw UI configs for re-compilation\n  const nodeMetadata: Record<string, any> = {}; // Store metadata from forward pass\n  const idMap: Record<string, string> = {}; // Map Source ID -> Compiled ID\n  const flatConnections: {\n    fromNode: string;\n    fromPort: string | number;\n    toNode: string;\n    toPort: string | number;\n  }[] = [];\n  const flatInputs: Record<string, { nodeId: string; port: string | number }> = {};\n  const flatOutputs: Record<string, { nodeId: string; port: string | number }> = {};\n  const virtualInputMappings: Record<string, Record<string, string>> = {};\n  const outputRemappings: Record<string, Record<string, string>> = {};\n\n  // Helper to process a graph recursively\n  function processGraph(\n    graph: GraphState,\n    idPrefix: string,\n    // Removed isRoot, as implicit grouping should work in nested graphs too.\n    parentConfigValues: Record<string, any> = {},\n    parentSubgraphId: string | null = null,\n    recursionPath: Set<string> = new Set(),\n    executionTag: string | undefined = undefined,\n    executionOwnerId: string | undefined = undefined\n  ) {\n    // 0. Local Pre-calculation: Identify Parent-Child Relationships in THIS graph scope\n    const childToParent = new Map<string, string>();\n    const parentNodes = new Set<string>();\n\n    for (const node of Object.values(graph.inner.nodes)) {\n      const nodeType = nodeRepository.getNodeType(node.config.typeId);\n      if (nodeType && nodeType.getChildren) {\n        const children = nodeType.getChildren(node, graph.inner.nodes);\n        for (const childId of children) {\n          if (childToParent.has(childId)) {\n            console.warn(`Node ${childId} is owned by multiple parents! Keeping ${childToParent.get(childId)}, ignoring ${node.id}.`);\n            continue;\n          }\n          childToParent.set(childId, node.id);\n        }\n        if (children.length > 0) {\n          parentNodes.add(node.id);\n        }\n      }\n    }\n\n    // 1. Process Nodes\n    for (const node of Object.values(graph.inner.nodes)) {\n      // Skip if this node is implicitly owned by another node in the SAME graph level\n      if (childToParent.has(node.id)) {\n        continue;\n      }\n\n      const nodeId = idPrefix + node.id;\n      const nodeType = nodeRepository.getNodeType(node.config.typeId);\n\n      // Check for subgraph expansion\n      // Explicit Subgraph (External File) vs Implicit Subgraph (Embedded Children)\n      // We prioritize Implicit if the node definition supports `getChildren`.\n\n      if (nodeType && nodeType.getChildren) {\n        // IMPLICIT PARENT NODE (e.g. core.ifthen)\n\n        const childrenIds = nodeType.getChildren(node, graph.inner.nodes);\n\n        if (childrenIds.length > 0) {\n          // 2. Construct Transient Graph for children\n          const transientGraph: GraphState = {\n            inner: {\n              nodes: {},\n              connections: {}\n            },\n            auxiliary: { outgoingConnections: new Map(), incomingConnections: new Map() }\n          } as any;\n\n          const childSet = new Set(childrenIds);\n\n          // Copy nodes to transient graph\n          childrenIds.forEach(cid => {\n            transientGraph.inner.nodes[cid] = graph.inner.nodes[cid];\n          });\n\n          // Copy/Filter connections\n          Object.values(graph.inner.connections).forEach(conn => {\n            if (childSet.has(conn.fromNodeId) && childSet.has(conn.toNodeId)) {\n              transientGraph.inner.connections[conn.id] = conn;\n            }\n          });\n\n          // 3. Define Context\n          // Note: subgraphExpansionTag is on PrimitiveNodeDefinition, but we can check safely\n          const implicitTag = (nodeType?.definition as any)?.subgraphExpansionTag;\n\n          let nextExecutionTag = executionTag;\n          let nextOwnerId = executionOwnerId;\n\n          if (implicitTag && implicitTag !== 'inline') {\n            nextExecutionTag = implicitTag;\n            nextOwnerId = nodeId;\n          }\n\n          // 4. Recurse\n          processGraph(transientGraph, nodeId + '.', node.config.values || {}, node.id, recursionPath, nextExecutionTag, nextOwnerId);\n        }\n\n        // 5. Add Parent Node itself\n        const instanceConfig = nodeType?.compileConfig\n          ? nodeType.compileConfig(node.config)\n          : (node.config as unknown as Structor);\n\n        flatNodes[nodeId] = {\n          definitionId: node.config.typeId,\n          defaultConfig: instanceConfig,\n          executionOwnerId: executionOwnerId\n        };\n        nodeUiConfigs[nodeId] = node.config;\n      } else if ((nodeType?.definition as any)?.subgraphExpansionTag) {\n        // EXPLICIT SUBGRAPH (Inline or Conditional)\n        // Only enter this if it wasn't handled as implicit parent.\n        const subgraphTag = (nodeType!.definition as any).subgraphExpansionTag;\n        // It's a subgraph expander (inline or conditional)\n        const subgraphId = node.config.subgraphId;\n\n        // Cycle Detection\n        if (recursionPath.has(subgraphId)) {\n          console.error(`Cycle detected: Subgraph ${subgraphId} includes itself (stack: ${Array.from(recursionPath).join(' -> ')}). Skipping.`);\n          continue;\n        }\n\n        // Recursively process subgraph\n        const subgraph = loadedSubgraphs.get(subgraphId);\n\n        if (!subgraph) {\n          console.warn(`Subgraph ${subgraphId} not found for node ${node.id}`);\n          continue;\n        }\n\n        // Determine execution context for children\n        let nextExecutionTag = executionTag;\n        let nextOwnerId = executionOwnerId;\n\n        if (subgraphTag !== 'inline') {\n          nextExecutionTag = subgraphTag;\n          nextOwnerId = nodeId;\n        }\n\n        // Recurse with new prefix and updated path\n        const newPath = new Set(recursionPath);\n        newPath.add(subgraphId);\n\n        processGraph(subgraph, nodeId + '.', node.config.values || {}, node.id, newPath, nextExecutionTag, nextOwnerId);\n\n        // Also add the subgraph container node itself to flatNodes\n        const instanceConfig = nodeType?.compileConfig\n          ? nodeType.compileConfig(node.config)\n          : (node.config as unknown as Structor);\n\n        flatNodes[nodeId] = {\n          definitionId: node.config.typeId,\n          defaultConfig: instanceConfig,\n          executionOwnerId: executionOwnerId\n        };\n        nodeUiConfigs[nodeId] = node.config;\n      } else {\n        // Regular node\n        const { typeId } = node.config;\n\n        const nodeType = nodeRepository.getNodeType(typeId);\n        const instanceConfig = nodeType?.compileConfig\n          ? nodeType.compileConfig(node.config)\n          : (node.config as unknown as Structor);\n\n        const instance: NodeInstance = {\n          definitionId: typeId,\n          defaultConfig: instanceConfig,\n          executionTag,\n          executionOwnerId\n        };\n\n        const compiledId = nodeId; // which is idPrefix + node.id\n        flatNodes[compiledId] = instance;\n        nodeUiConfigs[compiledId] = node.config;\n\n        // Map Source ID -> Compiled ID\n        // Note: This assumes source node IDs are unique in the context of the user interaction\n        // For implicit subgraphs (spatially nested), they are unique in the graph.\n        idMap[node.id] = compiledId;\n\n        if (idPrefix === '') { // Top level\n          if (node.config.typeId === 'io.input' || node.config.typeId === 'input') {\n            const name = node.config.name || node.id;\n            flatInputs[name] = { nodeId: nodeId, port: 'value' };\n          } else if (node.config.typeId === 'io.output' || node.config.typeId === 'output') {\n            const name = node.config.name || node.id;\n            flatOutputs[name] = { nodeId: nodeId, port: 'value' };\n          }\n        }\n\n        // --- Virtual Input Propagation ---\n        if (idPrefix !== '' && (node.config.typeId === 'io.input' || node.config.typeId === 'input')) {\n          const inputNodes = Object.values(graph.inner.nodes)\n            .filter(n => n.config.typeId === 'io.input' || n.config.typeId === 'input')\n            .sort((a, b) => a.y - b.y);\n\n          const myIndex = inputNodes.findIndex(n => n.id === node.id);\n          if (myIndex !== -1) {\n            const rawName = node.config.name || 'value';\n            const portName = resolvePortName(rawName, myIndex, inputNodes.length, 'input');\n\n            // 1. Static Injection (Phase 1)\n            const injectedValue = parentConfigValues[portName];\n\n            if (!instance.defaultConfig) instance.defaultConfig = { fields: {} };\n\n            if (injectedValue !== undefined) {\n              if (!(instance.defaultConfig as any).values) (instance.defaultConfig as any).values = {};\n              (instance.defaultConfig as any).values[portName] = injectedValue;\n            }\n\n            // Ensure the inner node knows its resolved name (e.g. replacing '#' with 'in')\n            if ((instance.defaultConfig as any).fields) {\n              (instance.defaultConfig as any).fields.name = portName;\n            } else {\n              (instance.defaultConfig as any).name = portName;\n            }\n\n            // Ensure the port is in 'values' so Executor scans it for connections\n            if (!(instance.defaultConfig as any).values) (instance.defaultConfig as any).values = {};\n            if (!Object.prototype.hasOwnProperty.call((instance.defaultConfig as any).values, portName)) {\n              (instance.defaultConfig as any).values[portName] = undefined;\n            }\n\n            // 2. Dynamic Mapping (Phase 2)\n            if (parentSubgraphId) {\n              if (!virtualInputMappings[parentSubgraphId]) {\n                virtualInputMappings[parentSubgraphId] = {};\n              }\n              virtualInputMappings[parentSubgraphId][portName] = nodeId;\n            }\n          }\n        }\n\n        if (idPrefix !== '' && (node.config.typeId === 'io.output' || node.config.typeId === 'output')) {\n          // New: Output Remapping for Debug Values\n          if (parentSubgraphId) {\n            const outputNodes = Object.values(graph.inner.nodes)\n              .filter(n => n.config.typeId === 'io.output' || n.config.typeId === 'output')\n              .sort((a, b) => a.y - b.y);\n\n            const myIndex = outputNodes.findIndex(n => n.id === node.id);\n            if (myIndex !== -1) {\n              const rawName = node.config.name || 'value';\n              const portName = resolvePortName(rawName, myIndex, outputNodes.length, 'output');\n\n              if (!outputRemappings[parentSubgraphId]) {\n                outputRemappings[parentSubgraphId] = {};\n              }\n              outputRemappings[parentSubgraphId][portName] = nodeId;\n            }\n          }\n        }\n\n        // Process Virtual Inputs (Standard)\n        // We need to consider both explicitly configured values AND default values for unconnected ports.\n\n        // 1. Determine all potential input ports\n        let inputPorts: { name: string, defaultValue?: any }[] = [];\n        if (nodeType) {\n          if (Array.isArray(nodeType.inputs)) {\n            inputPorts = nodeType.inputs;\n          } else if (nodeType.inputs && (nodeType.inputs as any).kind === 'record') {\n            // Convert RecordType to simplified input list for virtual processing\n            inputPorts = Object.entries((nodeType.inputs as any).fields || {}).map(([key, val]) => ({\n              name: key,\n              defaultValue: (val as any).defaultValue\n            }));\n          }\n        }\n\n        // 2. Collect all port names to process (defined inputs + any extra keys in config.values)\n        const portsToProcess = new Set<string>(inputPorts.map(p => p.name));\n        if (node.config.values) {\n          Object.keys(node.config.values).forEach(k => portsToProcess.add(k));\n        }\n\n        for (const portName of portsToProcess) {\n          // Check if this port is already connected in the original graph\n          const isConnected = Object.values(graph.inner.connections).some(\n            c => c.toNodeId === node.id && c.toPort === portName\n          );\n\n          if (!isConnected) {\n            // Determine value: Config > Default > undefined\n            let value = node.config.values?.[portName];\n\n            if (value === undefined) {\n              const portDef = inputPorts.find(p => p.name === portName);\n              if (portDef && portDef.defaultValue !== undefined) {\n                value = portDef.defaultValue;\n              } else if (portDef && (portDef as any).type && ((portDef as any).type as any).defaultValue !== undefined) {\n                value = ((portDef as any).type as any).defaultValue;\n              }\n            }\n\n            if (value !== undefined) {\n              // Inject into defaultConfig.values so GraphExecutor can pick it up dynamically\n              if (!instance.defaultConfig) instance.defaultConfig = { fields: {} };\n              if (!(instance.defaultConfig as any).values) (instance.defaultConfig as any).values = {};\n              (instance.defaultConfig as any).values[portName] = value;\n            }\n          }\n        }\n      }\n\n    }\n\n    // 2. Process Connections\n    for (const conn of Object.values(graph.inner.connections)) {\n      // Resolve Source\n      let baseFromNodeId = idPrefix + conn.fromNodeId;\n      if (childToParent.has(conn.fromNodeId)) {\n        baseFromNodeId = idPrefix + childToParent.get(conn.fromNodeId)! + '.' + conn.fromNodeId;\n      }\n      let fromNodeId = baseFromNodeId;\n      let fromPort = conn.fromPort;\n\n      const fromNode = graph.inner.nodes[conn.fromNodeId];\n      // Check if fromNode is a subgraph expander\n      const fromNodeType = fromNode ? nodeRepository.getNodeType(fromNode.config.typeId) : undefined;\n      const fromIsSubgraph = (fromNodeType?.definition as any)?.subgraphExpansionTag;\n\n      if (fromNode && fromIsSubgraph) {\n        // Connection FROM a subgraph node (output of subgraph)\n        const subgraphId = fromNode.config.subgraphId;\n        const subgraph = loadedSubgraphs.get(subgraphId);\n        if (subgraph) {\n          const outputNodes = Object.values(subgraph.inner.nodes)\n            .filter(n => n.config.typeId === 'io.output' || n.config.typeId === 'output')\n            .sort((a, b) => a.y - b.y);\n\n          const outputNode = outputNodes.find((n, i) => {\n            const rawName = (n.config as any).name || 'value';\n            const portName = resolvePortName(rawName, i, outputNodes.length, 'output');\n            return portName === fromPort;\n          });\n\n          if (outputNode) {\n            // Rewire: Source is the 'output' node inside the subgraph\n            fromNodeId = baseFromNodeId + '.' + outputNode.id;\n            fromPort = 'value'; // Output nodes output on 'value' (identity)\n          }\n        }\n      }\n\n      // Resolve Destination\n      let baseToNodeId = idPrefix + conn.toNodeId;\n      if (childToParent.has(conn.toNodeId)) {\n        baseToNodeId = idPrefix + childToParent.get(conn.toNodeId)! + '.' + conn.toNodeId;\n      }\n      let toNodeId = baseToNodeId;\n      let toPort = conn.toPort;\n\n      const toNode = graph.inner.nodes[conn.toNodeId];\n      // Check if toNode is a subgraph expander\n      const toNodeType = toNode ? nodeRepository.getNodeType(toNode.config.typeId) : undefined;\n      const toIsSubgraph = (toNodeType?.definition as any)?.subgraphExpansionTag;\n\n      if (toNode && toIsSubgraph) {\n        // Connection TO a subgraph node (input of subgraph)\n        const subgraphId = toNode.config.subgraphId;\n        const subgraph = loadedSubgraphs.get(subgraphId);\n        if (subgraph) {\n          const inputNodes = Object.values(subgraph.inner.nodes)\n            .filter(n => n.config.typeId === 'io.input' || n.config.typeId === 'input')\n            .sort((a, b) => a.y - b.y);\n\n          const inputNode = inputNodes.find((n, i) => {\n            const rawName = (n.config as any).name || 'value';\n            const portName = resolvePortName(rawName, i, inputNodes.length, 'input');\n            return portName === toPort;\n          });\n\n          if (inputNode) {\n            // Rewire: Destination is the 'input' node inside the subgraph\n            toNodeId = baseToNodeId + '.' + inputNode.id;\n            // Use the named port (resolved) to match Virtual Input injection keys.\n            toPort = toPort;\n          }\n        }\n      }\n\n      let validSource = true;\n      if (fromNode && fromIsSubgraph) {\n        // If tag == 'inline', strict rewiring?\n        if (fromIsSubgraph === 'inline' && fromNodeId === baseFromNodeId) {\n          validSource = false;\n        }\n      }\n\n      let validDest = true;\n      if (toNode && toIsSubgraph) {\n        if (toIsSubgraph === 'inline' && toNodeId === baseToNodeId) {\n          validDest = false;\n        }\n      }\n\n      if (validSource && validDest) {\n        flatConnections.push({\n          fromNode: fromNodeId,\n          fromPort,\n          toNode: toNodeId,\n          toPort\n        });\n\n        // Implicit Dependency Injection for Non-Inline Subgraphs\n\n        // Case 0: Implicit Child -> Destination (Parent -> Destination)\n        if (childToParent.has(conn.fromNodeId)) {\n          const parentId = idPrefix + childToParent.get(conn.fromNodeId)!;\n          if (parentId !== toNodeId) {\n            flatConnections.push({\n              fromNode: parentId,\n              fromPort: '___control___',\n              toNode: toNodeId,\n              toPort: '___control___'\n            });\n          }\n        }\n\n        // Case 1: Subgraph Output (Wrapper -> Peer via Inner)\n        if (fromIsSubgraph && fromIsSubgraph !== 'inline') {\n          const wrapperId = baseFromNodeId;\n          // If rewired (targeting inner node), add dependency Wrapper -> Destination\n          if (fromNodeId !== wrapperId) {\n            flatConnections.push({\n              fromNode: wrapperId,\n              fromPort: '___control___',\n              toNode: toNodeId,\n              toPort: '___control___'\n            });\n          }\n        }\n\n        // Case 2: Subgraph Input (Peer -> Wrapper via Inner)\n        if (toIsSubgraph && toIsSubgraph !== 'inline') {\n          const wrapperId = baseToNodeId;\n          // If rewired (targeting inner node), add dependency Source -> Wrapper\n          if (toNodeId !== wrapperId) {\n            flatConnections.push({\n              fromNode: fromNodeId,\n              fromPort: '___control___',\n              toNode: wrapperId,\n              toPort: '___control___'\n            });\n          }\n        }\n      }\n    }\n\n\n  }\n\n  processGraph(appState.graph, '');\n\n  // 3. Cycle Detection and Breaking (and Topological Sort)\n  const adjacency = new Map<string, Array<{ toNode: string; connIndex: number }>>();\n  const inDegree = new Map<string, number>();\n\n  // Initialize in-degrees\n  Object.keys(flatNodes).forEach(nodeId => inDegree.set(nodeId, 0));\n\n  flatConnections.forEach((conn, index) => {\n    if (!flatNodes[conn.fromNode] || !flatNodes[conn.toNode]) return;\n\n    if (!adjacency.has(conn.fromNode)) {\n      adjacency.set(conn.fromNode, []);\n    }\n    adjacency.get(conn.fromNode)!.push({ toNode: conn.toNode, connIndex: index });\n    inDegree.set(conn.toNode, (inDegree.get(conn.toNode) || 0) + 1);\n  });\n\n  // Kahn's Algorithm for Topological Sort & Cycle Breaking\n  const executionOrder: string[] = [];\n  const queue: string[] = [];\n  const validConnectionIndices = new Set<number>();\n\n  for (const [nodeId, degree] of inDegree) {\n    if (degree === 0) queue.push(nodeId);\n  }\n\n  // Loop until all nodes are processed or we can't make progress\n  while (executionOrder.length < Object.keys(flatNodes).length) {\n\n    // 1. Cycle Detection & Rescue\n    if (queue.length === 0) {\n      // We are stuck (either at start or mid-stream).\n      const remainingNodes = Object.keys(flatNodes).filter(n => !executionOrder.includes(n));\n\n      let brokenAny = false;\n\n      // Look for cycle breaking ports\n      for (const nodeId of remainingNodes) {\n        const instance = flatNodes[nodeId];\n        const nodeDef = nodeRepository.get(instance.definitionId);\n\n        if (nodeDef && nodeDef.kind === 'primitive' && nodeDef.cycleBreakingPorts && nodeDef.cycleBreakingPorts.length > 0) {\n          const breakingPorts = new Set(nodeDef.cycleBreakingPorts);\n          let brokenCount = 0;\n\n          flatConnections.forEach((conn, index) => {\n            if (conn.toNode === nodeId && remainingNodes.includes(conn.fromNode)) {\n              if (breakingPorts.has(conn.toPort.toString())) {\n                inDegree.set(nodeId, (inDegree.get(nodeId) || 0) - 1);\n                validConnectionIndices.add(index); // Mark valid!\n                brokenCount++;\n              }\n            }\n          });\n\n          if (brokenCount > 0) {\n            brokenAny = true;\n            if ((inDegree.get(nodeId) || 0) <= 0) {\n              queue.push(nodeId);\n            }\n          }\n        }\n      }\n\n      if (!brokenAny && remainingNodes.length > 0) {\n        // Fallback: Pick candidate with lowest in-degree\n        let minDegree = Infinity;\n        let candidate = remainingNodes[0];\n\n        for (const n of remainingNodes) {\n          const deg = inDegree.get(n) || 0;\n          if (deg < minDegree) {\n            minDegree = deg;\n            candidate = n;\n          }\n        }\n        queue.push(candidate);\n      }\n\n      if (queue.length === 0) break; // Failed to recover\n    }\n\n    // 2. Process Queue\n    if (queue.length > 0) {\n      const u = queue.shift()!;\n      executionOrder.push(u);\n\n      if (adjacency.has(u)) {\n        for (const { toNode, connIndex } of adjacency.get(u)!) {\n          validConnectionIndices.add(connIndex);\n          inDegree.set(toNode, (inDegree.get(toNode) || 0) - 1);\n          if (inDegree.get(toNode) === 0) {\n            queue.push(toNode);\n          }\n        }\n      }\n    }\n  }\n\n  if (executionOrder.length !== Object.keys(flatNodes).length) {\n    console.warn(`Graph contains cycles! Forced execution order.`);\n    for (const nodeId of Object.keys(flatNodes)) {\n      if (!executionOrder.includes(nodeId)) executionOrder.push(nodeId);\n    }\n  }\n\n  const validConnections = flatConnections\n    .filter((_, index) => validConnectionIndices.has(index))\n    .filter(c => flatNodes[c.fromNode] && flatNodes[c.toNode]);\n\n  // --- Type Compilation Passes ---\n\n  const nodeTypes = new Map<string, {\n    inputs: StructorType;\n    outputs: StructorType;\n  }>();\n\n  const outputRequirements = new Map<string, Record<string, StructorType>>();\n  const backwardMetadata = new Map<string, any>();\n\n  for (const nodeId of executionOrder) {\n    outputRequirements.set(nodeId, {});\n  }\n\n  // --- BACKWARD PASS ---\n  const context: AnalysisContext & { loadedSubgraphs: Map<string, GraphState> } = {\n    repository: nodeRepository,\n    broadcast: () => undefined,\n    loadedSubgraphs\n  };\n\n  for (let i = executionOrder.length - 1; i >= 0; i--) {\n    const nodeId = executionOrder[i];\n    const instance = flatNodes[nodeId];\n    const nodeDef = nodeRepository.get(instance.definitionId);\n\n    if (nodeDef && nodeDef.kind === 'primitive') {\n      const reqs = { kind: 'record', fields: outputRequirements.get(nodeId) || {} } as RecordType;\n      const config = instance.defaultConfig || { fields: {} };\n\n      let inputReqs: RecordType = {\n        kind: 'record',\n        fields: nodeDef.inputs ? { ...nodeDef.inputs } : {}\n      };\n\n      if (nodeDef.computeBackwardPorts) {\n        try {\n          const result = nodeDef.computeBackwardPorts(reqs, config, context);\n          inputReqs = {\n            kind: 'record',\n            fields: { ...inputReqs.fields, ...result.inputRequirements.fields }\n          };\n\n          if (result.backwardMetadata) {\n            backwardMetadata.set(nodeId, result.backwardMetadata);\n          }\n        } catch (e) {\n          console.warn(`Backward pass failed for ${nodeId} (${nodeDef.id}):`, e);\n        }\n      }\n\n      const inputConns = validConnections.filter(c => c.toNode === nodeId);\n\n      for (const conn of inputConns) {\n        const upstreamNodeId = conn.fromNode;\n        const upstreamPort = conn.fromPort.toString();\n        const downstreamPort = conn.toPort.toString();\n\n        if (inputReqs.fields[downstreamPort]) {\n          const upstreamReqs = outputRequirements.get(upstreamNodeId)!;\n          upstreamReqs[upstreamPort] = inputReqs.fields[downstreamPort];\n        }\n      }\n    }\n  }\n\n  // 5. Forward Pass (DataFlow Analysis)\n  for (const nodeId of executionOrder) {\n    const instance = flatNodes[nodeId];\n\n    const nodeDef = nodeRepository.get(instance.definitionId);\n    if (!nodeDef) continue; // Should have been caught earlier\n\n\n\n    // Resolve input types from connections\n\n    // Resolve input types from connections\n    const collectedInputs: RecordType = { kind: 'record', fields: {} };\n    const resolvedInputs: Record<string, StructorType> = {};\n\n\n    // Inefficient O(C) lookup for each node. (Better: Pre-group incoming connections)\n    // Actually we have flatConnections. We can build a map.\n    // Optimisation: Do it once.\n    // ... skipping optimization for now ...\n\n    // Find incoming connections\n    const incoming = validConnections.filter(c => c.toNode === nodeId);\n    const inputsByPort = new Map<string, StructorType[]>();\n\n    for (const conn of incoming) {\n      if (!nodeTypes.has(conn.fromNode)) {\n        // console.warn(`[ForwardPass] Missing inferred types for upstream ${conn.fromNode}`);\n        continue;\n      }\n      const fromType = nodeTypes.get(conn.fromNode)?.outputs;\n\n\n\n      if (fromType && fromType.kind === 'record') {\n        const portName = conn.fromPort.toString();\n        if (fromType.fields[portName]) {\n          if (!inputsByPort.has(conn.toPort.toString())) {\n            inputsByPort.set(conn.toPort.toString(), []);\n          }\n          inputsByPort.get(conn.toPort.toString())!.push(fromType.fields[portName]);\n        }\n      }\n    }\n\n    const expectedInputs = nodeDef.inputs || {};\n\n    for (const [port, types] of inputsByPort) {\n      const expected = expectedInputs[port];\n      if (expected && 'kind' in expected && expected.kind === 'array') {\n        if (types.length > 0) {\n          resolvedInputs[port] = { kind: 'array', element: types[0], size: types.length };\n        }\n      } else {\n        if (types.length > 0) {\n          resolvedInputs[port] = types[types.length - 1];\n        }\n      }\n    }\n\n    const inputRecordType: RecordType = {\n      kind: 'record',\n      fields: resolvedInputs\n    };\n\n    const config = instance.defaultConfig || { fields: {} };\n    let outputRecordType: RecordType;\n    let finalInputType: RecordType = inputRecordType;\n\n    try {\n      if (nodeDef.kind === 'primitive' && nodeDef.computeForwardPorts) {\n        const result = nodeDef.computeForwardPorts(\n          inputRecordType,\n          config,\n          context,\n          backwardMetadata.get(nodeId)\n        );\n        finalInputType = result.inputs;\n        outputRecordType = result.outputs;\n\n        // Capture Metadata\n        if (result.forwardMetadata) {\n          nodeMetadata[nodeId] = result.forwardMetadata;\n        }\n      } else {\n        outputRecordType = (nodeDef.outputs && (nodeDef.outputs as any).kind === 'record'\n          ? nodeDef.outputs\n          : { kind: 'record', fields: {} }) as RecordType;\n      }\n    } catch (e) {\n      console.warn(`Failed to compute output types for node ${nodeId} (${nodeDef.id}):`, e);\n      outputRecordType = { kind: 'record', fields: {} };\n    }\n\n    nodeTypes.set(nodeId, {\n      inputs: finalInputType,\n      outputs: outputRecordType\n    });\n  }\n\n\n  // --- Metadata & Re-Compilation Pass ---\n  // Now that we have all metadata, let's re-run compileConfig for nodes that produced metadata.\n  for (const nodeId of executionOrder) {\n    const instance = flatNodes[nodeId];\n    const nodeDef = nodeRepository.get(instance.definitionId);\n\n    // Check if we have metadata for this node\n    const metadata = nodeMetadata[nodeId];\n\n    if (metadata && nodeDef && nodeDef.kind === 'primitive' && nodeDef.compileConfig) {\n      const uiConfig = nodeUiConfigs[nodeId];\n      if (uiConfig) {\n        try {\n          const newCompiledConfig = nodeDef.compileConfig(uiConfig, metadata);\n\n          // Re-inject the values from the original compiled config (virtual inputs)\n          // Because compileConfig might return a fresh object without them if it doesn't handle them explicitly.\n          // Although typical compileConfig implementation should handle it, let's be safe and merge 'values'.\n          // Wait, 'compileConfig' is responsible for returning TCompiledConfig.\n          // Virtual inputs are injected into 'defaultConfig.values' in processGraph.\n          // If we overwrite instance.defaultConfig, we lose them!\n\n          const oldValues = (instance.defaultConfig as any)?.values;\n\n          instance.defaultConfig = newCompiledConfig;\n\n          if (oldValues) {\n            if (!(instance.defaultConfig as any).values) {\n              (instance.defaultConfig as any).values = {};\n            }\n            Object.assign((instance.defaultConfig as any).values, oldValues);\n          }\n\n        } catch (e) {\n          console.warn(`Re-compilation failed for ${nodeId} (${nodeDef.id}):`, e);\n        }\n      }\n    }\n  }\n\n  const inferredTypes: Record<string, { inputs: StructorType, outputs: StructorType }> = {};\n  for (const [id, types] of nodeTypes) {\n    inferredTypes[id] = types;\n  }\n\n\n\n  const graph: GraphDefinition = {\n    id: 'compiled-graph',\n    kind: 'graph',\n    type: { kind: 'graph', inputs: { kind: 'record', fields: {} }, outputs: { kind: 'record', fields: {} } },\n    nodes: flatNodes,\n    connections: validConnections,\n    inputs: flatInputs,\n    outputs: flatOutputs,\n    executionOrder,\n    virtualInputMappings // Attach mappings for Executor\n  };\n\n  return {\n    graph,\n    inferredTypes,\n    virtualInputMappings,\n    outputRemappings,\n    nodeMetadata,\n    idMap\n  };\n}\n","import { compileGraph } from '../builder/compiler';\nimport { defaultNodeRepository } from '../structor/repository';\nimport { CompilerWorkerMessage, GraphCompiledMessage } from './types';\nimport { GraphState } from '../builder/state';\n\nself.onerror = (e) => {\n  console.error('Compiler Worker Error (Global):', e);\n  // Optional: Post error back to main thread if we had a message type for it\n};\n\nself.onmessage = async (event: MessageEvent<CompilerWorkerMessage>) => {\n  const { type } = event.data;\n\n  if (type === 'COMPILE_GRAPH') {\n    const { state, subgraphs } = event.data;\n    try {\n      // Convert subgraphs Record to Map\n      const subgraphsMap = new Map<string, GraphState>(Object.entries(subgraphs));\n\n      // 0. Pre-load dependencies for nodes (e.g. TypeScript for Expression Node)\n      const uniqueTypeIds = new Set<string>();\n      // State is AppState, so we need state.graph.inner.nodes\n      if (state.graph && state.graph.inner && state.graph.inner.nodes) {\n        Object.values(state.graph.inner.nodes).forEach(n => uniqueTypeIds.add(n.config.typeId));\n      }\n\n      subgraphsMap.forEach(g => {\n        if (g.inner && g.inner.nodes) {\n          Object.values(g.inner.nodes).forEach(n => uniqueTypeIds.add(n.config.typeId));\n        }\n      });\n\n      const processedTypes = new Set<string>();\n      const loadPromises: Promise<void>[] = [];\n\n      for (const typeId of uniqueTypeIds) {\n        if (processedTypes.has(typeId)) continue;\n        processedTypes.add(typeId);\n\n        const nodeType = defaultNodeRepository.getNodeType(typeId);\n        if (nodeType && nodeType.definition && (nodeType.definition as any).loadCompileDeps) {\n          loadPromises.push((nodeType.definition as any).loadCompileDeps());\n        }\n      }\n\n      if (loadPromises.length > 0) {\n        // console.log(`Compiler Worker: Loading dependencies for ${loadPromises.length} node types...`);\n        await Promise.all(loadPromises);\n      }\n\n      // console.log('Compiler Worker: Compiling graph...');\n      const { graph, inferredTypes, virtualInputMappings, outputRemappings, nodeMetadata, idMap } = compileGraph(state, subgraphsMap, defaultNodeRepository);\n      const response: GraphCompiledMessage = {\n        type: 'GRAPH_COMPILED',\n        graph,\n        inferredTypes,\n        virtualInputMappings,\n        outputRemappings,\n        nodeMetadata,\n        idMap\n      };\n\n      self.postMessage(response);\n    } catch (error) {\n      console.error('Compiler Worker Error:', error);\n      // We might want an error message type, but for now just log\n    }\n  } else if (type === 'COMPILE_CONFIGS') {\n    try {\n      const { nodes } = event.data;\n\n      // 0. Pre-load dependencies\n      const uniqueTypeIds = new Set<string>();\n      nodes.forEach((n: any) => uniqueTypeIds.add(n.typeId));\n\n      const loadPromises: Promise<void>[] = [];\n      const processedTypes = new Set<string>();\n\n      for (const typeId of uniqueTypeIds) {\n        if (processedTypes.has(typeId)) continue;\n        processedTypes.add(typeId);\n\n        const nodeType = defaultNodeRepository.getNodeType(typeId);\n        if (nodeType && nodeType.definition && (nodeType.definition as any).loadCompileDeps) {\n          loadPromises.push((nodeType.definition as any).loadCompileDeps());\n        }\n      }\n\n      if (loadPromises.length > 0) {\n        await Promise.all(loadPromises);\n      }\n\n      const configs: Record<string, any> = {};\n\n      for (const node of nodes) {\n        const nodeType = defaultNodeRepository.getNodeType(node.typeId);\n        if (nodeType && nodeType.compileConfig) {\n          configs[node.id] = nodeType.compileConfig(node.config);\n        } else {\n          configs[node.id] = node.config; // Fallback to raw config\n        }\n      }\n\n      self.postMessage({\n        type: 'CONFIGS_COMPILED',\n        configs\n      });\n    } catch (error) {\n      console.error('Compiler Worker Error (Multi Config):', error);\n    }\n  }\n};\n"],"names":["NumberType","StringType","AnyType","fromStructor","value","type","v","rec","result","k","fieldType","toStructor","fields","definePrimitiveNode","options","configType","outputType","rawInput","rawConfig","context","state","processedConfig","inputs","rawFields","key","i","c","ctx","meta","newConfig","oldConfig","processedInput","broadcastConfig","overrides","dynamicOverride","isArray","override","defaultCombine","combine","args","mapped","item","typeIsNested","valueIsNested","val","unwrap","first","res","wrappedFields","rawOutputs","uiOutputs","keys","structorResult","anyResult","typedBroadcast","schema","config","def","processedResult","defineMathNode","id","metadata","op","arity","a","b","unifyTypes","types","t","hasNumber","hasBoolean","RegionVisibility","NodeRepository","node","defaultNodeRepository","defineNode","simpleInputs","ext","inputType","simpleOutputs","uiConfig","inputTypes","backwardMetadata","outputRequirements","registerNode","inputsSource","name","isExtended","outputsSource","outputs","nodeType","NodeCategory","curveStructorType","executeCurveEase","easingConfig","domain","range","segments","minIn","maxIn","minOut","maxOut","totalWeight","sum","s","currentT","matchedSegment","segmentStartT","segmentWidthT","segment","widthT","tInSegment","normY","curve","steps","exponent","points","p1","p2","localT","curve_ease","curve_ease4","executeCurveEnv","envConfig","nodes","firstNode","lastNode","segmentIndex","p0","shapedT","curveVal","safeT","curve_env","curveCropInputs","curve_crop","mode","start","end","length","numberType","stringType","booleanType","anyType","timeBaseEnum","midiEventType","midiStreamType","float4Type","noteStructorType","stepStructorType","sequenceStructorType","debugScopeNode","ExpressionExecutor","graph","cache","resolve","inputId","idx","compilerWrapper","executor","graphCache","getCompiledGraph","code","e","ExpressionFields","expressionNode","module","inputNames","exprInputs","sawtooth","freq","dt","ADSR_PHASE","adsr","stream","attackTime","decayTime","sustainLevel","releaseTime","lcg","seed","random","generator","MidiInputFields","MidiCcInputFields","midiInputNode","midiEvents","deviceId","midiCcInputNode","channel","cc","MidiCcFields","midiCcNode","targetCc","event","MidiNoteFields","midiNoteNode","targetNote","MidiToMonoFields","midiToMonoNode","rootNote","n","activeNote","relativeNote","frequency","midiFilterNode","filteredStream","midiPitchNode","shift","newNote","midiTriggerNode","pitch","velocity","trigger","midiMergeNode","midiSelectNode","count","root","skip","results","diff","index","midiOnChangeNode","changed","weightInputs","midiOnRangeNode","zoneCount","actualStart","actualEnd","targetZone","weights","w","rangeSpan","weightPos","currentW","note","oldNote","TimeBaseModeField","BeatDenomField","MidiDelayFields","midiDelayNode","duration","now","outputStream","remainingQueue","midiIsTriggerNode","hasNoteOn","MetronomeFields","midiMetronomeNode","durationInput","beatDenom","noteNumber","interval","prev","startStep","triggers","timeNode","beatNode","currentBeat","delta","layerOutputStructorType","SEQUENCE_LENGTH","RhythmicFields","rhythmicGenerator","density","sequence","numEvents","SeededRandom","min","max","ChaosFields","chaosGenerator","minNote","maxNote","rng","AbstractLayer","step","isNewStep","isActive","isReleased","GateLayer","vel","noteIndex","prevLayerOutput","ExponentialLayer","decay","output","lastActive","PWMLayer","phase","duty","NoiseLayer","ToneSynthLayer","audioContext","param","time","filterFreq","oldOsc","oldGain","oldFilter","stopTime","f","currentTime","createLayerNode","displayName","LayerClass","activeLayer","syntheticStep","gateLayer","expLayer","pwmLayer","noiseLayer","toneSynthLayer","generateHadamard","h","out","getComplexity","row","generateCodes","resolution","rawCodes","colMap","j","newCode","OrthomodFields","orthomod","decayRaw","curveRaw","sustainCurve","relCurveRaw","releaseCurve","resRaw","phaseRaw","manualPhase","currentEnv","base","pos","rate","sqr","sin","channels","rawChannels","ch","b1","b2","safeNum","createTone4State","tone4","audio","ratios","waves","ratio","osc","gain","masterVol","rootRaw","midiNote","rootFreq","vecRaw","vec","PRE_CONFIG","Sphere","pad","avail","plateY","magnetOn","params","springForce","totalDownForce","getMagneticForce","dist","holdForce","distToPlate","force","magForce","MagnetoFields","magneto","spheres","message","gate","attack","sustain","release","peak","magStr","kp","damp","cw","deep","shallow","plateOpenY","plateClosedY","plateSustainY","speedAttack","speedDecay","speedRelease","FIXED_STEP","magnetActive","targetY","speed","solverDt","sumTension","sumExt","sumFS","sumFM","latchedCount","metricTension","metricExt","maxSpringF","maxMagF","metricFS","metricFM","uiData","tomidi","seqs","currentStepIndex","seqIndices","_","seqIndex","seq","seqState","currentStep","lastNoteIndex","lastHold","isNoteActive","isSameNote","shouldRelease","shouldTrigger","sequencer","defaultSeq","oneshot","allEvents","triggered","stepCount","scan","crop","outSeq","len","fill","startVal","lengthVal","numOn","startIndex","endVal","EmptyStep","createBinaryOpNode","description","acc","firstSeq","stepB","xor","aActive","bActive","sub","and","or","negate","primitive_add","primitive_subtract","primitive_multiply","primitive_divide","primitive_pow","primitive_min","primitive_max","primitive_fmod","dividend","divisor","div","mod","primitive_and","primitive_or","primitive_xor","primitive_equals","primitive_greater_than","primitive_less_than","primitive_abs","primitive_negate","primitive_ceil","primitive_floor","primitive_round","primitive_sin","primitive_cos","primitive_tan","primitive_sqrt","primitive_not","defineAllNode","category","valuesInput","elementType","values","firstIsArray","firstIsRecordVec","vecKeys","rawOperand","operand","resRecord","primitive_all_add","primitive_all_subtract","primitive_all_multiply","primitive_all_divide","primitive_all_pow","primitive_all_min","primitive_all_max","primitive_all_and","primitive_all_or","primitive_all_xor","primitive_all_equals","primitive_all_greater_than","primitive_all_less_than","primitive_pi","primitive_e","primitive_clamp","primitive_lerp","doClamp","primitive_map","inMin","inMax","outMin","outMax","inferTypeFromConfig","typeStr","size","inputConfigType","primitive_input","valType","inferred","input","portName","structor","primitive_output","resolvePortName","total","kind","replacement","computeSubgraphPorts","loadedSubgraphs","subgraphId","subgraph","subgraphNodes","inputFields","inputNodes","outputFields","outputNodes","primitive_subgraph","parts","primitive_thensubgraph","basePorts","events","primitive_pack","outputReqs","targetType","inferredType","resultReq","inputReqs","primitive_unpack","record","detectTriggerMode","primitive_ifthen","allNodes","children","rx","ry","x1","y1","x2","y2","other","finalInputType","inferType","primitive_literal","primitive_hub","primitive_float","primitive_apply","functorType","functor","inputValue","logic_select","configObj","valueTypes","o","rawInputs","valKey","selectedIndex","rawIndex","matchVal","threshold","cfg","logic_latch","initMode","conditionType","triggerMode","valueType","initType","condition","init","logic_delay","modules","Binary","Unary","List","Constants","Utils","IOInput","IOOutput","CoreSubgraph","CoreThenSubgraph","CorePack","CoreUnpack","CoreIfThen","DataLiteral","DataHub","Functional","LogicSelect","LogicLatch","LogicDelay","exp","compileGraph","appState","nodeRepository","flatNodes","nodeUiConfigs","nodeMetadata","idMap","flatConnections","flatInputs","flatOutputs","virtualInputMappings","outputRemappings","processGraph","idPrefix","parentConfigValues","parentSubgraphId","recursionPath","executionTag","executionOwnerId","childToParent","parentNodes","childId","nodeId","childrenIds","transientGraph","childSet","cid","conn","implicitTag","nextExecutionTag","nextOwnerId","instanceConfig","subgraphTag","newPath","typeId","instance","compiledId","myIndex","rawName","injectedValue","inputPorts","portsToProcess","p","portDef","baseFromNodeId","fromNodeId","fromPort","fromNode","fromIsSubgraph","outputNode","baseToNodeId","toNodeId","toPort","toNode","toIsSubgraph","inputNode","validSource","validDest","parentId","wrapperId","adjacency","inDegree","executionOrder","queue","validConnectionIndices","degree","remainingNodes","brokenAny","nodeDef","breakingPorts","brokenCount","minDegree","candidate","deg","u","connIndex","validConnections","nodeTypes","reqs","inputConns","upstreamNodeId","upstreamPort","downstreamPort","upstreamReqs","resolvedInputs","incoming","inputsByPort","fromType","expectedInputs","port","expected","inputRecordType","outputRecordType","newCompiledConfig","oldValues","inferredTypes","subgraphs","subgraphsMap","uniqueTypeIds","processedTypes","loadPromises","response","error","configs"],"mappings":"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"}