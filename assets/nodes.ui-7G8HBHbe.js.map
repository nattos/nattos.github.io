{"version":3,"file":"nodes.ui-7G8HBHbe.js","sources":["../../src/views/graph-widget.ts","../../src/customnodes/curve/nodes.ui.ts"],"sourcesContent":["import { html, css, svg } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport { MobxLitElement } from './mobx-lit-element';\nimport { action, computed, makeObservable, observable } from 'mobx';\nimport { PointerDragOp } from '../utils/pointer-drag-op';\nimport { widgetStyles } from '../styles';\n\nexport type CurveType = 'exponential' | 'linear' | 'step' | 'sin' | 'quad' | 'points';\n\nexport interface GraphSegment {\n  id: string;\n  weight: number;\n  curve: {\n    type: CurveType;\n    value?: number; // For exponential (exponent), step (count)\n    points?: { x: number, y: number }[]; // For points type (normalized 0-1)\n  };\n}\n\nexport interface GraphWidgetConfig {\n  mode?: 'curve' | 'scope';\n  // Curve Mode\n  domain?: [number, number];\n  range?: [number, number];\n  segments?: GraphSegment[];\n  interactive?: boolean;\n  onSegmentChange?: (segmentId: string, param: string, value: number) => void;\n  onSegmentResize?: (segmentIndex: number, newWeight: number) => void;\n  onInteractionStart?: () => void;\n  onInteractionEnd?: () => void;\n  cursor?: number; // Normalized 0-1\n\n  // Scope Mode\n  data?: number[]; // History\n  historySize?: number;\n  autoRange?: boolean;\n  showGrid?: boolean;\n}\n\n@customElement('graph-widget')\nexport class GraphWidget extends MobxLitElement {\n  @property({ attribute: false })\n  config?: GraphWidgetConfig;\n\n  @property({ type: Number })\n  value?: number;\n\n  @property({ type: Number })\n  tick = 0;\n\n  // Scope State\n  private history: number[] = [];\n  private smoothedRange = 1.0;\n  private smoothedAnchor = 0.0;\n  private isSigned = false;\n\n  static styles = [\n    widgetStyles,\n    css`\n      :host {\n        height: 96px;\n        --grid-color: rgba(255, 255, 255, 0.05);\n        --grid-size: 24px;\n      }\n      path.curve {\n        fill: none;\n        stroke: var(--accent-color, #ff4500);\n        stroke-width: 2;\n        pointer-events: none;\n      }\n      .parameter-control {\n        cursor: ns-resize;\n      }\n      .parameter-bg {\n        fill: var(--accent-color, #ff4500);\n        opacity: 0.05;\n        transition: opacity 0.2s;\n      }\n      .parameter-control:hover .parameter-bg {\n        opacity: 0.15;\n      }\n      .parameter-line {\n        stroke: var(--accent-color, #ff4500);\n        stroke-width: 1;\n        vector-effect: non-scaling-stroke;\n        opacity: 0.6;\n        transition: all 0.2s;\n      }\n      .parameter-control:hover .parameter-line {\n        opacity: 1;\n        stroke-width: 2;\n      }\n      .split-handle {\n        stroke: var(--text-muted, #aaa);\n        stroke-width: 1;\n        stroke-dasharray: 2 2;\n        vector-effect: non-scaling-stroke;\n        opacity: 0.5;\n        cursor: col-resize;\n      }\n      .split-handle-target {\n        fill: transparent;\n        cursor: col-resize;\n      }\n      .split-handle-target:hover {\n        fill: rgba(255, 255, 255, 0.1);\n      }\n    `\n  ];\n\n  constructor() {\n    super();\n    makeObservable(this);\n  }\n\n  updated(changedProperties: Map<string, any>) {\n    if ((changedProperties.has('value') || changedProperties.has('tick')) && this.value !== undefined) {\n      this.history.push(this.value);\n      const maxSize = this.config?.historySize || 100;\n      if (this.history.length > maxSize) this.history.shift();\n\n      if (this.config?.mode === 'scope' && this.config.autoRange) {\n        this.updateAdaptiveRange();\n      }\n      // Request update is automatic for property change, but we modified history which is private\n      this.requestUpdate();\n    }\n  }\n\n  private updateAdaptiveRange() {\n    if (this.history.length === 0) return;\n\n    const history = this.history;\n    let minV = history[0];\n    let maxV = history[0];\n    let hasNegative = false;\n\n    for (const v of history) {\n      if (v < minV) minV = v;\n      if (v > maxV) maxV = v;\n      if (v < 0) hasNegative = true;\n    }\n\n    // Latch signed mode\n    if (hasNegative) this.isSigned = true;\n\n    // Calculate required view\n    const padding = 1.2;\n    let targetRange = 1.0;\n    let targetAnchor = 0.0;\n\n    if (this.isSigned) {\n      const signalCenter = (minV + maxV) / 2;\n      const signalSpan = maxV - minV;\n      const requiredSpan = Math.max(signalSpan * padding, 0.001);\n      const quantizedRange = Math.pow(2, Math.ceil(Math.log2(requiredSpan)));\n      const anchorStep = quantizedRange;\n      const quantizedAnchor = Math.round(signalCenter / anchorStep) * anchorStep;\n\n      targetRange = quantizedRange;\n      targetAnchor = quantizedAnchor;\n\n      const viewMin = targetAnchor - targetRange / 2;\n      const viewMax = targetAnchor + targetRange / 2;\n\n      if (minV < viewMin || maxV > viewMax) {\n         targetRange *= 2;\n      }\n    } else {\n      const span = Math.max(maxV - minV, 0.001);\n      let qRange = Math.pow(2, Math.ceil(Math.log2(span * padding)));\n      let qAnchor = Math.floor(minV / qRange) * qRange;\n\n      if (qAnchor + qRange < maxV) {\n        qRange *= 2;\n        qAnchor = Math.floor(minV / qRange) * qRange;\n      }\n\n      targetRange = qRange;\n      targetAnchor = qAnchor;\n    }\n\n    // Range Smoothing\n    if (targetRange > this.smoothedRange) {\n      this.smoothedRange = targetRange;\n    } else {\n      this.smoothedRange = this.smoothedRange * 0.95 + targetRange * 0.05;\n      if (Math.abs(this.smoothedRange - targetRange) < 0.01) this.smoothedRange = targetRange;\n    }\n\n    // Anchor Smoothing\n    const currentDisplayAnchor = this.getDisplayAnchor();\n    const currentDisplayRange = this.getDisplayRange();\n\n    let fits = false;\n    if (this.isSigned) {\n       const safeZone = 0.9;\n       const safeMin = currentDisplayAnchor - (currentDisplayRange * safeZone) / 2;\n       const safeMax = currentDisplayAnchor + (currentDisplayRange * safeZone) / 2;\n       if (minV >= safeMin && maxV <= safeMax) fits = true;\n    } else {\n       const safeMin = currentDisplayAnchor;\n       const safeMax = currentDisplayAnchor + currentDisplayRange * 0.9;\n       if (minV >= safeMin && maxV <= safeMax) fits = true;\n    }\n\n    if (!fits) {\n       this.smoothedAnchor = this.smoothedAnchor * 0.8 + targetAnchor * 0.2;\n       if (Math.abs(this.smoothedAnchor - targetAnchor) < 0.01) this.smoothedAnchor = targetAnchor;\n    } else {\n       this.smoothedAnchor = this.smoothedAnchor * 0.99 + targetAnchor * 0.01;\n    }\n  }\n\n  private getDisplayRange() {\n     return Math.pow(2, Math.ceil(Math.log2(this.smoothedRange)));\n  }\n\n  private getDisplayAnchor() {\n     const r = this.getDisplayRange();\n     return Math.round(this.smoothedAnchor / r) * r;\n  }\n\n  @computed\n  get totalWeight() {\n    return this.config?.segments?.reduce((sum, s) => sum + s.weight, 0) || 1;\n  }\n\n  @computed\n  get segmentLayout() {\n    if (!this.config || !this.config.segments) return [];\n    const width = 220;\n    let currentX = 0;\n    const totalWeight = this.totalWeight;\n\n    return this.config.segments.map((segment, index) => {\n      const segmentWidth = (segment.weight / totalWeight) * width;\n      const layout = {\n        segment,\n        index,\n        startX: currentX,\n        endX: currentX + segmentWidth,\n        width: segmentWidth\n      };\n      currentX += segmentWidth;\n      return layout;\n    });\n  }\n\n  @computed\n  get pathData() {\n    if (!this.config) return '';\n\n    if (this.config.mode === 'scope') {\n        const history = this.history;\n        const width = 220;\n        const height = 96;\n        const historySize = this.config.historySize || 100;\n\n        const range = this.config.autoRange ? this.getDisplayRange() : ((this.config.range?.[1] ?? 1) - (this.config.range?.[0] ?? 0));\n        const anchor = this.config.autoRange ? this.getDisplayAnchor() : (this.config.range?.[0] ?? 0);\n\n        let renderMin: number, renderMax: number;\n        if (this.config.autoRange) {\n            if (this.isSigned) {\n                renderMin = anchor - range / 2;\n                renderMax = anchor + range / 2;\n            } else {\n                renderMin = anchor;\n                renderMax = anchor + range;\n            }\n        } else {\n            renderMin = this.config.range?.[0] ?? 0;\n            renderMax = this.config.range?.[1] ?? 1;\n        }\n\n        const normalizeY = (val: number) => {\n          const normalized = (val - renderMin) / (renderMax - renderMin);\n          return height - (Math.max(0, Math.min(1, normalized)) * height);\n        };\n\n        const points = history.map((val, i) => {\n          const x = (i / (historySize - 1)) * width;\n          const y = normalizeY(val);\n          return `${x},${y}`;\n        });\n\n        return points.length > 0 ? `M ${points.join(' L ')}` : '';\n    }\n\n    // Curve Mode\n    const { domain, range } = this.config;\n    if (!domain || !range) return '';\n\n    const [minY, maxY] = range;\n    const height = 96;\n    const normalize = (val: number, min: number, max: number) => (val - min) / (max - min);\n\n    const points: [number, number][] = [];\n    const stepsPerSegment = 20;\n\n    this.segmentLayout.forEach(layout => {\n      const { segment, startX, endX } = layout;\n\n      // Pre-calculate parameters based on type\n      let exponent = 1;\n      if (segment.curve.type === 'exponential') {\n        exponent = Math.pow(10, -(segment.curve.value ?? 0));\n      }\n\n      const steps = segment.curve.type === 'step' ? (segment.curve.value ?? 2) : 1;\n\n      // For 'points', we just iterate through the provided points\n      if (segment.curve.type === 'points' && segment.curve.points) {\n        segment.curve.points.forEach(p => {\n          const t = p.x; // Normalized x within segment\n          const yVal = minY + p.y * (maxY - minY); // Map normalized y to value range\n\n          const svgX = startX + t * (endX - startX);\n          const svgY = height - (normalize(yVal, minY, maxY) * height);\n          points.push([svgX, svgY]);\n        });\n        return;\n      }\n\n      // For analytical curves\n      for (let i = 0; i <= stepsPerSegment; i++) {\n        const t = i / stepsPerSegment;\n        // x within segment (0 to 1)\n\n        let normY = 0;\n\n        switch (segment.curve.type) {\n          case 'exponential':\n            normY = Math.pow(t, exponent);\n            break;\n          case 'linear':\n            normY = t;\n            break;\n          case 'step':\n            if (steps <= 1) normY = 0;\n            else normY = Math.floor(t * steps) / (steps - 1);\n            if (t >= 0.999) normY = 1;\n            break;\n          case 'sin':\n            normY = -(Math.cos(Math.PI * t) - 1) / 2;\n            break;\n          case 'quad':\n            normY = t * t;\n            break;\n          default:\n            normY = t;\n        }\n\n        const yVal = minY + normY * (maxY - minY);\n        const svgX = startX + t * (endX - startX);\n        const svgY = height - (normalize(yVal, minY, maxY) * height);\n        points.push([svgX, svgY]);\n      }\n    });\n\n    return `M ${points.map(p => p.join(',')).join(' L ')}`;\n  }\n\n  private handlePointerDown(e: PointerEvent) {\n    if (!this.config?.interactive) return;\n\n    const rect = this.getBoundingClientRect();\n    const startX = e.clientX - rect.left;\n    const width = rect.width;\n    const height = rect.height;\n    const layout = this.segmentLayout;\n\n    // Check for resize (near split boundaries)\n    const resizeThreshold = 10;\n    let resizeIndex = -1;\n\n    for (let i = 0; i < layout.length - 1; i++) {\n      const boundaryX = layout[i].endX;\n      if (Math.abs(startX - boundaryX) < resizeThreshold) {\n        resizeIndex = i;\n        break;\n      }\n    }\n\n    if (resizeIndex !== -1 && this.config.onSegmentResize) {\n      // Resize Mode\n      const startSegmentWidth = layout[resizeIndex].width;\n\n      if (this.config.onInteractionStart) this.config.onInteractionStart();\n\n      new PointerDragOp(e, this, {\n        move: (_e, delta) => {\n          const newWidth = startSegmentWidth + delta[0];\n          const pixelToWeightRatio = this.totalWeight / width;\n          const newWeight = newWidth * pixelToWeightRatio;\n\n          if (newWeight > 0 && this.config?.onSegmentResize) {\n            this.config.onSegmentResize(resizeIndex, newWeight);\n          }\n        },\n        complete: () => {\n          if (this.config?.onInteractionEnd) this.config.onInteractionEnd();\n        }\n      });\n      return;\n    }\n\n    // Parameter Change Mode\n    if (this.config.onSegmentChange) {\n      const targetSegment = layout.find(l => startX >= l.startX && startX <= l.endX);\n      if (targetSegment && targetSegment.segment.curve.type === 'exponential') {\n        if (this.config.onInteractionStart) this.config.onInteractionStart();\n\n        new PointerDragOp(e, this, {\n          move: (e, _delta) => {\n            // For parameter, we want absolute position\n            const rect = this.getBoundingClientRect();\n            const y = e.clientY - rect.top;\n\n            // Clamp y\n            const clampedY = Math.max(0, Math.min(height, y));\n\n            // Map Y to value [-1, 1]\n            // y=0 (top) -> 1.0\n            // y=height (bottom) -> -1.0\n            // t = y / height (0 to 1)\n            // value = 1 - 2*t\n\n            const t = clampedY / height;\n            const newValue = 1 - 2 * t;\n\n            if (this.config?.onSegmentChange) {\n              this.config.onSegmentChange(targetSegment.segment.id, 'value', newValue);\n            }\n          },\n          complete: () => {\n            if (this.config?.onInteractionEnd) this.config.onInteractionEnd();\n          }\n        });\n      }\n    }\n  }\n\n  @observable\n  hoveredSegmentIndex = -1;\n\n  @observable\n  hoveredSplitIndex = -1;\n\n  private evaluateCurve(t: number): number {\n    if (!this.config || !this.config.segments) return 0;\n\n    const { range, segments } = this.config;\n    const [minY, maxY] = range || [0, 1];\n\n    // Find segment\n    const totalWeight = this.totalWeight;\n    const targetWeight = t * totalWeight;\n\n    let currentWeight = 0;\n    let matchedSegment = segments[segments.length - 1];\n    let segmentStartWeight = 0;\n\n    for (const segment of segments) {\n        if (targetWeight >= currentWeight && targetWeight <= currentWeight + segment.weight) {\n            matchedSegment = segment;\n            segmentStartWeight = currentWeight;\n            break;\n        }\n        currentWeight += segment.weight;\n    }\n\n    // Local T\n    const segmentWidthWeight = matchedSegment.weight;\n    const localT = (targetWeight - segmentStartWeight) / segmentWidthWeight;\n\n    // Evaluate\n    let normY = 0;\n    const curve = matchedSegment.curve;\n    const steps = curve.type === 'step' ? (curve.value ?? 2) : 1;\n\n    switch (curve.type) {\n      case 'exponential':\n        const exponent = Math.pow(10, -(curve.value ?? 0));\n        normY = Math.pow(localT, exponent);\n        break;\n      case 'linear':\n        normY = localT;\n        break;\n      case 'step':\n        if (steps <= 1) normY = 0;\n        else normY = Math.floor(localT * steps) / (steps - 1);\n        if (localT >= 0.999) normY = 1;\n        break;\n      case 'sin':\n        normY = -(Math.cos(Math.PI * localT) - 1) / 2;\n        break;\n      case 'quad':\n        normY = localT * localT;\n        break;\n      case 'points':\n         if (curve.points && curve.points.length > 0) {\n             const points = curve.points;\n             if (localT <= points[0].x) normY = points[0].y;\n             else if (localT >= points[points.length - 1].x) normY = points[points.length - 1].y;\n             else {\n                 for (let i = 0; i < points.length - 1; i++) {\n                     const p1 = points[i];\n                     const p2 = points[i+1];\n                     if (localT >= p1.x && localT <= p2.x) {\n                         const lt = (localT - p1.x) / (p2.x - p1.x);\n                         normY = p1.y + lt * (p2.y - p1.y);\n                         break;\n                     }\n                 }\n             }\n         } else {\n             normY = localT;\n         }\n         break;\n      default:\n        normY = localT;\n    }\n\n    return minY + normY * (maxY - minY);\n  }\n\n  @action\n  private handlePointerMove(e: PointerEvent) {\n    const rect = this.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const layout = this.segmentLayout;\n\n    // Reset hover\n    this.hoveredSegmentIndex = -1;\n    this.hoveredSplitIndex = -1;\n\n    // Check for resize (near split boundaries)\n    const resizeThreshold = 10;\n    for (let i = 0; i < layout.length - 1; i++) {\n      const boundaryX = layout[i].endX;\n      if (Math.abs(x - boundaryX) < resizeThreshold) {\n        this.hoveredSplitIndex = i;\n        return;\n      }\n    }\n\n    // Check for segment hover\n    const segmentIndex = layout.findIndex(l => x >= l.startX && x <= l.endX);\n    if (segmentIndex !== -1) {\n      this.hoveredSegmentIndex = segmentIndex;\n    }\n  }\n\n  @action\n  private handlePointerLeave() {\n    this.hoveredSegmentIndex = -1;\n    this.hoveredSplitIndex = -1;\n  }\n\n  render() {\n    if (!this.config) return html``;\n\n    const height = 96;\n\n    if (this.config.mode === 'scope') {\n        const range = this.config.autoRange ? this.getDisplayRange() : ((this.config.range?.[1] ?? 1) - (this.config.range?.[0] ?? 0));\n        const anchor = this.config.autoRange ? this.getDisplayAnchor() : (this.config.range?.[0] ?? 0);\n\n        let renderMin: number, renderMax: number;\n        if (this.config.autoRange) {\n            if (this.isSigned) {\n                renderMin = anchor - range / 2;\n                renderMax = anchor + range / 2;\n            } else {\n                renderMin = anchor;\n                renderMax = anchor + range;\n            }\n        } else {\n            renderMin = this.config.range?.[0] ?? 0;\n            renderMax = this.config.range?.[1] ?? 1;\n        }\n\n        const normalizeY = (val: number) => {\n          const normalized = (val - renderMin) / (renderMax - renderMin);\n          return height - (Math.max(0, Math.min(1, normalized)) * height);\n        };\n\n        const zeroY = normalizeY(0);\n\n        // Grid Lines\n        const gridLines = [];\n        if (this.config.showGrid) {\n            const maxAbs = Math.max(Math.abs(renderMin), Math.abs(renderMax));\n            const maxPow = Math.ceil(Math.log2(maxAbs));\n            const minPow = Math.floor(Math.log2(range)) - 4;\n\n            for (let p = minPow; p <= maxPow; p++) {\n              const val = Math.pow(2, p);\n              if (val <= renderMax && val >= renderMin) gridLines.push(normalizeY(val));\n              if (-val <= renderMax && -val >= renderMin) gridLines.push(normalizeY(-val));\n            }\n        }\n\n        return html`\n          <svg viewBox=\"0 0 220 96\" preserveAspectRatio=\"none\">\n                <defs>\n                    <pattern id=\"grid-x\" width=\"24\" height=\"96\" patternUnits=\"userSpaceOnUse\">\n                        <path d=\"M 0 0 L 0 96\" fill=\"none\" class=\"grid-pattern\" />\n                    </pattern>\n                    <pattern id=\"hash-pattern\" width=\"8\" height=\"8\" patternUnits=\"userSpaceOnUse\" patternTransform=\"rotate(45)\">\n                        <line x1=\"0\" y1=\"0\" x2=\"0\" y2=\"8\" stroke=\"var(--accent-color)\" stroke-width=\"4\" opacity=\"0.1\" />\n                    </pattern>\n                    ${this.config?.cursor !== undefined ? svg`\n                        <clipPath id=\"clip-left\">\n                            <rect x=\"0\" y=\"0\" width=\"${this.config.cursor * 220}\" height=\"96\" />\n                        </clipPath>\n                        <clipPath id=\"clip-right\">\n                            <rect x=\"${this.config.cursor * 220}\" y=\"0\" width=\"${220 - (this.config.cursor * 220)}\" height=\"96\" />\n                        </clipPath>\n                    ` : ''}\n                </defs>\n                <rect width=\"100%\" height=\"100%\" fill=\"url(#grid-x)\" />\n                ${gridLines.map(y => svg`<line class=\"grid\" x1=\"0\" y1=\"${y}\" x2=\"220\" y2=\"${y}\" />`)}\n                <line class=\"zero-line\" x1=\"0\" y1=\"${zeroY}\" x2=\"220\" y2=\"${zeroY}\" />\n\n                <!-- Curve Fills -->\n                ${this.config?.cursor !== undefined ? svg`\n                    <!-- Left (Solid) -->\n                    <path d=\"${this.pathData} L 220 ${height} L 0 ${height} Z\"\n                          fill=\"var(--accent-color)\" fill-opacity=\"0.2\"\n                          clip-path=\"url(#clip-left)\" />\n\n                    <!-- Right (Hashed) -->\n                    <path d=\"${this.pathData} L 220 ${height} L 0 ${height} Z\"\n                          fill=\"url(#hash-pattern)\"\n                          clip-path=\"url(#clip-right)\" />\n                ` : svg`\n                    <!-- Default Fill if no cursor -->\n                    <path d=\"${this.pathData} L 220 ${height} L 0 ${height} Z\"\n                          fill=\"var(--accent-color)\" fill-opacity=\"0.1\" />\n                `}\n\n                <!-- Curve Stroke -->\n                <path class=\"curve\" d=\"${this.pathData}\" fill=\"none\" stroke=\"#00ff88\" stroke-width=\"2\" vector-effect=\"non-scaling-stroke\" />\n\n                <!-- Parameter Handles -->\n                ${this.config?.segments?.map((segment, i) => {\n                    if (!this.config?.interactive) return '';\n\n                    const l = this.segmentLayout[i];\n                    if (!l) return '';\n\n                    const { startX, endX } = l;\n\n                    // Only calculate handle for exponential curves\n                    let handleY = 0;\n                    let showHandle = false;\n\n                    if (segment.curve.type === 'exponential') {\n                        // Map segment.curve.value [-1, 1] to SVG Y coordinate [0, height]\n                        // value = 1 - 2*t\n                        // 2*t = 1 - value\n                        // t = (1 - value) / 2\n                        const t = (1 - (segment.curve.value ?? 0)) / 2;\n                        handleY = t * height;\n                        showHandle = true;\n                    }\n\n                    return showHandle ? svg`\n                        <g class=\"parameter-control\">\n                            <!-- Vertical Sheer Bar -->\n                            <rect class=\"parameter-bg\" x=\"${startX}\" y=\"0\" width=\"${endX - startX}\" height=\"${height}\" />\n\n                            <!-- Horizontal Solid Line -->\n                            <line class=\"parameter-line\" x1=\"${startX}\" y1=\"${handleY}\" x2=\"${endX}\" y2=\"${handleY}\" />\n\n                            <!-- Handle Circle -->\n                            <circle class=\"parameter-handle\" cx=\"${startX + (endX - startX) / 2}\" cy=\"${handleY}\" r=\"4\" />\n                        </g>\n                    ` : '';\n                })}\n          </svg>\n        `;\n    }\n\n    const layout = this.segmentLayout;\n    const resizeThreshold = 10;\n\n    return html`\n            <svg viewBox=\"0 0 220 96\" preserveAspectRatio=\"none\"\n                @pointerdown=${(e: PointerEvent) => this.handlePointerDown(e)}\n                @pointermove=${(e: PointerEvent) => this.handlePointerMove(e)}\n                @pointerleave=${() => this.handlePointerLeave()}\n            >\n                <defs>\n                    <pattern id=\"grid\" width=\"24\" height=\"24\" patternUnits=\"userSpaceOnUse\">\n                        <path d=\"M 24 0 L 0 0 0 24\" fill=\"none\" class=\"grid-pattern\" />\n                    </pattern>\n                    <pattern id=\"hash-pattern\" width=\"8\" height=\"8\" patternUnits=\"userSpaceOnUse\" patternTransform=\"rotate(45)\">\n                        <line x1=\"0\" y1=\"0\" x2=\"0\" y2=\"8\" stroke=\"var(--accent-color)\" stroke-width=\"4\" opacity=\"0.1\" />\n                    </pattern>\n                    ${this.config?.cursor !== undefined ? svg`\n                        <clipPath id=\"clip-left\">\n                            <rect x=\"0\" y=\"0\" width=\"${this.config.cursor * 220}\" height=\"96\" />\n                        </clipPath>\n                        <clipPath id=\"clip-right\">\n                            <rect x=\"${this.config.cursor * 220}\" y=\"0\" width=\"${220 - (this.config.cursor * 220)}\" height=\"96\" />\n                        </clipPath>\n                    ` : ''}\n                    <linearGradient id=\"curveGradient\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"1\">\n                        <stop offset=\"0%\" stop-color=\"var(--accent-color)\" stop-opacity=\"0.2\" />\n                        <stop offset=\"100%\" stop-color=\"var(--accent-color)\" stop-opacity=\"0.0\" />\n                    </linearGradient>\n                </defs>\n\n                <rect width=\"100%\" height=\"100%\" fill=\"url(#grid)\" />\n\n                <!-- Axis Lines -->\n                <line class=\"axis-line\" x1=\"0\" y1=\"${height / 2}\" x2=\"220\" y2=\"${height / 2}\" />\n\n                <!-- Segments -->\n                ${layout.map(l => {\n      const { segment, startX, endX } = l;\n      const isHovered = l.index === this.hoveredSegmentIndex;\n      const isSplitHovered = l.index === this.hoveredSplitIndex;\n\n      // Only calculate handle for exponential curves\n      let handleY = 0;\n      let centerX = 0;\n      let showHandle = false;\n\n      if (segment.curve.type === 'exponential') {\n        const tHandle = (1 - (segment.curve.value ?? 0)) / 2;\n        handleY = tHandle * height;\n        centerX = startX + (endX - startX) / 2;\n        showHandle = true;\n      }\n\n      return svg`\n                        <!-- Hover Highlight -->\n                        ${isHovered && this.config?.interactive ? svg`\n                            <rect x=\"${startX}\" y=\"0\" width=\"${endX - startX}\" height=\"${height}\"\n                                fill=\"var(--accent-color)\" fill-opacity=\"0.05\" pointer-events=\"none\" />\n                        ` : ''}\n\n                        <!-- Segment Separator (if not last) -->\n                        ${l.index < layout.length - 1 ? svg`\n                            <line class=\"split-handle\" x1=\"${endX}\" y1=\"0\" x2=\"${endX}\" y2=\"${height}\"\n                                style=\"${isSplitHovered ? 'opacity: 1; stroke-width: 2; stroke: var(--accent-color);' : ''}\" />\n                            <!-- Visual target matches resizeThreshold * 2 -->\n                            <rect class=\"split-handle-target\" x=\"${endX - resizeThreshold}\" y=\"0\" width=\"${resizeThreshold * 2}\" height=\"${height}\" />\n                        ` : ''}\n\n                        <!-- Parameter Handle -->\n                        ${this.config?.interactive && showHandle ? svg`\n                            <g class=\"parameter-control\">\n                                <!-- Vertical Sheer Bar (Fill from bottom) -->\n                                <rect class=\"parameter-bg\" x=\"${startX}\" y=\"${handleY}\" width=\"${endX - startX}\" height=\"${height - handleY}\" />\n\n                                <!-- Horizontal Solid Line -->\n                                <line class=\"parameter-line\" x1=\"${startX}\" y1=\"${handleY}\" x2=\"${endX}\" y2=\"${handleY}\" />\n                            </g>\n                        ` : ''}\n                    `;\n    })}\n\n                <!-- Curve Fills -->\n                ${this.config?.cursor !== undefined ? svg`\n                    <!-- Left (Solid) -->\n                    <path d=\"${this.pathData} L 220 ${height} L 0 ${height} Z\"\n                          fill=\"var(--accent-color)\" fill-opacity=\"0.2\"\n                          clip-path=\"url(#clip-left)\" />\n\n                    <!-- Right (Hashed) -->\n                    <path d=\"${this.pathData} L 220 ${height} L 0 ${height} Z\"\n                          fill=\"url(#hash-pattern)\"\n                          clip-path=\"url(#clip-right)\" />\n                ` : svg`\n                    <!-- Default Fill if no cursor -->\n                    <path d=\"${this.pathData} L 220 ${height} L 0 ${height} Z\"\n                          fill=\"var(--accent-color)\" fill-opacity=\"0.1\" />\n                `}\n\n                <!-- Curve Stroke -->\n                <path class=\"curve\" d=\"${this.pathData}\" fill=\"none\" />\n\n                <!-- Cursor -->\n                ${this.config?.cursor !== undefined ? (() => {\n                    const cursorX = this.config.cursor * 220;\n                    const valY = this.evaluateCurve(this.config.cursor);\n\n                    // Normalize Y for SVG (0 at bottom? No, 0 at top in SVG usually, but we inverted it?)\n                    // In pathData: svgY = height - (normalize(yVal) * height)\n                    const [minY, maxY] = this.config.range || [0, 1];\n                    const normalizedY = (valY - minY) / (maxY - minY);\n                    const cursorY = height - (Math.max(0, Math.min(1, normalizedY)) * height);\n\n                    return svg`\n                        <!-- Vertical Line -->\n                        <line class=\"cursor-line\"\n                            x1=\"${cursorX}\" y1=\"0\"\n                            x2=\"${cursorX}\" y2=\"${height}\"\n                            stroke=\"var(--accent-color)\" stroke-width=\"1\" stroke-dasharray=\"4 4\" opacity=\"0.5\"\n                            style=\"pointer-events: none;\"\n                        />\n                        <!-- Intersection Point -->\n                        <circle cx=\"${cursorX}\" cy=\"${cursorY}\" r=\"3\" fill=\"var(--accent-color)\" stroke=\"var(--node-bg)\" stroke-width=\"1\" style=\"pointer-events: none;\" />\n                    `;\n                })() : ''}\n            </svg>\n        `;\n  }\n}\n","import './nodes';\nimport { html } from 'lit';\nimport '../../views/graph-widget';\nimport { GraphWidgetConfig } from '../../views/graph-widget';\n\nimport { appController, runtimeManager } from '../../builder/controllers';\nimport { toJS } from 'mobx';\n\nimport { customElement, property } from 'lit/decorators.js';\nimport { MobxLitElement } from '../../views/mobx-lit-element';\nimport { GridNode } from '../../builder/state';\nimport { GraphNodeRenderHandlers, InspectorChangeHandler, defaultNodeRepository } from '../../structor/repository';\n\n@customElement('curve-inspector')\nexport class CurveInspector extends MobxLitElement {\n  @property({ attribute: false })\n  node!: GridNode;\n\n  private longEdit: any = null;\n\n  render() {\n    if (!this.node) return html``;\n\n    const nodeType = defaultNodeRepository.getNodeType(this.node.config.typeId);\n    let defaultEasing = {\n      domain: [0, 1],\n      range: [0, 1],\n      segments: [{\n        id: 's1',\n        weight: 1,\n        curve: { type: 'exponential', value: 0 }\n      }]\n    };\n\n    if (nodeType && nodeType.inputs) {\n      const easingInput = nodeType.inputs.find(i => i.name === 'easing');\n      if (easingInput && easingInput.defaultValue) {\n        defaultEasing = easingInput.defaultValue;\n      }\n    }\n\n    const easingConfig = (this.node.config.values?.easing as any as GraphWidgetConfig | undefined) ?? defaultEasing;\n\n    const widgetConfig: GraphWidgetConfig = {\n      domain: easingConfig.domain as any,\n      range: easingConfig.range as any,\n      segments: easingConfig.segments as any,\n      interactive: true,\n      onInteractionStart: () => {\n        this.longEdit = appController.beginLongEdit({\n          apply: () => { },\n          cancel: () => { this.longEdit = null; }\n        });\n      },\n      onInteractionEnd: () => {\n        if (this.longEdit) {\n          this.longEdit.accept();\n          this.longEdit = null;\n        }\n      },\n      onSegmentChange: (segmentId, param, value) => {\n        const update = (c: any) => {\n          const innerEasingConfig = toJS(easingConfig);\n          const nodeConfig = toJS(this.node.config);\n          const newSegments = (innerEasingConfig.segments || []).map((s: any) => {\n            if (s.id === segmentId) {\n              if (param === 'value') {\n                return { ...s, curve: { ...s.curve, value: value } };\n              }\n            }\n            return s;\n          });\n          c.setNodeConfig(this.node.id, { values: { ...nodeConfig.values, easing: { ...innerEasingConfig, segments: newSegments } as any } });\n        };\n\n        if (this.longEdit) {\n          this.longEdit.applyAgain(update);\n        } else {\n          update(appController);\n        }\n      },\n      onSegmentResize: (segmentIndex, newWeight) => {\n        const update = (c: any) => {\n          const innerEasingConfig = toJS(easingConfig);\n          const nodeConfig = toJS(this.node.config);\n          const newSegments = [...(innerEasingConfig.segments || [])];\n          if (newSegments[segmentIndex]) {\n            newSegments[segmentIndex] = { ...newSegments[segmentIndex], weight: newWeight };\n            c.setNodeConfig(this.node.id, { values: { ...nodeConfig.values, easing: { ...innerEasingConfig, segments: newSegments } as any } });\n          }\n        };\n\n        if (this.longEdit) {\n          this.longEdit.applyAgain(update);\n        } else {\n          update(appController);\n        }\n      }\n    };\n\n    // Get input value for cursor\n    const inputs = runtimeManager.inputs.get(this.node.id);\n    let cursorValue: number | undefined = undefined;\n    if (inputs) {\n        if (inputs.fields && inputs.fields['value'] !== undefined) {\n            cursorValue = inputs.fields['value'];\n        } else if (inputs.untagged && inputs.untagged.length > 0) {\n            cursorValue = inputs.untagged[0];\n        }\n    }\n\n    // Normalize cursor if domain is not 0-1\n    if (cursorValue !== undefined) {\n        const [minIn, maxIn] = widgetConfig.domain || [0, 1];\n        cursorValue = (cursorValue - minIn) / (maxIn - minIn);\n        cursorValue = Math.max(0, Math.min(1, cursorValue));\n    }\n\n    widgetConfig.cursor = cursorValue;\n\n    return html`\n      <graph-widget style=\"pointer-events: auto;\" .config=${widgetConfig}></graph-widget>\n    `;\n  }\n}\n\nexport const CurveBodyRenderer = (node: GridNode, handlers: GraphNodeRenderHandlers) => {\n  return html`<curve-inspector .node=${node}></curve-inspector>`;\n};\n\nexport const CurveInspectorRenderer = (node: GridNode, onchange: InspectorChangeHandler) => {\n  // We can reuse the same component or a different one for inspector\n  return html`<div>Curve Inspector Placeholder</div>`;\n};\n\nexport const CurveBodyHeight = (node: GridNode) => 100;\n"],"names":["GraphWidget","MobxLitElement","makeObservable","changedProperties","maxSize","history","minV","maxV","hasNegative","v","padding","targetRange","targetAnchor","signalCenter","signalSpan","requiredSpan","quantizedRange","anchorStep","quantizedAnchor","viewMin","viewMax","span","qRange","qAnchor","currentDisplayAnchor","currentDisplayRange","fits","safeMin","safeMax","r","sum","s","width","currentX","totalWeight","segment","index","segmentWidth","layout","height","historySize","range","anchor","renderMin","renderMax","normalizeY","val","normalized","points","i","x","y","domain","minY","maxY","normalize","min","max","stepsPerSegment","startX","endX","exponent","steps","p","t","yVal","svgX","svgY","normY","rect","resizeThreshold","resizeIndex","boundaryX","startSegmentWidth","PointerDragOp","_e","delta","newWidth","pixelToWeightRatio","newWeight","targetSegment","e","_delta","newValue","segments","targetWeight","currentWeight","matchedSegment","segmentStartWeight","segmentWidthWeight","localT","curve","p1","p2","lt","segmentIndex","l","html","zeroY","gridLines","maxAbs","maxPow","minPow","svg","handleY","showHandle","isHovered","isSplitHovered","cursorX","valY","normalizedY","cursorY","widgetStyles","css","__decorateClass","property","computed","observable","action","customElement","CurveInspector","nodeType","defaultNodeRepository","defaultEasing","easingInput","easingConfig","widgetConfig","appController","segmentId","param","value","update","innerEasingConfig","toJS","nodeConfig","newSegments","c","inputs","runtimeManager","cursorValue","minIn","maxIn","CurveBodyRenderer","node","handlers","CurveInspectorRenderer","onchange","CurveBodyHeight"],"mappings":"iVAwCO,IAAMA,EAAN,cAA0BC,CAAe,CAsE9C,aAAc,CACZ,MAAA,EA/DF,KAAA,KAAO,EAGP,KAAQ,QAAoB,CAAA,EAC5B,KAAQ,cAAgB,EACxB,KAAQ,eAAiB,EACzB,KAAQ,SAAW,GAuYnB,KAAA,oBAAsB,GAGtB,KAAA,kBAAoB,GAhVlBC,EAAe,IAAI,CACrB,CAEA,QAAQC,EAAqC,CAC3C,IAAKA,EAAkB,IAAI,OAAO,GAAKA,EAAkB,IAAI,MAAM,IAAM,KAAK,QAAU,OAAW,CACjG,KAAK,QAAQ,KAAK,KAAK,KAAK,EAC5B,MAAMC,EAAU,KAAK,QAAQ,aAAe,IACxC,KAAK,QAAQ,OAASA,GAAS,KAAK,QAAQ,MAAA,EAE5C,KAAK,QAAQ,OAAS,SAAW,KAAK,OAAO,WAC/C,KAAK,oBAAA,EAGP,KAAK,cAAA,CACP,CACF,CAEQ,qBAAsB,CAC5B,GAAI,KAAK,QAAQ,SAAW,EAAG,OAE/B,MAAMC,EAAU,KAAK,QACrB,IAAIC,EAAOD,EAAQ,CAAC,EAChBE,EAAOF,EAAQ,CAAC,EAChBG,EAAc,GAElB,UAAWC,KAAKJ,EACVI,EAAIH,IAAMA,EAAOG,GACjBA,EAAIF,IAAMA,EAAOE,GACjBA,EAAI,IAAGD,EAAc,IAIvBA,SAAkB,SAAW,IAGjC,MAAME,EAAU,IAChB,IAAIC,EAAc,EACdC,EAAe,EAEnB,GAAI,KAAK,SAAU,CACjB,MAAMC,GAAgBP,EAAOC,GAAQ,EAC/BO,EAAaP,EAAOD,EACpBS,EAAe,KAAK,IAAID,EAAaJ,EAAS,IAAK,EACnDM,EAAiB,KAAK,IAAI,EAAG,KAAK,KAAK,KAAK,KAAKD,CAAY,CAAC,CAAC,EAC/DE,EAAaD,EACbE,EAAkB,KAAK,MAAML,EAAeI,CAAU,EAAIA,EAEhEN,EAAcK,EACdJ,EAAeM,EAEf,MAAMC,EAAUP,EAAeD,EAAc,EACvCS,EAAUR,EAAeD,EAAc,GAEzCL,EAAOa,GAAWZ,EAAOa,KAC1BT,GAAe,EAEpB,KAAO,CACL,MAAMU,EAAO,KAAK,IAAId,EAAOD,EAAM,IAAK,EACxC,IAAIgB,EAAS,KAAK,IAAI,EAAG,KAAK,KAAK,KAAK,KAAKD,EAAOX,CAAO,CAAC,CAAC,EACzDa,EAAU,KAAK,MAAMjB,EAAOgB,CAAM,EAAIA,EAEtCC,EAAUD,EAASf,IACrBe,GAAU,EACVC,EAAU,KAAK,MAAMjB,EAAOgB,CAAM,EAAIA,GAGxCX,EAAcW,EACdV,EAAeW,CACjB,CAGIZ,EAAc,KAAK,cACrB,KAAK,cAAgBA,GAErB,KAAK,cAAgB,KAAK,cAAgB,IAAOA,EAAc,IAC3D,KAAK,IAAI,KAAK,cAAgBA,CAAW,EAAI,WAAW,cAAgBA,IAI9E,MAAMa,EAAuB,KAAK,iBAAA,EAC5BC,EAAsB,KAAK,gBAAA,EAEjC,IAAIC,EAAO,GACX,GAAI,KAAK,SAAU,CAEhB,MAAMC,EAAUH,EAAwBC,EAAsB,GAAY,EACpEG,EAAUJ,EAAwBC,EAAsB,GAAY,EACtEnB,GAAQqB,GAAWpB,GAAQqB,IAASF,EAAO,GAClD,KAAO,CACJ,MAAMC,EAAUH,EACVI,EAAUJ,EAAuBC,EAAsB,GACzDnB,GAAQqB,GAAWpB,GAAQqB,IAASF,EAAO,GAClD,CAEKA,EAIF,KAAK,eAAiB,KAAK,eAAiB,IAAOd,EAAe,KAHlE,KAAK,eAAiB,KAAK,eAAiB,GAAMA,EAAe,GAC7D,KAAK,IAAI,KAAK,eAAiBA,CAAY,EAAI,WAAW,eAAiBA,GAIpF,CAEQ,iBAAkB,CACvB,OAAO,KAAK,IAAI,EAAG,KAAK,KAAK,KAAK,KAAK,KAAK,aAAa,CAAC,CAAC,CAC9D,CAEQ,kBAAmB,CACxB,MAAMiB,EAAI,KAAK,gBAAA,EACf,OAAO,KAAK,MAAM,KAAK,eAAiBA,CAAC,EAAIA,CAChD,CAGA,IAAI,aAAc,CAChB,OAAO,KAAK,QAAQ,UAAU,OAAO,CAACC,EAAKC,IAAMD,EAAMC,EAAE,OAAQ,CAAC,GAAK,CACzE,CAGA,IAAI,eAAgB,CAClB,GAAI,CAAC,KAAK,QAAU,CAAC,KAAK,OAAO,eAAiB,CAAA,EAClD,MAAMC,EAAQ,IACd,IAAIC,EAAW,EACf,MAAMC,EAAc,KAAK,YAEzB,OAAO,KAAK,OAAO,SAAS,IAAI,CAACC,EAASC,IAAU,CAClD,MAAMC,EAAgBF,EAAQ,OAASD,EAAeF,EAChDM,EAAS,CACb,QAAAH,EACA,MAAAC,EACA,OAAQH,EACR,KAAMA,EAAWI,EACjB,MAAOA,CAAA,EAET,OAAAJ,GAAYI,EACLC,CACT,CAAC,CACH,CAGA,IAAI,UAAW,CACb,GAAI,CAAC,KAAK,OAAQ,MAAO,GAEzB,GAAI,KAAK,OAAO,OAAS,QAAS,CAC9B,MAAMjC,EAAU,KAAK,QACf2B,EAAQ,IACRO,EAAS,GACTC,EAAc,KAAK,OAAO,aAAe,IAEzCC,EAAQ,KAAK,OAAO,UAAY,KAAK,mBAAsB,KAAK,OAAO,QAAQ,CAAC,GAAK,IAAM,KAAK,OAAO,QAAQ,CAAC,GAAK,GACrHC,EAAS,KAAK,OAAO,UAAY,KAAK,iBAAA,EAAsB,KAAK,OAAO,QAAQ,CAAC,GAAK,EAE5F,IAAIC,EAAmBC,EACnB,KAAK,OAAO,UACR,KAAK,UACLD,EAAYD,EAASD,EAAQ,EAC7BG,EAAYF,EAASD,EAAQ,IAE7BE,EAAYD,EACZE,EAAYF,EAASD,IAGzBE,EAAY,KAAK,OAAO,QAAQ,CAAC,GAAK,EACtCC,EAAY,KAAK,OAAO,QAAQ,CAAC,GAAK,GAG1C,MAAMC,EAAcC,GAAgB,CAClC,MAAMC,GAAcD,EAAMH,IAAcC,EAAYD,GACpD,OAAOJ,EAAU,KAAK,IAAI,EAAG,KAAK,IAAI,EAAGQ,CAAU,CAAC,EAAIR,CAC1D,EAEMS,EAAS3C,EAAQ,IAAI,CAACyC,EAAKG,IAAM,CACrC,MAAMC,EAAKD,GAAKT,EAAc,GAAMR,EAC9BmB,EAAIN,EAAWC,CAAG,EACxB,MAAO,GAAGI,CAAC,IAAIC,CAAC,EAClB,CAAC,EAED,OAAOH,EAAO,OAAS,EAAI,KAAKA,EAAO,KAAK,KAAK,CAAC,GAAK,EAC3D,CAGA,KAAM,CAAE,OAAAI,EAAQ,MAAAX,CAAA,EAAU,KAAK,OAC/B,GAAI,CAACW,GAAU,CAACX,EAAO,MAAO,GAE9B,KAAM,CAACY,EAAMC,CAAI,EAAIb,EACfF,EAAS,GACTgB,EAAY,CAACT,EAAaU,EAAaC,KAAiBX,EAAMU,IAAQC,EAAMD,GAE5ER,EAA6B,CAAA,EAC7BU,EAAkB,GAExB,YAAK,cAAc,QAAQpB,GAAU,CACnC,KAAM,CAAE,QAAAH,EAAS,OAAAwB,EAAQ,KAAAC,CAAA,EAAStB,EAGlC,IAAIuB,EAAW,EACX1B,EAAQ,MAAM,OAAS,gBACzB0B,EAAW,KAAK,IAAI,GAAI,EAAE1B,EAAQ,MAAM,OAAS,EAAE,GAGrD,MAAM2B,EAAQ3B,EAAQ,MAAM,OAAS,OAAUA,EAAQ,MAAM,OAAS,EAAK,EAG3E,GAAIA,EAAQ,MAAM,OAAS,UAAYA,EAAQ,MAAM,OAAQ,CAC3DA,EAAQ,MAAM,OAAO,QAAQ4B,GAAK,CAChC,MAAMC,EAAID,EAAE,EACNE,EAAOZ,EAAOU,EAAE,GAAKT,EAAOD,GAE5Ba,EAAOP,EAASK,GAAKJ,EAAOD,GAC5BQ,EAAO5B,EAAUgB,EAAUU,EAAMZ,EAAMC,CAAI,EAAIf,EACrDS,EAAO,KAAK,CAACkB,EAAMC,CAAI,CAAC,CAC1B,CAAC,EACD,MACF,CAGA,QAASlB,EAAI,EAAGA,GAAKS,EAAiBT,IAAK,CACzC,MAAMe,EAAIf,EAAIS,EAGd,IAAIU,EAAQ,EAEZ,OAAQjC,EAAQ,MAAM,KAAA,CACpB,IAAK,cACHiC,EAAQ,KAAK,IAAIJ,EAAGH,CAAQ,EAC5B,MACF,IAAK,SACHO,EAAQJ,EACR,MACF,IAAK,OACCF,GAAS,EAAGM,EAAQ,IACX,KAAK,MAAMJ,EAAIF,CAAK,GAAKA,EAAQ,GAC1CE,GAAK,OAAOI,EAAQ,GACxB,MACF,IAAK,MACHA,EAAQ,EAAE,KAAK,IAAI,KAAK,GAAKJ,CAAC,EAAI,GAAK,EACvC,MACF,IAAK,OACHI,EAAQJ,EAAIA,EACZ,MACF,QACEI,EAAQJ,CAAA,CAGZ,MAAMC,EAAOZ,EAAOe,GAASd,EAAOD,GAC9Ba,EAAOP,EAASK,GAAKJ,EAAOD,GAC5BQ,EAAO5B,EAAUgB,EAAUU,EAAMZ,EAAMC,CAAI,EAAIf,EACrDS,EAAO,KAAK,CAACkB,EAAMC,CAAI,CAAC,CAC1B,CACF,CAAC,EAEM,KAAKnB,EAAO,IAAIe,GAAKA,EAAE,KAAK,GAAG,CAAC,EAAE,KAAK,KAAK,CAAC,EACtD,CAEQ,kBAAkB,EAAiB,CACzC,GAAI,CAAC,KAAK,QAAQ,YAAa,OAE/B,MAAMM,EAAO,KAAK,sBAAA,EACZV,EAAS,EAAE,QAAUU,EAAK,KAC1BrC,EAAQqC,EAAK,MACb9B,EAAS8B,EAAK,OACd/B,EAAS,KAAK,cAGdgC,EAAkB,GACxB,IAAIC,EAAc,GAElB,QAAStB,EAAI,EAAGA,EAAIX,EAAO,OAAS,EAAGW,IAAK,CAC1C,MAAMuB,EAAYlC,EAAOW,CAAC,EAAE,KAC5B,GAAI,KAAK,IAAIU,EAASa,CAAS,EAAIF,EAAiB,CAClDC,EAActB,EACd,KACF,CACF,CAEA,GAAIsB,IAAgB,IAAM,KAAK,OAAO,gBAAiB,CAErD,MAAME,EAAoBnC,EAAOiC,CAAW,EAAE,MAE1C,KAAK,OAAO,oBAAoB,KAAK,OAAO,mBAAA,EAEhD,IAAIG,EAAc,EAAG,KAAM,CACzB,KAAM,CAACC,EAAIC,IAAU,CACnB,MAAMC,EAAWJ,EAAoBG,EAAM,CAAC,EACtCE,EAAqB,KAAK,YAAc9C,EACxC+C,EAAYF,EAAWC,EAEzBC,EAAY,GAAK,KAAK,QAAQ,iBAChC,KAAK,OAAO,gBAAgBR,EAAaQ,CAAS,CAEtD,EACA,SAAU,IAAM,CACV,KAAK,QAAQ,kBAAkB,KAAK,OAAO,iBAAA,CACjD,CAAA,CACD,EACD,MACF,CAGA,GAAI,KAAK,OAAO,gBAAiB,CAC/B,MAAMC,EAAgB1C,EAAO,KAAK,GAAKqB,GAAU,EAAE,QAAUA,GAAU,EAAE,IAAI,EACzEqB,GAAiBA,EAAc,QAAQ,MAAM,OAAS,gBACpD,KAAK,OAAO,oBAAoB,KAAK,OAAO,mBAAA,EAEhD,IAAIN,EAAc,EAAG,KAAM,CACzB,KAAM,CAACO,EAAGC,IAAW,CAEnB,MAAMb,EAAO,KAAK,sBAAA,EACZlB,EAAI8B,EAAE,QAAUZ,EAAK,IAYrBc,EAAW,EAAI,GATJ,KAAK,IAAI,EAAG,KAAK,IAAI5C,EAAQY,CAAC,CAAC,EAQ3BZ,GAGjB,KAAK,QAAQ,iBACf,KAAK,OAAO,gBAAgByC,EAAc,QAAQ,GAAI,QAASG,CAAQ,CAE3E,EACA,SAAU,IAAM,CACV,KAAK,QAAQ,kBAAkB,KAAK,OAAO,iBAAA,CACjD,CAAA,CACD,EAEL,CACF,CAQQ,cAAcnB,EAAmB,CACvC,GAAI,CAAC,KAAK,QAAU,CAAC,KAAK,OAAO,SAAU,MAAO,GAElD,KAAM,CAAE,MAAAvB,EAAO,SAAA2C,CAAA,EAAa,KAAK,OAC3B,CAAC/B,EAAMC,CAAI,EAAIb,GAAS,CAAC,EAAG,CAAC,EAG7BP,EAAc,KAAK,YACnBmD,EAAerB,EAAI9B,EAEzB,IAAIoD,EAAgB,EAChBC,EAAiBH,EAASA,EAAS,OAAS,CAAC,EAC7CI,EAAqB,EAEzB,UAAWrD,KAAWiD,EAAU,CAC5B,GAAIC,GAAgBC,GAAiBD,GAAgBC,EAAgBnD,EAAQ,OAAQ,CACjFoD,EAAiBpD,EACjBqD,EAAqBF,EACrB,KACJ,CACAA,GAAiBnD,EAAQ,MAC7B,CAGA,MAAMsD,EAAqBF,EAAe,OACpCG,GAAUL,EAAeG,GAAsBC,EAGrD,IAAIrB,EAAQ,EACZ,MAAMuB,EAAQJ,EAAe,MACvBzB,EAAQ6B,EAAM,OAAS,OAAUA,EAAM,OAAS,EAAK,EAE3D,OAAQA,EAAM,KAAA,CACZ,IAAK,cACH,MAAM9B,EAAW,KAAK,IAAI,GAAI,EAAE8B,EAAM,OAAS,EAAE,EACjDvB,EAAQ,KAAK,IAAIsB,EAAQ7B,CAAQ,EACjC,MACF,IAAK,SACHO,EAAQsB,EACR,MACF,IAAK,OACC5B,GAAS,EAAGM,EAAQ,IACX,KAAK,MAAMsB,EAAS5B,CAAK,GAAKA,EAAQ,GAC/C4B,GAAU,OAAOtB,EAAQ,GAC7B,MACF,IAAK,MACHA,EAAQ,EAAE,KAAK,IAAI,KAAK,GAAKsB,CAAM,EAAI,GAAK,EAC5C,MACF,IAAK,OACHtB,EAAQsB,EAASA,EACjB,MACF,IAAK,SACF,GAAIC,EAAM,QAAUA,EAAM,OAAO,OAAS,EAAG,CACzC,MAAM3C,EAAS2C,EAAM,OACrB,GAAID,GAAU1C,EAAO,CAAC,EAAE,EAAGoB,EAAQpB,EAAO,CAAC,EAAE,UACpC0C,GAAU1C,EAAOA,EAAO,OAAS,CAAC,EAAE,EAAGoB,EAAQpB,EAAOA,EAAO,OAAS,CAAC,EAAE,MAE9E,SAASC,EAAI,EAAGA,EAAID,EAAO,OAAS,EAAGC,IAAK,CACxC,MAAM2C,EAAK5C,EAAOC,CAAC,EACb4C,EAAK7C,EAAOC,EAAE,CAAC,EACrB,GAAIyC,GAAUE,EAAG,GAAKF,GAAUG,EAAG,EAAG,CAClC,MAAMC,GAAMJ,EAASE,EAAG,IAAMC,EAAG,EAAID,EAAG,GACxCxB,EAAQwB,EAAG,EAAIE,GAAMD,EAAG,EAAID,EAAG,GAC/B,KACJ,CACJ,CAER,MACIxB,EAAQsB,EAEZ,MACH,QACEtB,EAAQsB,CAAA,CAGZ,OAAOrC,EAAOe,GAASd,EAAOD,EAChC,CAGQ,kBAAkB,EAAiB,CACzC,MAAMgB,EAAO,KAAK,sBAAA,EACZnB,EAAI,EAAE,QAAUmB,EAAK,KACrB/B,EAAS,KAAK,cAGpB,KAAK,oBAAsB,GAC3B,KAAK,kBAAoB,GAGzB,MAAMgC,EAAkB,GACxB,QAASrB,EAAI,EAAGA,EAAIX,EAAO,OAAS,EAAGW,IAAK,CAC1C,MAAMuB,EAAYlC,EAAOW,CAAC,EAAE,KAC5B,GAAI,KAAK,IAAIC,EAAIsB,CAAS,EAAIF,EAAiB,CAC7C,KAAK,kBAAoBrB,EACzB,MACF,CACF,CAGA,MAAM8C,EAAezD,EAAO,UAAU0D,GAAK9C,GAAK8C,EAAE,QAAU9C,GAAK8C,EAAE,IAAI,EACnED,IAAiB,KACnB,KAAK,oBAAsBA,EAE/B,CAGQ,oBAAqB,CAC3B,KAAK,oBAAsB,GAC3B,KAAK,kBAAoB,EAC3B,CAEA,QAAS,CACP,GAAI,CAAC,KAAK,OAAQ,OAAOE,IAEzB,MAAM1D,EAAS,GAEf,GAAI,KAAK,OAAO,OAAS,QAAS,CAC9B,MAAME,EAAQ,KAAK,OAAO,UAAY,KAAK,mBAAsB,KAAK,OAAO,QAAQ,CAAC,GAAK,IAAM,KAAK,OAAO,QAAQ,CAAC,GAAK,GACrHC,EAAS,KAAK,OAAO,UAAY,KAAK,iBAAA,EAAsB,KAAK,OAAO,QAAQ,CAAC,GAAK,EAE5F,IAAIC,EAAmBC,EACnB,KAAK,OAAO,UACR,KAAK,UACLD,EAAYD,EAASD,EAAQ,EAC7BG,EAAYF,EAASD,EAAQ,IAE7BE,EAAYD,EACZE,EAAYF,EAASD,IAGzBE,EAAY,KAAK,OAAO,QAAQ,CAAC,GAAK,EACtCC,EAAY,KAAK,OAAO,QAAQ,CAAC,GAAK,GAG1C,MAAMC,EAAcC,GAAgB,CAClC,MAAMC,GAAcD,EAAMH,IAAcC,EAAYD,GACpD,OAAOJ,EAAU,KAAK,IAAI,EAAG,KAAK,IAAI,EAAGQ,CAAU,CAAC,EAAIR,CAC1D,EAEM2D,EAAQrD,EAAW,CAAC,EAGpBsD,EAAY,CAAA,EAClB,GAAI,KAAK,OAAO,SAAU,CACtB,MAAMC,EAAS,KAAK,IAAI,KAAK,IAAIzD,CAAS,EAAG,KAAK,IAAIC,CAAS,CAAC,EAC1DyD,EAAS,KAAK,KAAK,KAAK,KAAKD,CAAM,CAAC,EACpCE,EAAS,KAAK,MAAM,KAAK,KAAK7D,CAAK,CAAC,EAAI,EAE9C,QAASsB,EAAIuC,EAAQvC,GAAKsC,EAAQtC,IAAK,CACrC,MAAMjB,EAAM,KAAK,IAAI,EAAGiB,CAAC,EACrBjB,GAAOF,GAAaE,GAAOH,KAAqB,KAAKE,EAAWC,CAAG,CAAC,EACpE,CAACA,GAAOF,GAAa,CAACE,GAAOH,GAAWwD,EAAU,KAAKtD,EAAW,CAACC,CAAG,CAAC,CAC7E,CACJ,CAEA,OAAOmD;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA,sBASO,KAAK,QAAQ,SAAW,OAAYM;AAAAA;AAAAA,uDAEH,KAAK,OAAO,OAAS,GAAG;AAAA;AAAA;AAAA,uCAGxC,KAAK,OAAO,OAAS,GAAG,kBAAkB,IAAO,KAAK,OAAO,OAAS,GAAI;AAAA;AAAA,sBAEzF,EAAE;AAAA;AAAA;AAAA,kBAGRJ,EAAU,IAAIhD,GAAKoD,kCAAoCpD,CAAC,kBAAkBA,CAAC,MAAM,CAAC;AAAA,qDAC/C+C,CAAK,kBAAkBA,CAAK;AAAA;AAAA;AAAA,kBAG/D,KAAK,QAAQ,SAAW,OAAYK;AAAAA;AAAAA,+BAEvB,KAAK,QAAQ,UAAUhE,CAAM,QAAQA,CAAM;AAAA;AAAA;AAAA;AAAA;AAAA,+BAK3C,KAAK,QAAQ,UAAUA,CAAM,QAAQA,CAAM;AAAA;AAAA;AAAA,kBAGtDgE;AAAAA;AAAAA,+BAEW,KAAK,QAAQ,UAAUhE,CAAM,QAAQA,CAAM;AAAA;AAAA,iBAEzD;AAAA;AAAA;AAAA,yCAGwB,KAAK,QAAQ;AAAA;AAAA;AAAA,kBAGpC,KAAK,QAAQ,UAAU,IAAI,CAACJ,EAASc,IAAM,CACzC,GAAI,CAAC,KAAK,QAAQ,YAAa,MAAO,GAEtC,MAAM+C,EAAI,KAAK,cAAc/C,CAAC,EAC9B,GAAI,CAAC+C,EAAG,MAAO,GAEf,KAAM,CAAE,OAAArC,EAAQ,KAAAC,CAAA,EAASoC,EAGzB,IAAIQ,EAAU,EACVC,EAAa,GAEjB,OAAItE,EAAQ,MAAM,OAAS,gBAMvBqE,GADW,GAAKrE,EAAQ,MAAM,OAAS,IAAM,EAC/BI,EACdkE,EAAa,IAGVA,EAAaF;AAAAA;AAAAA;AAAAA,4DAGoB5C,CAAM,kBAAkBC,EAAOD,CAAM,aAAapB,CAAM;AAAA;AAAA;AAAA,+DAGrDoB,CAAM,SAAS6C,CAAO,SAAS5C,CAAI,SAAS4C,CAAO;AAAA;AAAA;AAAA,mEAG/C7C,GAAUC,EAAOD,GAAU,CAAC,SAAS6C,CAAO;AAAA;AAAA,sBAEvF,EACR,CAAC,CAAC;AAAA;AAAA,SAGd,CAEA,MAAMlE,EAAS,KAAK,cACdgC,EAAkB,GAExB,OAAO2B;AAAAA;AAAAA,+BAEqBhB,GAAoB,KAAK,kBAAkBA,CAAC,CAAC;AAAA,+BAC7CA,GAAoB,KAAK,kBAAkBA,CAAC,CAAC;AAAA,gCAC7C,IAAM,KAAK,mBAAA,CAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBASzC,KAAK,QAAQ,SAAW,OAAYsB;AAAAA;AAAAA,uDAEH,KAAK,OAAO,OAAS,GAAG;AAAA;AAAA;AAAA,uCAGxC,KAAK,OAAO,OAAS,GAAG,kBAAkB,IAAO,KAAK,OAAO,OAAS,GAAI;AAAA;AAAA,sBAEzF,EAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qDAU2BhE,EAAS,CAAC,kBAAkBA,EAAS,CAAC;AAAA;AAAA;AAAA,kBAGzED,EAAO,IAAI0D,GAAK,CAC5B,KAAM,CAAE,QAAA7D,EAAS,OAAAwB,EAAQ,KAAAC,CAAA,EAASoC,EAC5BU,EAAYV,EAAE,QAAU,KAAK,oBAC7BW,EAAiBX,EAAE,QAAU,KAAK,kBAGxC,IAAIQ,EAAU,EAEVC,EAAa,GAEjB,OAAItE,EAAQ,MAAM,OAAS,gBAEzBqE,GADiB,GAAKrE,EAAQ,MAAM,OAAS,IAAM,EAC/BI,EAEpBkE,EAAa,IAGRF;AAAAA;AAAAA,0BAEaG,GAAa,KAAK,QAAQ,YAAcH;AAAAA,uCAC3B5C,CAAM,kBAAkBC,EAAOD,CAAM,aAAapB,CAAM;AAAA;AAAA,0BAEnE,EAAE;AAAA;AAAA;AAAA,0BAGJyD,EAAE,MAAQ1D,EAAO,OAAS,EAAIiE;AAAAA,6DACK3C,CAAI,gBAAgBA,CAAI,SAASrB,CAAM;AAAA,yCAC3DoE,EAAiB,4DAA8D,EAAE;AAAA;AAAA,mEAEvD/C,EAAOU,CAAe,kBAAkBA,EAAkB,CAAC,aAAa/B,CAAM;AAAA,0BACrH,EAAE;AAAA;AAAA;AAAA,0BAGJ,KAAK,QAAQ,aAAekE,EAAaF;AAAAA;AAAAA;AAAAA,gEAGH5C,CAAM,QAAQ6C,CAAO,YAAY5C,EAAOD,CAAM,aAAapB,EAASiE,CAAO;AAAA;AAAA;AAAA,mEAGxE7C,CAAM,SAAS6C,CAAO,SAAS5C,CAAI,SAAS4C,CAAO;AAAA;AAAA,0BAE1F,EAAE;AAAA,qBAE1B,CAAC,CAAC;AAAA;AAAA;AAAA,kBAGY,KAAK,QAAQ,SAAW,OAAYD;AAAAA;AAAAA,+BAEvB,KAAK,QAAQ,UAAUhE,CAAM,QAAQA,CAAM;AAAA;AAAA;AAAA;AAAA;AAAA,+BAK3C,KAAK,QAAQ,UAAUA,CAAM,QAAQA,CAAM;AAAA;AAAA;AAAA,kBAGtDgE;AAAAA;AAAAA,+BAEW,KAAK,QAAQ,UAAUhE,CAAM,QAAQA,CAAM;AAAA;AAAA,iBAEzD;AAAA;AAAA;AAAA,yCAGwB,KAAK,QAAQ;AAAA;AAAA;AAAA,kBAGpC,KAAK,QAAQ,SAAW,QAAa,IAAM,CACzC,MAAMqE,EAAU,KAAK,OAAO,OAAS,IAC/BC,EAAO,KAAK,cAAc,KAAK,OAAO,MAAM,EAI5C,CAACxD,EAAMC,CAAI,EAAI,KAAK,OAAO,OAAS,CAAC,EAAG,CAAC,EACzCwD,GAAeD,EAAOxD,IAASC,EAAOD,GACtC0D,EAAUxE,EAAU,KAAK,IAAI,EAAG,KAAK,IAAI,EAAGuE,CAAW,CAAC,EAAIvE,EAElE,OAAOgE;AAAAA;AAAAA;AAAAA,kCAGOK,CAAO;AAAA,kCACPA,CAAO,SAASrE,CAAM;AAAA;AAAA;AAAA;AAAA;AAAA,sCAKlBqE,CAAO,SAASG,CAAO;AAAA,qBAE7C,GAAA,EAAO,EAAE;AAAA;AAAA,SAGvB,CACF,EAtwBa/G,EAgBJ,OAAS,CACdgH,EACAC;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA,KAkDF,EAlEAC,EAAA,CADCC,EAAS,CAAE,UAAW,EAAA,CAAO,CAAA,EADnBnH,EAEX,UAAA,SAAA,CAAA,EAGAkH,EAAA,CADCC,EAAS,CAAE,KAAM,MAAA,CAAQ,CAAA,EAJfnH,EAKX,UAAA,QAAA,CAAA,EAGAkH,EAAA,CADCC,EAAS,CAAE,KAAM,MAAA,CAAQ,CAAA,EAPfnH,EAQX,UAAA,OAAA,CAAA,EAgLIkH,EAAA,CADHE,CAAA,EAvLUpH,EAwLP,UAAA,cAAA,CAAA,EAKAkH,EAAA,CADHE,CAAA,EA5LUpH,EA6LP,UAAA,gBAAA,CAAA,EAqBAkH,EAAA,CADHE,CAAA,EAjNUpH,EAkNP,UAAA,WAAA,CAAA,EAmMJkH,EAAA,CADCG,CAAA,EApZUrH,EAqZX,UAAA,sBAAA,CAAA,EAGAkH,EAAA,CADCG,CAAA,EAvZUrH,EAwZX,UAAA,oBAAA,CAAA,EAiFQkH,EAAA,CADPI,CAAA,EAxeUtH,EAyeH,UAAA,oBAAA,CAAA,EA2BAkH,EAAA,CADPI,CAAA,EAngBUtH,EAogBH,UAAA,qBAAA,CAAA,EApgBGA,EAANkH,EAAA,CADNK,EAAc,cAAc,CAAA,EAChBvH,CAAA,kMC1BN,IAAMwH,EAAN,cAA6BvH,CAAe,CAA5C,aAAA,CAAA,MAAA,GAAA,SAAA,EAIL,KAAQ,SAAgB,IAAA,CAExB,QAAS,CACP,GAAI,CAAC,KAAK,KAAM,OAAOgG,IAEvB,MAAMwB,EAAWC,EAAsB,YAAY,KAAK,KAAK,OAAO,MAAM,EAC1E,IAAIC,EAAgB,CAClB,OAAQ,CAAC,EAAG,CAAC,EACb,MAAO,CAAC,EAAG,CAAC,EACZ,SAAU,CAAC,CACT,GAAI,KACJ,OAAQ,EACR,MAAO,CAAE,KAAM,cAAe,MAAO,CAAA,CAAE,CACxC,CAAA,EAGH,GAAIF,GAAYA,EAAS,OAAQ,CAC/B,MAAMG,EAAcH,EAAS,OAAO,KAAKxE,GAAKA,EAAE,OAAS,QAAQ,EAC7D2E,GAAeA,EAAY,eAC7BD,EAAgBC,EAAY,aAEhC,CAEA,MAAMC,EAAgB,KAAK,KAAK,OAAO,QAAQ,QAAmDF,EAE5FG,EAAkC,CACtC,OAAQD,EAAa,OACrB,MAAOA,EAAa,MACpB,SAAUA,EAAa,SACvB,YAAa,GACb,mBAAoB,IAAM,CACxB,KAAK,SAAWE,EAAc,cAAc,CAC1C,MAAO,IAAM,CAAE,EACf,OAAQ,IAAM,CAAE,KAAK,SAAW,IAAM,CAAA,CACvC,CACH,EACA,iBAAkB,IAAM,CAClB,KAAK,WACP,KAAK,SAAS,OAAA,EACd,KAAK,SAAW,KAEpB,EACA,gBAAiB,CAACC,EAAWC,EAAOC,IAAU,CAC5C,MAAMC,EAAU,GAAW,CACzB,MAAMC,EAAoBC,EAAKR,CAAY,EACrCS,EAAaD,EAAK,KAAK,KAAK,MAAM,EAClCE,GAAeH,EAAkB,UAAY,CAAA,GAAI,IAAKrG,GACtDA,EAAE,KAAOiG,GACPC,IAAU,QACL,CAAE,GAAGlG,EAAG,MAAO,CAAE,GAAGA,EAAE,MAAO,MAAAmG,EAAa,EAG9CnG,CACR,EACD,EAAE,cAAc,KAAK,KAAK,GAAI,CAAE,OAAQ,CAAE,GAAGuG,EAAW,OAAQ,OAAQ,CAAE,GAAGF,EAAmB,SAAUG,CAAA,CAAY,EAAY,CACpI,EAEI,KAAK,SACP,KAAK,SAAS,WAAWJ,CAAM,EAE/BA,EAAOJ,CAAa,CAExB,EACA,gBAAiB,CAAChC,EAAchB,IAAc,CAC5C,MAAMoD,EAAUK,GAAW,CACzB,MAAMJ,EAAoBC,EAAKR,CAAY,EACrCS,EAAaD,EAAK,KAAK,KAAK,MAAM,EAClCE,EAAc,CAAC,GAAIH,EAAkB,UAAY,CAAA,CAAG,EACtDG,EAAYxC,CAAY,IAC1BwC,EAAYxC,CAAY,EAAI,CAAE,GAAGwC,EAAYxC,CAAY,EAAG,OAAQhB,CAAA,EACpEyD,EAAE,cAAc,KAAK,KAAK,GAAI,CAAE,OAAQ,CAAE,GAAGF,EAAW,OAAQ,OAAQ,CAAE,GAAGF,EAAmB,SAAUG,CAAA,CAAY,EAAY,EAEtI,EAEI,KAAK,SACP,KAAK,SAAS,WAAWJ,CAAM,EAE/BA,EAAOJ,CAAa,CAExB,CAAA,EAIIU,EAASC,EAAe,OAAO,IAAI,KAAK,KAAK,EAAE,EACrD,IAAIC,EAUJ,GATIF,IACIA,EAAO,QAAUA,EAAO,OAAO,QAAa,OAC5CE,EAAcF,EAAO,OAAO,MACrBA,EAAO,UAAYA,EAAO,SAAS,OAAS,IACnDE,EAAcF,EAAO,SAAS,CAAC,IAKnCE,IAAgB,OAAW,CAC3B,KAAM,CAACC,EAAOC,CAAK,EAAIf,EAAa,QAAU,CAAC,EAAG,CAAC,EACnDa,GAAeA,EAAcC,IAAUC,EAAQD,GAC/CD,EAAc,KAAK,IAAI,EAAG,KAAK,IAAI,EAAGA,CAAW,CAAC,CACtD,CAEA,OAAAb,EAAa,OAASa,EAEf1C;AAAAA,4DACiD6B,CAAY;AAAA,KAEtE,CACF,EA5GEZ,EAAA,CADCC,EAAS,CAAE,UAAW,EAAA,CAAO,CAAA,EADnBK,EAEX,UAAA,OAAA,CAAA,EAFWA,EAANN,EAAA,CADNK,EAAc,iBAAiB,CAAA,EACnBC,CAAA,EAgHN,MAAMsB,EAAoB,CAACC,EAAgBC,IACzC/C,2BAA8B8C,CAAI,sBAG9BE,EAAyB,CAACF,EAAgBG,IAE9CjD,0CAGIkD,EAAmBJ,GAAmB"}