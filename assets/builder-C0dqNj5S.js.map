{"version":3,"file":"builder-C0dqNj5S.js","sources":["../../src/customnodes/expr/v2/codegen-js.ts","../../src/customnodes/expr/v2/codegen-cpp.ts","../../src/customnodes/expr/v2/builder.ts"],"sourcesContent":["import { IRGraph, IRNode, OpKind, DataType, DataTypeKind, BlockNode, IfNode, BinaryNode, ConstNode, VarNode, VarDeclNode, AssignNode, ReturnNode, IntrinsicNode, ArrayNode, StructNode, PropAccessNode, PrimitiveType, IndexAccessNode, StructType, PhiNode, UnaryNode, WhileNode, BreakNode, SetPropNode, SetIndexNode } from './ir-types';\n\nexport interface CodeGenOptions {\n  inputs: Record<string, DataType>;\n  outputType?: DataType;\n  debug?: boolean;\n  checkInputs?: boolean;\n}\n\nexport function generateJS(ir: IRGraph, options: CodeGenOptions): string {\n  const lines: string[] = [];\n\n  lines.push('function compute(input, debug_out) {');\n\n  if (options.debug) {\n    lines.push('    function record_debug(line, val) { if(debug_out) debug_out[line] = val; }');\n  }\n\n  if (options.checkInputs && options.inputs) {\n    for (const [key, type] of Object.entries(options.inputs)) {\n      if (type.kind === DataTypeKind.Primitive) {\n        const prim = type as PrimitiveType;\n        if (prim.name === 'number') {\n          lines.push(`    if (typeof input.${key} !== 'number') throw new Error(\"Input '${key}' must be a number\");`);\n        } else if (prim.name === 'boolean') {\n          lines.push(`    if (typeof input.${key} !== 'boolean') throw new Error(\"Input '${key}' must be a boolean\");`);\n        }\n      }\n      // Arrays/Structs checks could be added here\n    }\n  }\n\n  lines.push(emitBlock(ir.root as BlockNode, 1, options));\n\n  lines.push('}');\n\n  lines.push('');\n  lines.push('module.exports = { compute };');\n\n  return lines.join('\\n');\n}\n\nfunction emitBlock(block: BlockNode, indent: number, options: CodeGenOptions): string {\n  const lines: string[] = [];\n  const spaces = '    '.repeat(indent);\n\n  for (const stmt of block.statements) {\n    const code = emitNode(stmt, indent, options);\n    if (!code) continue;\n\n    if (stmt.kind === OpKind.If || stmt.kind === OpKind.Block || stmt.kind === OpKind.While) {\n      lines.push(code.includes('\\n') ? code.split('\\n').map((line, idx) => (idx === 0 ? spaces : spaces) + line).join('\\n') : `${spaces}${code}`);\n    } else {\n      lines.push(`${spaces}${code};`);\n\n      if (options.debug) {\n        if (stmt.kind === OpKind.VarDecl) {\n          const d = stmt as VarDeclNode;\n          if (d.debugInfo) lines.push(`${spaces}record_debug(${d.debugInfo.line}, ${d.name});`);\n        }\n        if (stmt.kind === OpKind.Assign) {\n          const a = stmt as AssignNode;\n          if (a.debugInfo) lines.push(`${spaces}record_debug(${a.debugInfo.line}, ${a.target});`);\n        }\n      }\n    }\n  }\n  return lines.join('\\n');\n}\n\nfunction emitNode(node: IRNode, indent: number, options: CodeGenOptions): string {\n  const inputs = options.inputs;\n\n  switch (node.kind) {\n    case OpKind.Const: {\n      const c = node as ConstNode;\n      if (c.value === null || c.value === undefined) return 'null';\n      if (typeof c.value === 'string') return `\"${c.value}\"`;\n      if (typeof c.value === 'boolean') return String(c.value);\n      if (Array.isArray(c.value)) {\n        const elems = c.value.map((v: any) => {\n          if (typeof v === 'object') return JSON.stringify(v);\n          return String(v);\n        }).join(', ');\n        return `[${elems}]`;\n      }\n      if (typeof c.value === 'object') {\n        if ((c.value as any).node && (c.value as any).closure) return 'null /* Inlined Function */';\n        return JSON.stringify(c.value);\n      }\n      return String(c.value);\n    }\n\n    case OpKind.Array: {\n      const a = node as ArrayNode;\n      const elems = a.elements.map(e => emitNode(e, indent, options)).join(', ');\n      return `[${elems}]`;\n    }\n\n    case OpKind.Var: {\n      const v = node as VarNode;\n      if (inputs[v.name]) return `input.${v.name}`;\n      return v.name;\n    }\n\n    case OpKind.Binary: {\n      const b = node as BinaryNode;\n      return `(${emitNode(b.left, indent, options)} ${b.op} ${emitNode(b.right, indent, options)})`;\n    }\n\n    case OpKind.Unary: {\n      const u = node as UnaryNode;\n      return `(${u.op}${emitNode(u.operand, indent, options)})`;\n    }\n\n    case OpKind.Assign: {\n      const a = node as AssignNode;\n      return `${a.target} = ${emitNode(a.value, indent, options)}`;\n    }\n\n    case OpKind.VarDecl: {\n      const d = node as VarDeclNode;\n      if (d.init) return `let ${d.name} = ${emitNode(d.init, indent, options)}`;\n      return `let ${d.name}`;\n    }\n\n    case OpKind.If: {\n      const i = node as IfNode;\n      const cond = emitNode(i.condition, indent, options);\n      const thenB = emitBlock(i.thenBlock, indent + 1, options);\n      let res = `if (${cond}) {\\n${thenB}\\n${'    '.repeat(indent)}}`;\n      if (i.elseBlock) {\n        const elseB = emitBlock(i.elseBlock, indent + 1, options);\n        res += ` else {\\n${elseB}\\n${'    '.repeat(indent)}}`;\n      }\n      return res;\n    }\n\n    case OpKind.While: {\n      const w = node as WhileNode;\n      const cond = emitNode(w.condition, indent, options);\n      const body = emitBlock(w.body, indent + 1, options);\n      return `while (${cond}) {\\n${body}\\n${'    '.repeat(indent)}}`;\n    }\n\n    case OpKind.Break: return 'break';\n\n    case OpKind.Return: {\n      const r = node as ReturnNode;\n      const val = emitNode(r.value, indent, options);\n      // Coerce to number if outputType dictates it (for parity with C++/WGSL boolean->int/float)\n      if (options.outputType && options.outputType.kind === DataTypeKind.Primitive &&\n        (options.outputType as PrimitiveType).name === 'number') {\n        return `return Number(${val})`;\n      }\n      return `return ${val}`;\n    }\n\n    case OpKind.Phi: {\n      const p = node as PhiNode;\n      return `(${emitNode(p.condition, indent, options)} ? ${emitNode(p.trueValue, indent, options)} : ${emitNode(p.falseValue, indent, options)})`;\n    }\n\n    case OpKind.Intrinsic: {\n      const i = node as IntrinsicNode;\n      if (i.library === 'Array') {\n        if (i.method === 'length') return `${emitNode(i.args[0], indent, options)}.length`;\n        if (i.method === 'get') return `${emitNode(i.args[0], indent, options)}[${emitNode(i.args[1], indent, options)}]`;\n\n        const [obj, ...rest] = i.args;\n        const args = rest.map(a => emitNode(a, indent, options)).join(', ');\n        return `${emitNode(obj, indent, options)}.${i.method}(${args})`;\n      }\n      return `Math.${i.method}(${i.args.map(a => emitNode(a, indent, options)).join(', ')})`;\n    }\n\n    case OpKind.Struct: {\n      const s = node as StructNode;\n      const st = s.type as StructType;\n      const fields = Object.keys(st.fields).map(k => {\n        return `${k}: ${emitNode(s.fields[k], indent, options)}`;\n      });\n      return `{ ${fields.join(', ')} }`;\n    }\n\n    case OpKind.PropAccess: {\n      const p = node as PropAccessNode;\n      return `${emitNode(p.object, indent, options)}.${p.property}`;\n    }\n\n    case OpKind.IndexAccess: {\n      const p = node as IndexAccessNode;\n      return `${emitNode(p.object, indent, options)}[${emitNode(p.index, indent, options)}]`;\n    }\n\n    case OpKind.SetProp: {\n      const sp = node as SetPropNode;\n      return `${emitNode(sp.object, indent, options)}.${sp.property} = ${emitNode(sp.value, indent, options)}`;\n    }\n\n    case OpKind.SetIndex: {\n      const si = node as SetIndexNode;\n      return `${emitNode(si.object, indent, options)}[${emitNode(si.index, indent, options)}] = ${emitNode(si.value, indent, options)}`;\n    }\n\n    case OpKind.Block: {\n      const b = node as BlockNode;\n      return `{\\n${emitBlock(b, indent + 1, options)}\\n${'    '.repeat(indent)}}`;\n    }\n\n    default: return `/* Unknown Op ${node.kind} */`;\n  }\n}\n","import { IRGraph, IRNode, OpKind, DataType, DataTypeKind, BlockNode, IfNode, BinaryNode, ConstNode, VarNode, VarDeclNode, AssignNode, ReturnNode, IntrinsicNode, ArrayNode, StructNode, PropAccessNode, PrimitiveType, IndexAccessNode, StructType, PhiNode, UnaryNode, WhileNode, BreakNode, SetPropNode, SetIndexNode } from './ir-types';\n\nconst NUMBER_TYPE: PrimitiveType = { kind: DataTypeKind.Primitive, name: 'number' };\n\nexport interface CodeGenOptions {\n  inputs: Record<string, DataType>; // Map of input names to types\n  outputType?: DataType; // Expected output type (or inferred)\n  debug?: boolean; // Enable debug source map logging\n}\n\n// Helper to generate canonical name for structural types\nfunction getStructName(type: StructType): string {\n  if (type.name) return type.name;\n  // Canonical name based on fields (User Order)\n  const keys = Object.keys(type.fields);\n  return `Struct_${keys.join('_')}`;\n}\n\nfunction collectStructs(ir: IRGraph, inputs: Record<string, DataType>): Map<string, StructType> {\n  const structs = new Map<string, StructType>();\n\n  function visitType(t: DataType) {\n    if (!t) return;\n    if (t.kind === DataTypeKind.Struct) {\n      const s = t as StructType;\n      const name = getStructName(s);\n      if (!structs.has(name)) {\n        structs.set(name, s);\n        // visit fields\n        Object.values(s.fields).forEach(visitType);\n      }\n    } else if (t.kind === DataTypeKind.Array) {\n      visitType((t as any).elementType);\n    }\n  }\n\n  // scans inputs\n  Object.values(inputs).forEach(visitType);\n\n  // scan nodes\n  function visitNode(n: IRNode) {\n    if (n.type) visitType(n.type);\n    if (n.kind === OpKind.Block) {\n      (n as BlockNode).statements.forEach(visitNode);\n    }\n    if (n.kind === OpKind.If) {\n      visitNode((n as IfNode).condition);\n      visitNode((n as IfNode).thenBlock);\n      if ((n as IfNode).elseBlock) visitNode((n as IfNode).elseBlock!);\n    }\n    // ... recursing all usage ...\n    // Simplification: just scan flat list of nodes if we traverse block?\n    // But what about nested expressions? emitNode recurses.\n    // We need deep traversal.\n    // Let's assume types are captured on nodes.\n  }\n  // We need a proper traverse function or just rely on inputs + declarations?\n  // Constants might imply struct types.\n  // Let's iterate all reachable nodes.\n  const visited = new Set<string>();\n  const stack = [ir.root];\n  while (stack.length) {\n    const n = stack.pop()!;\n    if (!n || typeof n !== 'object') continue; // Defensive\n    // if (visited.has((n as any).id)) continue; // Nodes might not have IDs? IRNode has id.\n    // visited.add((n as any).id);\n\n    if ((n as any).type) visitType((n as any).type);\n\n    // Push children\n    if (n.kind === OpKind.Block) stack.push(...(n as BlockNode).statements);\n    else if (n.kind === OpKind.If) {\n      stack.push((n as IfNode).condition);\n      stack.push((n as IfNode).thenBlock);\n      if ((n as IfNode).elseBlock) stack.push((n as IfNode).elseBlock!);\n    }\n    else if (n.kind === OpKind.Binary) { stack.push((n as BinaryNode).left, (n as BinaryNode).right); }\n    else if (n.kind === OpKind.Assign) { stack.push((n as AssignNode).value); }\n    else if (n.kind === OpKind.Return) { stack.push((n as ReturnNode).value); }\n    else if (n.kind === OpKind.Struct) {\n      const s = n as StructNode;\n      Object.values(s.fields).forEach(f => stack.push(f));\n    }\n    else if (n.kind === OpKind.Array) { stack.push(...(n as ArrayNode).elements); }\n    else if (n.kind === OpKind.PropAccess) { stack.push((n as PropAccessNode).object); }\n    else if (n.kind === OpKind.IndexAccess) { stack.push((n as any).object, (n as any).index); }\n    else if (n.kind === OpKind.Intrinsic) { stack.push(...(n as IntrinsicNode).args); }\n    else if (n.kind === OpKind.VarDecl) { if ((n as VarDeclNode).init) stack.push((n as VarDeclNode).init!); }\n\n  }\n\n  return structs;\n}\n\n// Garbage removed\n\n// Need to allow typeToCpp to be replaced or modified\n// We can shadow it or pass struct map.\n// Simpler: Just rely on getStructName in typeToCpp if we export it or use the new one locally?\n\nfunction typeToCpp(type: DataType): string {\n  switch (type.kind) {\n    case DataTypeKind.Primitive: {\n      const p = type as PrimitiveType;\n      if (p.name === 'number') return 'double';\n      if (p.name === 'boolean') return 'bool';\n      if (p.name === 'void') return 'void';\n      return 'auto';\n    }\n    case DataTypeKind.Array: {\n      const inner = (type as any).elementType;\n      return `std::vector<${typeToCpp(inner)}>`;\n    }\n    case DataTypeKind.Struct: return getStructName(type as any);\n    case DataTypeKind.Union: {\n      const u = type as any;\n      const nonNull = u.types.filter((sub: DataType) =>\n        !(sub.kind === DataTypeKind.Primitive && (sub.name === 'null' || sub.name === 'undefined'))\n      );\n      if (nonNull.length === 1) {\n        return `std::optional<${typeToCpp(nonNull[0])}>`;\n      }\n      if (nonNull.length === 0) {\n        // Pure null/undefined\n        return `std::optional<double>`;\n      }\n      throw new Error(`Complex unions not supported in C++ backend: ${JSON.stringify(type)}`);\n    }\n    default: return 'auto';\n  }\n}\n\nexport function generateCPP(ir: IRGraph, options: CodeGenOptions): string {\n  const lines: string[] = [];\n\n  // Collect Structs\n  const structs = collectStructs(ir, options.inputs);\n\n  // 1. Headers\n  lines.push('#include <iostream>');\n  lines.push('#include <vector>');\n  lines.push('#include <string>');\n  lines.push('#include <cmath>');\n  lines.push('#include <algorithm>');\n  lines.push('#include <optional>');\n  lines.push('#include \"json.hpp\"');\n  lines.push('');\n  lines.push('using json = nlohmann::json;');\n  lines.push('');\n\n  // 1.5 Emit Struct Defs\n\n\n  // 2. Input Struct\n  // 3. Define Types and Serialization\n  structs.forEach((structType, name) => {\n    lines.push(`struct ${name} {`);\n\n    for (const [fname, ftype] of Object.entries(structType.fields)) {\n      lines.push(`    ${typeToCpp(ftype)} ${fname}{};`);\n    }\n    lines.push('};');\n    lines.push(`void to_json(json& j, const ${name}& p) {`);\n    lines.push('    j = json{');\n    const fieldNames = Object.keys(structType.fields);\n    lines.push(fieldNames.map(f => `        {\"${f}\", p.${f}}`).join(',\\n'));\n    lines.push('    };');\n    lines.push('}');\n    lines.push(`void from_json(const json& j, ${name}& p) {`);\n    for (const [fname, ftype] of Object.entries(structType.fields)) {\n      // partial check for optional\n      // If type string starts with std::optional...\n      const cppTypeStr = typeToCpp(ftype);\n      if (cppTypeStr.startsWith('std::optional')) {\n        lines.push(`    if (j.contains(\"${fname}\")) j.at(\"${fname}\").get_to(p.${fname});`);\n      } else {\n        lines.push(`    j.at(\"${fname}\").get_to(p.${fname});`);\n      }\n    }\n    lines.push('}');\n    lines.push('');\n  });\n\n  // Input Struct\n  lines.push('struct Input {');\n  for (const [name, type] of Object.entries(options.inputs)) {\n    lines.push(`    ${typeToCpp(type)} ${name}{};`);\n  }\n  lines.push('};');\n\n  lines.push('void from_json(const json& j, Input& p) {');\n  for (const [name, type] of Object.entries(options.inputs)) {\n    const cppTypeStr = typeToCpp(type);\n    if (cppTypeStr.startsWith('std::optional')) {\n      lines.push(`    if (j.contains(\"${name}\")) j.at(\"${name}\").get_to(p.${name});`);\n    } else {\n      lines.push(`    if (j.contains(\"${name}\")) j.at(\"${name}\").get_to(p.${name});`); // Inputs might be optional in root?\n      // Actually if root input is missing but required, we throw?\n      // Standard get_to throws.\n    }\n  }\n  lines.push('}');\n  lines.push('');\n\n  // 4. Compute Function\n  let retType = 'auto';\n  if (options.outputType) retType = typeToCpp(options.outputType);\n\n  // Debug Scaffolding\n  if (options.debug) {\n    lines.push('json debug_log = json::object();');\n    lines.push('template <typename T> auto to_debug_json(const T& v) { return v; }');\n    lines.push('template <typename T> auto to_debug_json(const std::vector<T>& v) {');\n    lines.push('    if (v.size() > 4) return std::vector<T>(v.begin(), v.begin() + 4);');\n    lines.push('    return v;');\n    lines.push('}');\n    lines.push('template <typename T> void record_debug(int line, const T& val) {');\n    lines.push('    debug_log[std::to_string(line)] = to_debug_json(val);');\n    lines.push('}');\n  }\n\n  lines.push(`${retType} compute(Input& input) {`);\n  // Pass debug option recursively? Or global flag?\n  // emitNode needs access to 'options.debug'.\n  // I must pass options or 'debug' boolean to emitBlock/emitNode.\n  // Currently emitBlock takes (block, indent, inputs).\n  // I need to refactor emitBlock signature or bind it.\n  // I'll update emitBlock signature below.\n  lines.push(emitBlock(ir.root as BlockNode, 1, options));\n  lines.push('}');\n  lines.push('');\n\n  // 6. Main Harness\n  lines.push(`\nint main() {\n    try {\n        json j_in;\n        std::cin >> j_in;\n\n        Input in;\n        if (j_in.contains(\"inputs\")) {\n            j_in[\"inputs\"].get_to(in);\n        } else {\n             // Try root\n             j_in.get_to(in);\n        }\n\n        auto res = compute(in);\n\n        json j_out;\n        j_out[\"outputs\"] = { {\"res\", res} };\n`);\n  if (options.debug) {\n    lines.push('        j_out[\"debug\"] = debug_log;');\n  }\n  lines.push(`        std::cout << j_out.dump(4) << std::endl;`);\n\n  lines.push(`\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n    return 0;\n}\n`);\n\n  return lines.join('\\n');\n}\n\n\nfunction emitBlock(block: BlockNode, indent: number, options: CodeGenOptions): string {\n  const lines: string[] = [];\n  const spaces = '    '.repeat(indent);\n\n  for (const stmt of block.statements) {\n    const code = emitNode(stmt, indent, options);\n    if (code) {\n      if (stmt.kind === OpKind.If || stmt.kind === OpKind.Block || stmt.kind === OpKind.VarDecl || stmt.kind === OpKind.While) {\n        if (options.debug && stmt.kind === OpKind.VarDecl) {\n          lines.push(`${spaces}${code}; `);\n          const d = stmt as VarDeclNode;\n          if (d.debugInfo) lines.push(`${spaces} record_debug(${d.debugInfo.line}, ${d.name}); `);\n        } else {\n          lines.push(code.includes('\\n') ? code.split('\\n').map((line, idx) => (idx === 0 ? spaces : spaces) + line).join('\\n') : `${spaces}${code}${stmt.kind === OpKind.VarDecl ? ';' : ''} `);\n          // If VarDecl (not block/if), it needs semicolon if not provided?\n          // Actually my prev logic was: `lines.push((stmt.kind === OpKind.If || OpKind.Block) ? code : `${spaces}${code};`); `\n          // VarDecl emits `type name = val`. It needs semicolon.\n          // If statement had logic: if (If/Block) push(code) else push(`${ code }; `).\n          // So VarDecl fell into `else `?\n          // Checking prev code line 280: `lines.push(`${spaces}${code}; `); `\n          // So VarDecl was in the semicolon bucket.\n          // But my \"ReplacementContent\" logic for `If` check was: `stmt.kind === OpKind.If || stmt.kind === OpKind.Block || stmt.kind === OpKind.VarDecl`.\n          // If I put VarDecl in the \"no semicolon added\" bucket, I must ensure `emitNode` adds it OR `emitBlock` logic handles it manually.\n          // Best to keep standard logic:\n          // If Block/If: code covers it.\n          // Else: append ;\n        }\n      } else {\n        // Assign, Return, Expr\n        if (code.includes('\\n')) { // e.g. multi-line struct init?\n          lines.push(code.split('\\n').map((line, idx) => (idx === 0 ? spaces : spaces) + line).join('\\n') + ';');\n        } else {\n          lines.push(`${spaces}${code}; `);\n        }\n        // Debug logic for Assign\n        if (options.debug && stmt.kind === OpKind.Assign) {\n          const a = stmt as AssignNode;\n          if (a.debugInfo) lines.push(`${spaces} record_debug(${a.debugInfo.line}, ${a.target}); `);\n        }\n      }\n    }\n  }\n  return lines.join('\\n');\n}\n\nfunction emitNode(node: IRNode, indent: number, options: CodeGenOptions): string {\n  const inputs = options.inputs;\n  switch (node.kind) {\n    case OpKind.Const: {\n      const c = node as ConstNode;\n      if (c.value === null || c.value === undefined) return 'std::nullopt';\n      if (typeof c.value === 'string') return `\"${c.value}\"`;\n      if (typeof c.value === 'boolean') return c.value ? 'true' : 'false';\n      if (Array.isArray(c.value)) {\n        let elemType: DataType | undefined = undefined;\n        if (c.type && c.type.kind === DataTypeKind.Array) {\n          elemType = (c.type as any).elementType;\n        }\n        const elems = c.value.map((v: any) => {\n          if (typeof v === 'number') {\n            const s = String(v);\n            return s.includes('.') ? s : s + '.0';\n          }\n          return emitNode({ kind: OpKind.Const, type: elemType, value: v } as any, indent, options);\n        }).join(', ');\n        return `{ ${elems} } `;\n      }\n      if (typeof c.value === 'object' && c.value && !Array.isArray(c.value)) {\n        if (c.type.kind === DataTypeKind.Struct) {\n          const sType = c.type as StructType;\n          const name = getStructName(sType);\n          const keys = Object.keys(sType.fields);\n          // Value is a JS object { r: 0, i: 0 }\n          const valObj = c.value as any;\n          const args = keys.map(k => {\n            // We need to emit the field value.\n            // Recursively emit const?\n            // Helper: typeToCpp(valObj[k])? No, we need value string.\n            // We can synthesize a ConstNode?\n            // Or simple recursion if we assume primitives?\n            // Let's use emitNode with a synthetic ConstNode used for recursion.\n            // NOTE: We need correct type for the field.\n            // Field type is in sType.fields[k].\n            return emitNode({\n              kind: OpKind.Const,\n              type: sType.fields[k],\n              value: valObj[k],\n              id: 'const_inner'\n            } as any, indent, options);\n          }).join(', ');\n          return `${name}{${args}}`;\n        }\n        return '/* unused_function */ 0';\n      }\n      if (typeof c.value === 'number') {\n        const s = String(c.value);\n        return s.includes('.') ? s : s + '.0';\n      }\n      return String(c.value);\n    }\n    case OpKind.Array: {\n      const a = node as ArrayNode;\n      const elems = a.elements.map(e => emitNode(e, indent, options)).join(', ');\n      return `{ ${elems} } `;\n    }\n    case OpKind.Var: {\n      const v = node as VarNode;\n      if (inputs[v.name]) return `input.${v.name} `;\n      return v.name;\n    }\n    case OpKind.Binary: {\n      const b = node as BinaryNode;\n      const left = emitNode(b.left, indent, options);\n      const right = emitNode(b.right, indent, options);\n      return `(${left} ${b.op} ${right})`;\n    }\n    case OpKind.Return: {\n      const r = node as ReturnNode;\n      return `return ${emitNode(r.value, indent, options)} `;\n    }\n    case OpKind.Assign: {\n      const a = node as AssignNode;\n      return `${a.target} = ${emitNode(a.value, indent, options)} `;\n    }\n    case OpKind.VarDecl: {\n      const d = node as VarDeclNode;\n      let init = '';\n      if (d.init) init = ` = ${emitNode(d.init, indent, options)}`;\n\n      let typeStr = typeToCpp(d.type || NUMBER_TYPE);\n      if (d.type && (d.type.kind === DataTypeKind.Struct || d.type.kind === DataTypeKind.Array)) {\n        if (d.init) {\n          const k = d.init.kind;\n          if (k === OpKind.Var || k === OpKind.IndexAccess || k === OpKind.PropAccess) {\n            typeStr += '&';\n          }\n        }\n      }\n      return `${typeStr} ${d.name}${init}`;\n    }\n    case OpKind.If: {\n      const i = node as IfNode;\n      const cond = emitNode(i.condition, indent, options);\n      const thenB = emitBlock(i.thenBlock, indent + 1, options);\n      let res = `if (${cond}) { \\n${thenB} \\n${'    '.repeat(indent)} } `;\n      if (i.elseBlock) {\n        const elseB = emitBlock(i.elseBlock, indent + 1, options);\n        res += ` else { \\n${elseB} \\n${'    '.repeat(indent)} } `;\n      }\n      return res;\n    }\n    case OpKind.Unary: {\n      const u = node as UnaryNode;\n      const operand = emitNode(u.operand, indent, options);\n      return `(${u.op}${operand})`;\n    }\n    case OpKind.Phi: {\n      const p = node as PhiNode;\n      const cond = emitNode(p.condition, indent, options);\n      const tVal = emitNode(p.trueValue, indent, options);\n      const fVal = emitNode(p.falseValue, indent, options);\n      return `((${cond}) ? (${tVal}) : (${fVal}))`;\n    }\n    case OpKind.While: {\n      const w = node as WhileNode;\n      const cond = emitNode(w.condition, indent, options);\n      const body = emitBlock(w.body, indent + 1, options);\n      return `while (${cond}) {\\n${body}\\n${'    '.repeat(indent)}}`;\n    }\n    case OpKind.Break: return 'break';\n    case OpKind.Intrinsic: {\n      const i = node as IntrinsicNode;\n      // ... Intrinsic Helper needs recursion ...\n      // I'll inline the simple map logic for brevity in replace\n      const simpleMaps: Record<string, string> = {\n        'sin': 'std::sin', 'cos': 'std::cos', 'tan': 'std::tan',\n        'abs': 'std::abs', 'sqrt': 'std::sqrt', 'log': 'std::log',\n        'exp': 'std::exp', 'floor': 'std::floor', 'ceil': 'std::ceil', 'round': 'std::round'\n      };\n      if (i.library === 'Array' && i.method === 'length') {\n        return `${emitNode(i.args[0], indent, options)}.size()`;\n      }\n      if (i.library === 'Array' && i.method === 'push') {\n        return `${emitNode(i.args[0], indent, options)}.push_back(${emitNode(i.args[1], indent, options)})`;\n      }\n      if (simpleMaps[i.method]) {\n        return `${simpleMaps[i.method]} (${emitNode(i.args[0], indent, options)})`;\n      }\n      if (i.method === 'pow') return `std:: pow(${emitNode(i.args[0], indent, options)}, ${emitNode(i.args[1], indent, options)})`;\n      if (i.method === 'min') return `std:: min(${emitNode(i.args[0], indent, options)}, ${emitNode(i.args[1], indent, options)})`;\n      if (i.method === 'max') return `std:: max(${emitNode(i.args[0], indent, options)}, ${emitNode(i.args[1], indent, options)})`;\n      return `/* Unknown Intrinsic */`;\n    }\n    case OpKind.Struct: {\n      const s = node as StructNode;\n      const name = getStructName(s.type as StructType);\n      // Use definition order from type to ensure C++ brace init matches struct layout\n      const st = s.type as StructType;\n      const keys = Object.keys(st.fields);\n      const args = keys.map(k => emitNode(s.fields[k], indent, options)).join(', ');\n      return `${name} {${args} } `;\n    }\n    case OpKind.PropAccess: {\n      const p = node as PropAccessNode;\n      return `${emitNode(p.object, indent, options)}.${p.property} `;\n    }\n    case OpKind.SetProp: {\n      const sp = node as SetPropNode;\n      return `${emitNode(sp.object, indent, options)}.${sp.property} = ${emitNode(sp.value, indent, options)} `;\n    }\n    case OpKind.SetIndex: {\n      const si = node as SetIndexNode;\n      return `${emitNode(si.object, indent, options)}[${emitNode(si.index, indent, options)}] = ${emitNode(si.value, indent, options)} `;\n    }\n    case OpKind.IndexAccess: {\n      const p = node as any;\n      return `${emitNode(p.object, indent, options)} [${emitNode(p.index, indent, options)}]`;\n    }\n    case OpKind.Block: {\n      const b = node as BlockNode;\n      const content = emitBlock(b, indent + 1, options);\n      return `{\\n${content}\\n${'    '.repeat(indent)}}`;\n    }\n    default:\n      return `/* Unknown Op: ${node.kind} */`;\n  }\n}\n","import * as ts from 'typescript';\nimport { compileToIR } from './compiler';\nimport { generateJS } from './codegen-js';\nimport { generateCPP } from './codegen-cpp';\nimport { generateWGSL } from './codegen-wgsl';\nimport { IRGraph, Diagnostic, DataType, DiagnosticSeverity, OpKind, IRNode, BlockNode, ReturnNode, IfNode, WhileNode, DataTypeKind, PrimitiveType } from './ir-types';\n\nexport interface BuildOptions {\n  code: string;\n  emitIR?: boolean;\n  emitJS?: boolean;\n  emitJSRunner?: boolean;\n  emitWGSL?: boolean;\n  emitCPP?: boolean;\n\n  outputType?: DataType; // For coercion (JS) or return type (CPP)\n  debug?: 'none' | 'only' | 'both'; // Debug instrumentation control\n  autoInputs?: boolean; // Automatically define unresolved vars as number inputs\n  containerMode?: 'expression-like' | 'function-body';  // Implicit return support\n\n  // Pass-through options\n  globalInputs?: Record<string, any>;\n}\n\nexport type BuildResult<T extends BuildOptions> = {\n  outIR: T['emitIR'] extends true ? { graph: IRGraph } : undefined;\n\n  outJS: T['emitJS'] extends true ? {\n    code: T['debug'] extends 'only' ? undefined : string;\n    debugCode: T['debug'] extends 'only' | 'both' ? string : undefined;\n  } : undefined;\n\n  outJSRunner: T['emitJSRunner'] extends true ? {\n    runner: T['debug'] extends 'only' ? undefined : (inputs: any, debug?: any) => any;\n    debugRunner: T['debug'] extends 'only' | 'both' ? (inputs: any, debug?: any) => any : undefined;\n  } : undefined;\n\n  outWGSL: T['emitWGSL'] extends true ? {\n    code: T['debug'] extends 'only' ? undefined : string;\n    debugCode: T['debug'] extends 'only' | 'both' ? string : undefined;\n  } : undefined;\n\n  outCPP: T['emitCPP'] extends true ? {\n    code: T['debug'] extends 'only' ? undefined : string;\n    debugCode: T['debug'] extends 'only' | 'both' ? string : undefined;\n  } : undefined;\n\n  diagnostics: Diagnostic[];\n  injectedInputs?: string[]; // Names of auto-injected inputs\n\n  // Reflection Data (Always Available)\n  inputs: Record<string, DataType>;\n  output: DataType;\n};\n\nexport function buildCode<T extends BuildOptions>(opts: T): BuildResult<T> {\n  // Capture diagnostics\n  let diagnostics: Diagnostic[] = [];\n  let currentCode = opts.code;\n  let injectedInputs: string[] = [];\n\n  let sourceFileToUse: ts.SourceFile | undefined;\n\n  // 0. Pre-process code for Container Mode (Implicit Return)\n  if (opts.containerMode === 'expression-like') {\n    const sf = ts.createSourceFile('temp.ts', currentCode, ts.ScriptTarget.Latest, true);\n    let modified = false;\n\n    if (sf.statements.length > 0) {\n      const lastStmt = sf.statements[sf.statements.length - 1];\n      if (ts.isExpressionStatement(lastStmt)) {\n        // Safe wrapping strategy: return (<expr>);\n        const expr = lastStmt.expression;\n        // Use getStart/getEnd to extract the exact expression text, avoiding semicolons\n        const exprStart = expr.getStart(sf);\n        const exprEnd = expr.getEnd();\n\n        // Splice: ... prev code ... return ( <expr> ); ... potential trailing semicolon/comments ...\n        // Note: We need to preserve original text for source maps/debug lines if possible,\n        // but robust return wrapping involves new text.\n        // We replace the statement range with the wrapped version.\n        // Actually, we can just replace the expression part with \"return (...)\".\n        // But what if there's a semicolon after?\n        // \"x + 1;\" -> \"return (x + 1);\"\n        // \"x + 1\"  -> \"return (x + 1)\"\n        // It's safest to construct: code_before + \"return (\" + expr_text + \");\" + code_after\n        // The lastStmt end might include a semicolon.\n\n        const before = currentCode.slice(0, exprStart);\n        const exprText = currentCode.slice(exprStart, exprEnd);\n        const after = currentCode.slice(lastStmt.getEnd());\n\n        // We might lose the original semicolon if we just ignore what's between exprEnd and lastStmt.getEnd().\n        // That's fine, we explicitly add one inside the wrapper.\n        // But comments? sourceFile parsing usually attaches them.\n\n        currentCode = before + 'return (' + exprText + ');' + after;\n        modified = true;\n      }\n    }\n\n    if (!modified) {\n      sourceFileToUse = sf;\n    }\n  }\n\n  // 1. Initial Compile\n  let ir = compileToIR(sourceFileToUse || currentCode, {});\n\n  // 2. Auto-Inputs Logic (Retry Loop)\n  if (opts.autoInputs && ir.diagnostics) {\n    const unresolvedVars = new Set<string>();\n\n    // Scan for \"Unresolved identifier: X\"\n    for (const diag of ir.diagnostics) {\n      const match = diag.message.match(/Unresolved identifier: (\\w+)/);\n      if (match) {\n        unresolvedVars.add(match[1]);\n      }\n    }\n\n    if (unresolvedVars.size > 0) {\n      const newDecls: string[] = [];\n      for (const v of unresolvedVars) {\n        // Enforce 'number' type as per user request\n        newDecls.push(`var ${v}: number;`);\n        injectedInputs.push(v);\n      }\n\n      if (newDecls.length > 0) {\n        // Prepend new declarations\n        currentCode = newDecls.join('\\n') + '\\n' + currentCode;\n\n        // RE-COMPILE\n        ir = compileToIR(currentCode, {});\n      }\n    }\n  }\n\n  if (ir.diagnostics) {\n    diagnostics.push(...ir.diagnostics);\n  }\n\n  const result: any = { diagnostics };\n  if (injectedInputs.length > 0) {\n    result.injectedInputs = injectedInputs;\n  }\n\n  if (opts.emitIR) {\n    result.outIR = { graph: ir };\n  }\n\n  // Common inputs from IR (merged source + global)\n  const inputs: Record<string, DataType> = { ...(ir.inputs || {}) };\n\n  // Ensure injected inputs are treated as inputs\n  for (const name of injectedInputs) {\n    if (!inputs[name]) {\n      inputs[name] = { kind: DataTypeKind.Primitive, name: 'number' } as PrimitiveType;\n    }\n  }\n\n  result.inputs = inputs;\n  result.output = (ir.root && inferReturnType(ir.root)) || { kind: 'primitive', name: 'void' } as any;\n\n  const mode = opts.debug || 'none';\n  const genClean = mode === 'none' || mode === 'both';\n  const genDebug = mode === 'only' || mode === 'both';\n\n  if (opts.emitJS || opts.emitJSRunner) {\n    try {\n      const out: any = {};\n      const outRunner: any = {};\n\n      // Clean Pass\n      if (genClean) {\n        const jsCode = generateJS(ir, {\n          inputs,\n          checkInputs: true,\n          outputType: opts.outputType,\n          debug: false\n        });\n        if (opts.emitJS) out.code = jsCode;\n        if (opts.emitJSRunner) {\n          const body = jsCode.replace('module.exports = { compute };', 'return compute;');\n          outRunner.runner = new Function(body)();\n        }\n      }\n\n      // Debug Pass\n      if (genDebug) {\n        const jsDebug = generateJS(ir, {\n          inputs,\n          checkInputs: true,\n          outputType: opts.outputType,\n          debug: true\n        });\n        if (opts.emitJS) out.debugCode = jsDebug;\n        if (opts.emitJSRunner) {\n          const body = jsDebug.replace('module.exports = { compute };', 'return compute;');\n          outRunner.debugRunner = new Function(body)();\n        }\n      }\n\n      if (opts.emitJS) result.outJS = out;\n      if (opts.emitJSRunner) result.outJSRunner = outRunner;\n\n    } catch (e: any) {\n      diagnostics.push({ message: `JS Codegen Error: ${e.message}`, severity: DiagnosticSeverity.Error, source: 'codegen-js' });\n    }\n  }\n\n  if (opts.emitWGSL) {\n    try {\n      // WGSL doesn't support debug instrumentation yet, so code == debugCode effectively.\n      // But adhering to interface:\n      const wgslCode = generateWGSL(ir, { inputs, outputType: opts.outputType });\n      const out: any = {};\n\n      if (genClean) out.code = wgslCode;\n      if (genDebug) out.debugCode = wgslCode; // Duplicate for now\n\n      result.outWGSL = out;\n    } catch (e: any) {\n      diagnostics.push({ message: `WGSL Codegen Error: ${e.message}`, severity: DiagnosticSeverity.Error, source: 'codegen-wgsl' });\n    }\n  }\n\n  if (opts.emitCPP) {\n    try {\n      const out: any = {};\n\n      if (genClean) {\n        out.code = generateCPP(ir, {\n          inputs,\n          outputType: opts.outputType,\n          debug: false\n        });\n      }\n\n      if (genDebug) {\n        out.debugCode = generateCPP(ir, {\n          inputs,\n          outputType: opts.outputType,\n          debug: true\n        });\n      }\n\n      result.outCPP = out;\n\n    } catch (e: any) {\n      diagnostics.push({ message: `CPP Codegen Error: ${e.message}`, severity: DiagnosticSeverity.Error, source: 'codegen-cpp' });\n    }\n  }\n\n  return result;\n}\n\nfunction inferReturnType(node: IRNode): DataType | null {\n  if (node.kind === OpKind.Return) {\n    return (node as ReturnNode).value.type;\n  }\n  if (node.kind === OpKind.Block) {\n    const block = node as BlockNode;\n    for (const stmt of block.statements) {\n      const t = inferReturnType(stmt);\n      if (t) return t;\n    }\n  }\n  if (node.kind === OpKind.If) {\n    const ifNode = node as IfNode;\n    const t = inferReturnType(ifNode.thenBlock);\n    if (t) return t;\n    if (ifNode.elseBlock) {\n      return inferReturnType(ifNode.elseBlock);\n    }\n  }\n  if (node.kind === OpKind.While) {\n    return inferReturnType((node as WhileNode).body);\n  }\n  return null;\n}\n"],"names":["generateJS","ir","options","lines","key","type","DataTypeKind","prim","emitBlock","block","indent","spaces","stmt","code","emitNode","OpKind","line","idx","d","a","node","inputs","c","v","e","b","u","i","cond","thenB","res","elseB","w","body","val","p","obj","rest","args","s","st","k","sp","si","NUMBER_TYPE","getStructName","collectStructs","structs","visitType","t","name","stack","n","f","typeToCpp","inner","nonNull","sub","generateCPP","structType","fname","ftype","fieldNames","retType","elemType","sType","keys","valObj","left","right","init","typeStr","operand","tVal","fVal","simpleMaps","buildCode","opts","diagnostics","currentCode","injectedInputs","sourceFileToUse","sf","ts.createSourceFile","ts.ScriptTarget","modified","lastStmt","ts.isExpressionStatement","expr","exprStart","exprEnd","before","exprText","after","compileToIR","unresolvedVars","diag","match","newDecls","result","inferReturnType","mode","genClean","genDebug","out","outRunner","jsCode","jsDebug","DiagnosticSeverity","wgslCode","generateWGSL","ifNode"],"mappings":"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"}