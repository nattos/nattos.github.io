import{D as q,O as o,q as u,p as y,u as G,v as Y,w as Z}from"./stdlib-aBcQoNak.js";class j{constructor(e=null,t=!1){this.parent=e,this.isBranchScope=t,this.variables=new Map,this.values=new Map,this.aliases=new Map,this.functions=new Map,this.types=new Map}fork(){return new j(this,!0)}extend(){return new j(this,!1)}snapshot(){const e=new j(null,!1);return e.values=new Map(this.values),e.variables=new Map(this.variables),e.functions=new Map(this.functions),e.types=new Map(this.types),e.aliases=new Map(this.aliases),this.parent&&(e.parent=this.parent.snapshot()),e}declare(e,t){this.variables.set(e,t)}set(e,t){this.values.set(e,t)}declareFunction(e,t){t.body&&this.functions.set(e,t)}assign(e,t){if(this.aliases.has(e)&&this.aliases.delete(e),this.values.has(e)){this.values.set(e,t);return}if(this.parent){this.isBranchScope?this.values.set(e,t):this.parent.assign(e,t);return}this.values.set(e,t)}resolve(e){if(this.variables.has(e))return this.variables.get(e);if(this.parent)return this.parent.resolve(e)}resolveValue(e){if(this.values.has(e))return this.values.get(e);if(this.parent)return this.parent.resolveValue(e)}resolveAlias(e){if(this.aliases.has(e))return this.aliases.get(e);if(this.parent)return this.parent.resolveAlias(e)}invalidateAll(){let e=this;for(;e;){for(const t of e.variables.keys())this.values.set(t,void 0);e=e.parent}}resolveFunction(e){return this.functions.has(e)?this.functions.get(e):this.parent?this.parent.resolveFunction(e):null}static merge(e,t,n,i){}declareType(e,t){this.types.set(e,t)}resolveType(e){if(this.types.has(e))return this.types.get(e);if(this.parent)return this.parent.resolveType(e)}}class H{constructor(e){this.sourceFile=e,this.diagnostics=[],this.depth=0,this.maxDepth=500,this.declaredInputs={},this.scope=new j}addDiagnostic(e,t,n){let i;if(n&&n.getStart){const r=n,l=this.sourceFile.getLineAndCharacterOfPosition(r.getStart()),a=this.sourceFile.getLineAndCharacterOfPosition(r.getEnd());i={startLineNumber:l.line+1,startColumn:l.character+1,endLineNumber:a.line+1,endColumn:a.character+1}}else if(n&&n.debugInfo){const r=n.debugInfo.line;i={startLineNumber:r,startColumn:1,endLineNumber:r,endColumn:1}}this.diagnostics.push({message:e,severity:t,source:"compiler",range:i})}addError(e,t){this.addDiagnostic(e,q.Error,t)}addWarning(e,t){this.addDiagnostic(e,q.Warning,t)}pushScope(){this.scope=this.scope.extend()}popScope(){this.scope.parent&&(this.scope=this.scope.parent)}}function F(s){if(!s)return null;if(s.kind===o.Return)return s.value;if(s.kind===o.Block){const e=s;if(e.statements.length>0)return F(e.statements[e.statements.length-1])}return null}function k(s,e){if(e.depth++,e.depth>e.maxDepth)return(e.diagnostics.length===0||!e.diagnostics[e.diagnostics.length-1].message.includes("Recursion"))&&e.addError(`Recursion depth exceeded (${e.maxDepth})`,s),e.depth--,null;try{switch(s.kind){case u.SyntaxKind.ExpressionStatement:return k(s.expression,e);case u.SyntaxKind.SourceFile:{const t=s,n=[];for(const i of t.statements){const r=k(i,e);r&&n.push(r)}return{id:p(),kind:o.Block,type:m,statements:n}}case u.SyntaxKind.Block:{const t=s;e.pushScope();const n=[];for(const i of t.statements){const r=k(i,e);r&&n.push(r)}return e.popScope(),{id:p(),kind:o.Block,type:m,statements:n}}case u.SyntaxKind.VariableStatement:return k(s.declarationList,e);case u.SyntaxKind.VariableDeclarationList:{const t=s,n=[];return t.declarations.forEach(i=>{const r=i.name.text;let l,a={kind:y.Any};const d=!!(u.getCombinedNodeFlags(i)&u.NodeFlags.Const);if(i.type?a=B(i.type,e):i.initializer&&(l=k(i.initializer,e)||void 0,l&&(a=l.type)),i.initializer&&!l&&(l=k(i.initializer,e)||void 0,l&&!i.type&&(a=l.type)),l&&!d&&(a.kind===y.Array||a.kind===y.Struct)&&(l.kind===o.Var||l.kind===o.PropAccess||l.kind===o.IndexAccess||l.kind===o.SetIndex||l.kind===o.SetProp)){e.scope.aliases.set(r,l),e.scope.declare(r,a);return}if(!l&&e.scope.parent===null&&!e.scope.isBranchScope){e.declaredInputs[r]=a,e.scope.set(r,{id:p(),kind:o.Var,type:a,name:r});return}l&&(!d&&(a.kind===y.Array||a.kind===y.Struct)?e.scope.set(r,{id:p(),kind:o.Var,type:a,name:r}):e.scope.set(r,l)),e.scope.declare(r,a);const{line:f}=e.sourceFile.getLineAndCharacterOfPosition(i.getStart());n.push({id:p(),kind:o.VarDecl,type:a,name:r,init:l,debugInfo:{line:f+1}})}),n.length===0?null:n.length===1?n[0]:{id:p(),kind:o.Block,type:m,statements:n}}case u.SyntaxKind.Identifier:{const t=s.text,n=e.scope.resolveAlias(t);if(n)return{...n};const i=e.scope.resolveValue(t);if(i)return i;const r=e.scope.resolveFunction(t);if(r)return{id:p(),kind:o.Const,type:A,value:{node:r,closure:e.scope.snapshot()}};const l=e.scope.resolve(t);if(!l){const a=Z(t);return a||(t!=="Array"&&(console.log(`Debug: Warn for ${t}`),e.addWarning(`Unresolved identifier: ${t}`,s)),{id:p(),kind:o.Var,type:{kind:y.Any},name:t})}return{id:p(),kind:o.Var,type:l,name:t}}case u.SyntaxKind.NumericLiteral:return{id:p(),kind:o.Const,type:$,value:parseFloat(s.text)};case u.SyntaxKind.StringLiteral:return{id:p(),kind:o.Const,type:{kind:y.Primitive,name:"string"},value:s.text};case u.SyntaxKind.TrueKeyword:return{id:p(),kind:o.Const,type:{kind:y.Primitive,name:"boolean"},value:!0};case u.SyntaxKind.FalseKeyword:return{id:p(),kind:o.Const,type:{kind:y.Primitive,name:"boolean"},value:!1};case u.SyntaxKind.CallExpression:{const t=s,n=G(e,t,k);if(n)return n;if(t.expression.kind===u.SyntaxKind.PropertyAccessExpression){const a=t.expression,c=k(a.expression,e);if(c){const d=Y(e,t,c,k);if(d)return d}}let i=null,r=null;if(t.expression.kind===u.SyntaxKind.Identifier){const a=t.expression.text;i=e.scope.resolveValue(a)||null,i||(r=e.scope.resolveFunction(a))}else i=k(t.expression,e);const l=(a,c,d)=>{const f=[],h=a.typeParameters,g=new Map;for(let S=0;S<a.parameters.length;S++){const b=a.parameters[S],x=b.name.text,w=b.type?B(b.type,e):A;let P=c.arguments[S]?k(c.arguments[S],e):void 0;if(P||(b.initializer?P=k(b.initializer,e)||void 0:b.questionToken&&(P={id:p(),kind:o.Const,type:{kind:y.Primitive,name:"undefined"},value:void 0})),P){if(b.type&&b.type.kind===u.SyntaxKind.TypeReference){const U=b.type.typeName.text;h?.some(z=>z.name.text===U)&&g.set(U,P.type)}f.push({name:x,value:P})}}const K=e.scope;d&&(e.scope=d),e.pushScope();for(const S of f)e.scope.set(S.name,S.value),e.scope.declare(S.name,S.value.type);let T=null;if(a.body)if(a.kind===u.SyntaxKind.ArrowFunction&&a.body.kind!==u.SyntaxKind.Block)T=k(a.body,e);else{const S=a.body,b=[];for(const x of S.statements){const w=k(x,e);w&&b.push(w);const P=F(w);if(P){T=P;break}}!T&&b.length>0?T={id:p(),kind:o.Block,type:m,statements:b}:T&&b.length>1}if(e.popScope(),e.scope=K,T&&a.type&&a.type.kind===u.SyntaxKind.TypeReference){const S=a.type,b=S.typeName.text;if(S.typeArguments&&S.typeArguments.length>0){const x=S.typeArguments[0];if(x.kind===u.SyntaxKind.TypeReference&&g.has(x.typeName.getText())){const w=g.get(x.typeName.getText()),P=Q(b,[w]);return{...T,type:P}}}}return T};if(i){if(i.kind===o.Phi){const a=i,c=d=>{if(d.kind===o.Phi){const f=d,h=c(f.trueValue),g=c(f.falseValue);return!h||!g?null:{id:p(),kind:o.Phi,type:h.type,condition:f.condition,trueValue:h,falseValue:g}}if(d.kind===o.Const&&d.value){const f=d.value;if(f.node&&f.closure)return l(f.node,t,f.closure);if(f.kind)return l(f,t)}return null};return c(a)}if(i.kind===o.Const&&i.value){const a=i.value;if(a.node&&a.closure)return l(a.node,t,a.closure);if(a.kind)return l(a,t)}}return r?l(r,t):(e.addError(`Unsupported dynamic dispatch or unresolved function: ${s.getText()}`,s),null)}case u.SyntaxKind.BinaryExpression:{const t=s;if(t.operatorToken.kind===u.SyntaxKind.EqualsToken||t.operatorToken.kind===u.SyntaxKind.PlusEqualsToken){const c=t.operatorToken.kind===u.SyntaxKind.PlusEqualsToken;let d=k(t.right,e);if(!d)return null;const f=h=>({id:p(),kind:o.Binary,type:$,op:"+",left:h,right:d});if(t.left.kind===u.SyntaxKind.Identifier){const h=t.left.text;if(c){const T=e.scope.resolveValue(h)||{id:p(),kind:o.Var,type:$,name:h};d=f(T)}e.scope.assign(h,d);const{line:g}=e.sourceFile.getLineAndCharacterOfPosition(t.getStart());return{id:p(),kind:o.Assign,type:m,target:h,value:d,debugInfo:{line:g+1}}}else if(t.left.kind===u.SyntaxKind.PropertyAccessExpression){const h=t.left,g=k(h.expression,e);if(!g)return null;const K=h.name.text;if(c){const T={id:p(),kind:o.PropAccess,type:A,object:g,property:K};d=f(T)}return g.kind===o.Phi&&e.addWarning("Mutation of Phi value: Reference origin is ambiguous due to control flow.",s),{id:p(),kind:o.SetProp,type:m,object:g,property:K,value:d}}else if(t.left.kind===u.SyntaxKind.ElementAccessExpression){const h=t.left,g=k(h.expression,e),K=k(h.argumentExpression,e);if(!g||!K)return null;if(c){const T={id:p(),kind:o.IndexAccess,type:A,object:g,index:K};d=f(T)}return g.kind===o.Phi&&e.addWarning("Mutation of Phi value: Reference origin is ambiguous due to control flow. Mutation will apply to audio-rate copy, not original source.",s),{id:p(),kind:o.SetIndex,type:m,object:g,index:K,value:d}}else throw new Error("Assignment target must be Identifier, Property, or Element access")}const n=k(t.left,e),i=k(t.right,e);if(!n||!i)return null;if(n.kind===o.Const&&i.kind===o.Const){const c=n.value,d=i.value;if(typeof c=="number"&&typeof d=="number"){let f=null,h=!1;switch(t.operatorToken.kind){case u.SyntaxKind.PlusToken:f=c+d;break;case u.SyntaxKind.MinusToken:f=c-d;break;case u.SyntaxKind.AsteriskToken:f=c*d;break;case u.SyntaxKind.SlashToken:f=c/d;break;case u.SyntaxKind.PercentToken:f=c%d;break;case u.SyntaxKind.LessThanToken:f=c<d,h=!0;break;case u.SyntaxKind.GreaterThanToken:f=c>d,h=!0;break;case u.SyntaxKind.LessThanEqualsToken:f=c<=d,h=!0;break;case u.SyntaxKind.GreaterThanEqualsToken:f=c>=d,h=!0;break;case u.SyntaxKind.EqualsEqualsToken:f=c==d,h=!0;break;case u.SyntaxKind.ExclamationEqualsToken:f=c!=d,h=!0;break;case u.SyntaxKind.EqualsEqualsEqualsToken:f=c===d,h=!0;break;case u.SyntaxKind.ExclamationEqualsEqualsToken:f=c!==d,h=!0;break}if(f!==null)return{id:p(),kind:o.Const,type:h?V:$,value:f}}}let r="?";switch(t.operatorToken.kind){case u.SyntaxKind.PlusToken:r="+";break;case u.SyntaxKind.MinusToken:r="-";break;case u.SyntaxKind.AsteriskToken:r="*";break;case u.SyntaxKind.SlashToken:r="/";break;case u.SyntaxKind.LessThanToken:r="<";break;case u.SyntaxKind.GreaterThanToken:r=">";break;case u.SyntaxKind.LessThanEqualsToken:r="<=";break;case u.SyntaxKind.GreaterThanEqualsToken:r=">=";break;case u.SyntaxKind.EqualsEqualsToken:r="==";break;case u.SyntaxKind.ExclamationEqualsToken:r="!=";break;case u.SyntaxKind.AmpersandAmpersandToken:r="&&";break;case u.SyntaxKind.BarBarToken:r="||";break}const a=["<",">","<=",">=","==","!=","&&","||"].includes(r)?V:$;return{id:p(),kind:o.Binary,type:a,op:r,left:n,right:i}}case u.SyntaxKind.PostfixUnaryExpression:case u.SyntaxKind.PrefixUnaryExpression:{const t=s,n=t.operand,i=k(n,e);if(!i)return null;if((t.operator===u.SyntaxKind.PlusPlusToken||t.operator===u.SyntaxKind.MinusMinusToken)&&n.kind===u.SyntaxKind.Identifier){const l=n.text;if(i.kind===o.Const&&typeof i.value=="number"){const a=i.value,c=t.operator===u.SyntaxKind.PlusPlusToken?a+1:a-1,d={id:p(),kind:o.Const,type:$,value:c};return e.scope.assign(l,d),s.kind===u.SyntaxKind.PrefixUnaryExpression?d:i}else{const a=t.operator===u.SyntaxKind.PlusPlusToken?"+":"-",c={id:p(),kind:o.Const,type:$,value:1},d={id:p(),kind:o.Binary,type:$,op:a,left:i,right:c},f={id:p(),kind:o.Assign,type:m,target:l,value:d,debugInfo:i.debugInfo};return e.scope.assign(l,d),f}}let r="";if(t.operator===u.SyntaxKind.MinusToken?r="-":t.operator===u.SyntaxKind.ExclamationToken?r="!":t.operator===u.SyntaxKind.TildeToken&&(r="~"),r){if(i.kind===o.Const){const l=i.value;if(r==="-"&&typeof l=="number")return{id:p(),kind:o.Const,type:$,value:-l};if(r==="!"&&(typeof l=="boolean"||typeof l=="number"))return{id:p(),kind:o.Const,type:V,value:!l};if(r==="~"&&typeof l=="number")return{id:p(),kind:o.Const,type:$,value:~l}}return{id:p(),kind:o.Unary,type:i.type,op:r,operand:i}}return i}case u.SyntaxKind.ParenthesizedExpression:return k(s.expression,e);case u.SyntaxKind.ObjectLiteralExpression:{const t=s,n={},i={};let r=!0;for(const l of t.properties)if(l.kind===u.SyntaxKind.PropertyAssignment){const a=l.name.text,c=k(l.initializer,e);c&&(n[a]=c,i[a]=c.type,c.kind!==o.Const&&(r=!1))}if(r){const l={};for(const a in n)l[a]=n[a].value;return{id:p(),kind:o.Const,type:{kind:y.Struct,fields:i},value:l}}return{id:p(),kind:o.Struct,type:{kind:y.Struct,fields:i},fields:n}}case u.SyntaxKind.ArrayLiteralExpression:{const t=s,n=[];let i=A,r=!0;for(const l of t.elements){const a=k(l,e);a&&(n.push(a),n.length===1&&(i=a.type),a.kind!==o.Const&&(r=!1))}if(r){const l=n.map(a=>a.value);if(i.kind===y.Any&&l.length>0){const a=R(l[0]);a&&(i=a)}return{id:p(),kind:o.Const,type:{kind:y.Array,elementType:i,length:l.length},value:l}}return{id:p(),kind:o.Array,type:{kind:y.Array,elementType:i,length:n.length},elements:n}}case u.SyntaxKind.NullKeyword:return{id:p(),kind:o.Const,type:{kind:y.Primitive,name:"null"},value:null};case u.SyntaxKind.UndefinedKeyword:return{id:p(),kind:o.Const,type:{kind:y.Primitive,name:"undefined"},value:void 0};case u.SyntaxKind.PropertyAccessExpression:{const t=s,n=k(t.expression,e),i=t.name.text;if(!n)return null;if(n.kind===o.Struct){const l=n;if(l.fields[i])return l.fields[i]}if(n.kind===o.Const&&typeof n.value=="object"&&n.value!==null){const l=n.value[i];if(l!==void 0){const a=R(l)||A;return{id:p(),kind:o.Const,type:a,value:l}}}let r=A;if(n.type.kind===y.Struct){const l=n.type;l.fields[i]&&(r=l.fields[i])}return n.type.kind===y.Array&&i==="length"?{id:p(),kind:o.Intrinsic,type:$,library:"Array",method:"length",args:[n]}:{id:p(),kind:o.PropAccess,type:r,object:n,property:i}}case u.SyntaxKind.ElementAccessExpression:{const t=s,n=k(t.expression,e),i=k(t.argumentExpression,e);if(!n||!i)return null;const r=i.kind===o.Const?i.value:void 0;if(typeof r=="number"){if(n.kind===o.Array){const a=n;if(a.elements[r])return a.elements[r]}if(n.kind===o.Const&&Array.isArray(n.value)){const a=n.value[r];if(a!==void 0){const c=R(a)||A;return{id:p(),kind:o.Const,type:c,value:a}}}}let l=A;return n.type.kind===y.Array&&(l=n.type.elementType||A),{id:p(),kind:o.IndexAccess,type:l,object:n,index:i}}case u.SyntaxKind.InterfaceDeclaration:{const t=s,n=t.name.text,i={};t.members.forEach(l=>{if(u.isPropertySignature(l)&&l.name){const a=l.name.text||"unknown";let c=l.type?B(l.type,e):A;if(l.questionToken){const d={kind:y.Primitive,name:"undefined"};c={kind:y.Union,types:[c,d]}}i[a]=c}});const r={kind:y.Struct,name:n,fields:i};return e.scope.declareType(n,r),null}case u.SyntaxKind.FunctionDeclaration:{const t=s;return t.name&&e.scope.declareFunction(t.name.text,t),{id:p(),kind:o.Const,type:m,value:null}}case u.SyntaxKind.ArrowFunction:case u.SyntaxKind.FunctionExpression:{const t=s;return{id:p(),kind:o.Const,type:A,value:{node:t,closure:e.scope.snapshot()}}}case u.SyntaxKind.BreakStatement:return{id:p(),kind:o.Break,type:m};case u.SyntaxKind.WhileStatement:{const t=s;e.scope.invalidateAll();const n=k(t.expression,e);if(!n)return null;const i=k(t.statement,e);let r;return i&&i.kind===o.Block?r=i:r={id:p(),kind:o.Block,type:m,statements:i?[i]:[]},e.scope.invalidateAll(),{id:p(),kind:o.While,type:m,condition:n,body:r}}case u.SyntaxKind.ReturnStatement:{const t=s;let n=null;return t.expression&&(n=k(t.expression,e)),{id:p(),kind:o.Return,type:n?.type||m,value:n||{id:"void",kind:o.Const,type:m,value:null}}}case u.SyntaxKind.IfStatement:{const t=s,n=k(t.expression,e);if(!n)return null;if(n.kind===o.Const)return n.value?k(t.thenStatement,e):t.elseStatement?k(t.elseStatement,e):{id:p(),kind:o.Block,type:m,statements:[]};const i=e.scope,r=i.fork();e.scope=r;let l=k(t.thenStatement,e),a;l&&l.kind===o.Block?a=l:a={id:p(),kind:o.Block,type:m,statements:l?[l]:[]};let c;if(t.elseStatement){const d=i.fork();e.scope=d;const f=k(t.elseStatement,e);f&&f.kind===o.Block?c=f:c={id:p(),kind:o.Block,type:m,statements:f?[f]:[]},e.scope=i,X(i,r,d,n)}else e.scope=i,ee(i,r,n);return e.scope=i,{id:p(),kind:o.If,type:m,condition:n,thenBlock:a,elseBlock:c}}case u.SyntaxKind.ForStatement:{const t=s,n=e.scope,i=n.extend();e.scope=i;const r=t.initializer?k(t.initializer,e):null;let l=t.condition?k(t.condition,e):null;if(l&&l.kind===o.Const){const c=[];let d=0;for(;d<100;){const f=t.condition?k(t.condition,e):null;if(f&&f.kind===o.Const&&!f.value)break;const h=k(t.statement,e);h&&c.push(h),t.incrementor&&k(t.incrementor,e),d++}return e.scope=n,{id:p(),kind:o.Block,type:m,statements:c}}else{e.scope.invalidateAll();const c=t.condition?k(t.condition,e):{id:p(),kind:o.Const,type:V,value:!0},d=k(t.statement,e),f=t.incrementor?k(t.incrementor,e):null,h=[];d&&(d.kind===o.Block?h.push(...d.statements):h.push(d)),f&&h.push(f);const g={id:p(),kind:o.While,type:m,condition:c,body:{id:p(),kind:o.Block,type:m,statements:h}},K=[];return r&&K.push(r),K.push(g),e.scope=n,{id:p(),kind:o.Block,type:m,statements:K}}}default:return e.addWarning(`Unsupported syntax kind: ${u.SyntaxKind[s.kind]}`,s),null}}finally{e.depth--}}let J=0;function p(){return`ir${J++}`}function B(s,e){if(s.kind===u.SyntaxKind.NumberKeyword)return $;if(s.kind===u.SyntaxKind.BooleanKeyword)return V;if(s.kind===u.SyntaxKind.StringKeyword)return W;if(s.kind===u.SyntaxKind.VoidKeyword)return m;if(s.kind===u.SyntaxKind.UndefinedKeyword)return{kind:y.Primitive,name:"undefined"};if(s.kind===u.SyntaxKind.NullKeyword)return{kind:y.Primitive,name:"null"};if(u.isArrayTypeNode(s)){const t=B(s.elementType,e);return{kind:y.Array,elementType:t}}if(u.isLiteralTypeNode(s)&&s.literal.kind===u.SyntaxKind.NullKeyword)return{kind:y.Primitive,name:"null"};if(u.isUnionTypeNode(s)){const t=s.types.map(n=>B(n,e));return{kind:y.Union,types:t}}if(u.isTypeLiteralNode(s)){const t={};return s.members.forEach(n=>{if(u.isPropertySignature(n)&&n.name){const i=n.name.text;let r=n.type?B(n.type,e):A;if(n.questionToken){const l={kind:y.Primitive,name:"undefined"};r={kind:y.Union,types:[r,l]}}t[i]=r}}),{kind:y.Struct,fields:t}}if(u.isTypeReferenceNode(s)){const t=s.typeName.text;if(t==="Array"&&s.typeArguments&&s.typeArguments.length>0)return{kind:y.Array,elementType:B(s.typeArguments[0],e)};const n=e.scope.resolveType(t);if(n)return n}return A}const W={kind:y.Primitive,name:"string"},m={kind:y.Primitive,name:"void"},$={kind:y.Primitive,name:"number"},V={kind:y.Primitive,name:"boolean"},A={kind:y.Any},Q=(s,e)=>({kind:y.GenericInstantiation,base:s,args:e});function R(s){return typeof s=="number"?$:typeof s=="boolean"?V:typeof s=="string"?W:null}function X(s,e,t,n){const i=new Set([...e.values.keys(),...t.values.keys()]);for(const r of i){const l=e.values.get(r)||s.resolveValue(r)||s.resolveAlias(r),a=t.values.get(r)||s.resolveValue(r)||s.resolveAlias(r);if(l&&a&&l!==a){if(l.kind===o.Const&&a.kind===o.Const&&l.value===a.value){s.assign(r,l);continue}const c=s.resolveValue(r)||s.resolveAlias(r);if(l===c&&a===c)continue;const d={id:p(),kind:o.Phi,type:l.type,condition:n,trueValue:l,falseValue:a};s.assign(r,d)}}}function ee(s,e,t){const n=new Set([...e.values.keys()]);for(const i of n){const r=e.values.get(i),l=s.resolveValue(i)||s.resolveAlias(i);if(r!==l&&l){const a={id:p(),kind:o.Phi,type:r.type,condition:t,trueValue:r,falseValue:l};s.assign(i,a)}}}function ae(s,e={}){let t;typeof s=="string"?t=u.createSourceFile("expr.ts",s,u.ScriptTarget.ES2015,!0):t=s;const n=new H(t),i=t.parseDiagnostics||[];for(const a of i){const c=typeof a.messageText=="string"?a.messageText:a.messageText.messageText;let d;if(a.start!==void 0&&a.length!==void 0){const f=t.getLineAndCharacterOfPosition(a.start),h=t.getLineAndCharacterOfPosition(a.start+a.length);d={startLineNumber:f.line+1,startColumn:f.character+1,endLineNumber:h.line+1,endColumn:h.character+1}}n.diagnostics.push({message:`TS Error: ${c}`,severity:q.Error,source:"ts-parser",range:d})}for(const[a,c]of Object.entries(e))n.scope.declare(a,c),n.scope.set(a,{id:p(),kind:o.Var,type:c,name:a});let r;try{const a=k(t,n);a&&a.kind===o.Block?r=a:a?r={id:p(),kind:o.Block,type:m,statements:[a]}:r={id:p(),kind:o.Block,type:m,statements:[]}}catch(a){n.addError(`Internal Compiler Error: ${a.message}`),r={id:p(),kind:o.Block,type:m,statements:[]}}const l={...e,...n.declaredInputs};return{root:r,diagnostics:n.diagnostics,inputs:l}}const L="f32",ne="bool";function O(s){return s.replace(/[^a-zA-Z0-9_]/g,"_")}function te(s,e){const t=new Map;function n(r){if(r)if(r.kind===y.Struct){const l=r,a=N(l);t.has(a)||(t.set(a,l),Object.values(l.fields).forEach(n))}else r.kind===y.Array&&n(r.elementType)}Object.values(e).forEach(n),n(ie());const i=[s.root];for(;i.length;){const r=i.pop();!r||typeof r!="object"||(r.type&&n(r.type),r.kind===o.Block?i.push(...r.statements):r.kind===o.If?(i.push(r.condition,r.thenBlock),r.elseBlock&&i.push(r.elseBlock)):r.kind===o.While&&i.push(r.condition,r.body))}return t}function N(s){return s.name?s.name:`Struct_${Object.keys(s.fields).sort().join("_")}`}function C(s){switch(s.kind){case y.Primitive:{const e=s;return e.name==="number"?L:e.name==="boolean"?ne:e.name==="void"?"void":L}case y.Array:{const e=s.elementType,t=s.length;if(typeof t=="number"){const n=C(e);return n===L&&(t===2||t===3||t===4)?`vec${t}<f32>`:`array<${n}, ${t}>`}return`array<${C(e)}>`}case y.Struct:return N(s);default:return L}}function ie(s){return{kind:y.Primitive,name:"void"}}function oe(s,e){const t=[];t.push("diagnostic(off, derivative_uniformity);"),t.push(""),te(s,e.inputs).forEach((a,c)=>{t.push(`struct ${c} {`);const d=Object.keys(a.fields).sort();d.length===0?t.push("    _dummy: f32,"):d.forEach(f=>{t.push(`    ${f}: ${C(a.fields[f])},`)}),t.push("};"),t.push("")}),t.push("struct Input {");const i=Object.entries(e.inputs);i.filter(([a,c])=>c.kind===y.Array).length>1;const l=i.sort((a,c)=>{const d=a[1].kind===y.Array,f=c[1].kind===y.Array;return d&&!f?1:!d&&f?-1:0});if(l.length===0)t.push("    _dummy: f32,");else for(const[a,c]of l)t.push(`    ${a}: ${C(c)},`);return t.push("};"),t.push(""),t.push("struct Output {"),e.outputType?t.push(`    result: ${C(e.outputType)},`):t.push("    result: f32,"),t.push("};"),t.push(""),t.push("@group(0) @binding(0) var<storage, read_write> input: Input;"),t.push("@group(0) @binding(1) var<storage, read_write> output: Output;"),t.push(""),t.push("@compute @workgroup_size(1)"),t.push("fn main() {"),t.push("    _ = &input;"),t.push("    _ = &output;"),t.push(I(s.root,1,e)),t.push("}"),t.join(`
`)}function I(s,e,t){const n=[],i="    ".repeat(e);for(const r of s.statements){if(r.kind===o.Return){const a=r;let c=v(a.value,t,t.outputType);t.outputType&&t.outputType.kind===y.Primitive&&t.outputType.name==="number"&&E(a.value,t)&&(c=`select(0.0, 1.0, ${c})`),n.push(`${i}output.result = ${c};`),n.push(`${i}return;`);continue}const l=v(r,t);l&&(r.kind===o.If||r.kind===o.While||r.kind===o.Block?n.push(l.includes(`
`)?l.split(`
`).map((a,c)=>i+a).join(`
`):`${i}${l}`):r.kind!==o.Const&&n.push(`${i}${l};`))}return n.join(`
`)}function D(s,e,t,n){if(n&&n.kind===e.kind&&e.kind===y.Struct){const i=e,r=n;!i.name&&r.name&&(e=r)}if(typeof s=="number"){const i=String(s);return i.includes(".")?i:i+".0"}if(typeof s=="boolean")return String(s);if(Array.isArray(s)){const i=e.elementType,r=s.map(l=>D(l,i,t,i)).join(", ");return`${C(e)}(${r})`}if(typeof s=="object"&&s!==null&&e.kind===y.Struct){const i=N(e),l=Object.keys(e.fields).sort().map(a=>D(s[a],e.fields[a],t,e.fields[a])).join(", ");return`${i}(${l})`}return"0.0"}function E(s,e){if(s.kind===o.Const)return typeof s.value=="boolean";if(s.kind===o.Binary){const t=s;return["==","!=","<",">","<=",">="].includes(t.op)?!0:["&&","||"].includes(t.op)?E(t.left,e)&&E(t.right,e):!1}if(s.kind===o.Unary)return s.op==="!";if(s.kind===o.Var){const t=s;if(e.inputs[t.name]){const n=e.inputs[t.name];if(n.kind===y.Primitive&&n.name==="boolean")return!0}}return!!(s.type&&s.type.kind===y.Primitive&&s.type.name==="boolean")}function _(s,e){return E(s,e)?`select(0.0, 1.0, ${v(s,e)})`:v(s,e)}function M(s,e){return E(s,e)?v(s,e):`(${v(s,e)} != 0.0)`}function v(s,e,t){switch(s.kind){case o.Const:{const n=s;if(typeof n.value=="number"){const i=String(n.value);return i.includes(".")?i:i+".0"}return typeof n.value=="boolean"?String(n.value):typeof n.value=="object"||Array.isArray(n.value)?D(n.value,n.type,e,t):"0.0"}case o.Var:{const n=s;return e.inputs[n.name]?`input.${n.name}`:O(n.name)}case o.Binary:{const n=s;if(n.op==="&&"||n.op==="||"){const i=E(n.left,e),r=E(n.right,e);if(!i||!r){const l=_(n.left,e),a=_(n.right,e);if(n.op==="||")return`select(${a}, ${l}, ${l} != 0.0)`;if(n.op==="&&")return`select(${l}, ${a}, ${l} != 0.0)`}}return`(${v(n.left,e)} ${n.op} ${v(n.right,e)})`}case o.Unary:{const n=s;return n.op==="!"?`!${M(n.operand,e)}`:`${n.op}${v(n.operand,e)}`}case o.Assign:{const n=s;return`${O(n.target)} = ${v(n.value,e)}`}case o.VarDecl:{const n=s,i=n.type&&(n.type.kind===y.Struct||n.type.kind===y.Array),r=n.init&&(n.init.kind===o.Var||n.init.kind===o.PropAccess||n.init.kind===o.IndexAccess);if(i&&r)return`let ${O(n.name)} = &${v(n.init,e,n.type)}`;n.type&&n.type.kind===y.Array&&typeof n.type.length>"u"&&n.init&&n.init.kind===o.Array&&(n.type.length=n.init.elements.length),n.type&&n.type.kind===y.Array&&typeof n.type.length>"u"&&n.init&&n.init.kind===o.Const&&Array.isArray(n.init.value)&&(n.type.length=n.init.value.length);let l=C(n.type||{kind:y.Primitive,name:"number"}),a=n.init?` = ${v(n.init,e,n.type)}`:"";return n.type&&n.type.name==="number"&&n.init&&E(n.init,e)&&(a=` = select(0.0, 1.0, ${v(n.init,e,n.type)})`),`var ${O(n.name)} : ${l}${a}`}case o.While:{const n=s;return`while (${M(n.condition,e)}) {
${I(n.body,1,e)}
}`}case o.If:{const n=s;let i=`if (${M(n.condition,e)}) {
${I(n.thenBlock,1,e)}
}`;return n.elseBlock&&(i+=` else {
${I(n.elseBlock,1,e)}
}`),i}case o.Block:return`{
${I(s,1,e)}
}`;case o.Intrinsic:{const n=s;if(n.library==="Array"&&n.method==="length"){const i=n.args[0];return i.type&&i.type.kind===y.Array&&typeof i.type.length=="number"?`${i.type.length}.0`:`f32(arrayLength(&${v(i,e)}))`}return`${n.method}(${n.args.map(i=>v(i,e)).join(", ")})`}case o.PropAccess:{const n=s;return`${v(n.object,e)}.${n.property}`}case o.SetProp:{const n=s;return`${v(n.object,e)}.${n.property} = ${v(n.value,e)}`}case o.SetIndex:{const n=s;return`${v(n.object,e)}[i32(${v(n.index,e)})] = ${v(n.value,e)}`}case o.IndexAccess:{const n=s;return`${v(n.object,e)}[i32(${v(n.index,e)})]`}case o.Struct:{const n=s;let i=n.type;if(t&&t.kind===y.Struct){const a=t;!i.name&&a.name&&(i=a)}const r=N(i);if(!r)return"/* Anonymous Struct */";const l=Object.keys(i.fields).sort().map(a=>n.fields[a]?v(n.fields[a],e,i.fields[a]):"0");return`${r}(${l.join(", ")})`}case o.Array:{const n=s;return`${C(n.type)}(${n.elements.map(r=>v(r,e,n.type.elementType)).join(", ")})`}case o.Break:return"break;";default:return`/* Unknown ${s.kind} */`}}export{ae as c,oe as g};
//# sourceMappingURL=codegen-wgsl-CST6uU3w.js.map
