(function(){"use strict";class F{constructor(){this.items=[]}push(r,h){this.items.push({key:r,fScore:h}),this.bubbleUp(this.items.length-1)}pop(){if(this.items.length===0)return;const r=this.items[0],h=this.items.pop();return this.items.length>0&&h&&(this.items[0]=h,this.bubbleDown(0)),r}size(){return this.items.length}bubbleUp(r){for(;r>0;){const h=Math.floor((r-1)/2);if(this.items[r].fScore>=this.items[h].fScore)break;this.swap(r,h),r=h}}bubbleDown(r){const h=this.items.length,M=this.items[r];for(;;){let $=2*r+1,T=2*r+2,n,E,v=null;if($<h&&(n=this.items[$],n.fScore<M.fScore&&(v=$)),T<h&&(E=this.items[T],(v===null&&E.fScore<M.fScore||v!==null&&E.fScore<n.fScore)&&(v=T)),v===null)break;this.swap(r,v),r=v}}swap(r,h){const M=this.items[r];this.items[r]=this.items[h],this.items[h]=M}}function G(g,r){return g&65535|r<<16}function C(g){return{x:g&65535,y:g>>>16}}function N(g,r){return g.x===r.x&&g.y===r.y}function W(g,r={}){const h=[],M={},$=new Set,T=new Map,n=32;for(const e of r.obstacles||[]){const o=e.x*2+1,d=e.y*n;if(e.height&&e.height>1){T.set(`${o},${e.y}`,e.height);const f=Math.min(e.height,31);for(let y=0;y<f;y++)$.add(G(o,d+y))}else T.set(`${o},${e.y}`,1),$.add(G(o,d))}const E=e=>({x:e.x*2+1,y:e.y*n}),v=new Map;for(const e of g){const o={x:e.start.x*2+2,y:e.start.y*n+(e.startOffset||0)},d={x:e.end.x*2,y:e.end.y*n+(e.endOffset||0)};let f=[];if(N(o,d))f=[o];else{const y=new F,s=new Map,t=new Map,i=G(o.x,o.y),x=G(d.x,d.y);t.set(i,0);const S=(R,b)=>Math.abs(R-d.x)+Math.abs(b-d.y);y.push(i,S(o.x,o.y));const c=new Set,l=-1,p=Math.max(o.y,d.y)+256;let I=0;const k=5e4;for(;y.size()>0;){if(I++,I>k){console.warn(`WireLayout: A* Safety Limit Reached (${k}) for wire ${e.id}`);break}const R=y.pop();if(!R)break;const b=R.key;if(b===x){let u=b;for(f=[C(u)];s.has(u);)u=s.get(u),f.unshift(C(u));break}if(c.has(b))continue;c.add(b);const m=C(b),a=[m.x+1,m.x-1],Y=[m.y,m.y];m.x%2===0&&(m.y>l&&(a.push(m.x),Y.push(m.y-1)),m.y<p&&(a.push(m.x),Y.push(m.y+1)));for(let u=0;u<a.length;u++){const L=a[u],A=Y[u];if(A<l||A>p)continue;const B=G(L,A);if(c.has(B))continue;let P=1;const X=B===x;if($.has(B)&&!X)continue;const z=s.get(b);if(z!==void 0){const O=C(z);O.x!==L&&O.y!==A&&(P+=1,m.x%2===0&&(P+=20))}const _=(t.get(b)||0)+P;if(_<(t.get(B)||1/0)){s.set(B,b),t.set(B,_);const O=_+S(L,A);y.push(B,O)}}}}if(f.length===0&&(f=[o,d]),f.length>0){const y=[f[0]];for(let s=1;s<f.length;s++){const t=y[y.length-1],i=f[s];N(t,i)||y.push(i)}f=y}M[e.id]={path:f};for(const y of f){const s=G(y.x,y.y);v.set(s,(v.get(s)||0)+1)}}const D=new Map,w=n-1;for(const e of g){const o=M[e.id].path;if(!o||o.length===0)continue;const d=E(e.start);h.push({id:`${e.id}-start`,wireId:e.id,x:d.x,y:d.y+(e.startOffset||0),type:"start",lane:0,totalLanes:1,length:1});const f=E(e.end),y=f.y+(e.endOffset||0);h.push({id:`${e.id}-end`,wireId:e.id,x:f.x,y,type:"end",lane:0,totalLanes:1,length:1});for(let s=0;s<o.length;s++){const t=o[s],i=G(t.x,t.y),x=v.get(i)||1,S=D.get(i)||0;D.set(i,S+1);const c=s>0?o[s-1]:null,l=s<o.length-1?o[s+1]:null;let p="h";if(c&&l){const a=t.x-c.x,Y=t.y-c.y,u=l.x-t.x,L=l.y-t.y;a!==0&&u!==0?p="h":Y!==0&&L!==0?p="v":a===1&&L>0?p="ctr":a===1&&L<0?p="cbr":a===-1&&L>0?p="ctl":a===-1&&L<0||Y>0&&u===1?p="cbl":Y>0&&u===-1?p="cbr":Y<0&&u===1?p="ctl":Y<0&&u===-1&&(p="ctr")}else if(!c)l?p=l.x!==t.x?"h":"v":p="h",l&&(l.y<t.y?p="cbr":l.y>t.y&&(p="ctr"));else if(!l&&c){const a=f.x>t.x;c.y<t.y?p=a?"cbl":"cbr":c.y>t.y?p=a?"ctl":"ctr":p="h"}let I,k;const R=Math.floor(t.y/n);if(t.y%n<w){if(c&&c.x===t.x&&c.y<t.y){const a=Math.floor(c.y/n);a===R?c.y%n<w&&(I=c.y%n):a===R-1&&c.y%n===w&&(I=-1)}l&&l.x===t.x&&l.y>t.y&&Math.floor(l.y/n)===R&&(l.y%n<w?k=l.y%n:l.y%n===w&&(k=w)),c&&c.x===t.x&&c.y>t.y&&Math.floor(c.y/n)===R&&(c.y%n<w?k=c.y%n:c.y%n===w&&(k=w)),l&&l.x===t.x&&l.y<t.y&&Math.floor(l.y/n)===R&&l.y%n<w&&(I=l.y%n)}else c&&c.x===t.x&&c.y<t.y&&(I=-1);h.push({id:`${e.id}-${s}`,wireId:e.id,x:t.x,y:t.y,type:p,lane:S+1,totalLanes:x,length:1,clipTopRem:I,clipBotRem:k})}}const U=[],K=new Map;for(const e of h){const o=Math.floor(e.y/n),d=e.y%n;let f="";d<w?f=`${e.wireId}:${e.x}:${o}:node`:f=`${e.wireId}:${e.x}:${o}:gap`,K.has(f)||K.set(f,[]),K.get(f).push(e)}for(const[e,o]of K.entries()){const d=o.some(s=>s.type!=="h"&&s.type!=="v"&&s.type!=="start"&&s.type!=="end"),f=(s,t)=>s===void 0&&t!==void 0||s!==void 0&&t!==void 0&&s<t,y=(s,t)=>s===void 0&&t!==void 0||s!==void 0&&t!==void 0&&s>t;if(d){const s=o.filter(i=>i.type==="v"),t=o.filter(i=>i.type!=="v"&&i.type!=="h"&&i.type!=="start"&&i.type!=="end");for(const i of t)if(i.type==="cbl"||i.type==="cbr")for(const x of s)f(x.clipTopRem,i.clipTopRem)&&(i.clipTopRem=x.clipTopRem);else if(i.type==="ctl"||i.type==="ctr")for(const x of s)y(x.clipBotRem,i.clipBotRem)&&(i.clipBotRem=x.clipBotRem);for(const i of o)i.type!=="v"&&U.push(i)}else{const s=o.filter(i=>i.type==="v"),t=o.filter(i=>i.type!=="v");if(s.length>0){let i={...s[0]};for(let x=1;x<s.length;x++){const S=s[x];f(S.clipTopRem,i.clipTopRem)&&(i.clipTopRem=S.clipTopRem),y(S.clipBotRem,i.clipBotRem)&&(i.clipBotRem=S.clipBotRem)}U.push(i)}U.push(...t)}}return{segments:U,wires:M}}const H=self;H.onmessage=g=>{const{type:r,wires:h,options:M}=g.data;if(r==="LAYOUT_REQUEST"){const T={type:"LAYOUT_RESULT",layout:W(h,M)};H.postMessage(T)}}})();
//# sourceMappingURL=wire-layout.worker-DK4aiM0G.js.map
